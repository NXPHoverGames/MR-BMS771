From e45b57ac570f934407f9680f4e19fb4f0cee2c6b Mon Sep 17 00:00:00 2001
From: nxf63123 <cis.van.mierlo@nxp.com>
Date: Thu, 22 May 2025 07:52:26 +0200
Subject: [PATCH] nuttx patch BMS7.0

---
 arch/arm/src/s32k1xx/Kconfig                  |  273 ++++
 .../arm/src/s32k1xx/hardware/s32k14x_dmamux.h |   86 ++
 .../arm/src/s32k1xx/hardware/s32k1xx_dmamux.h |   10 +-
 arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h  |    6 +-
 arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h |   60 +-
 .../src/s32k1xx/hardware/s32k1xx_memorymap.h  |    4 +-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.c    |   32 +-
 arch/arm/src/s32k1xx/s32k1xx_clockconfig.h    |   21 +-
 arch/arm/src/s32k1xx/s32k1xx_edma.c           |  235 ++--
 arch/arm/src/s32k1xx/s32k1xx_edma.h           |   33 +-
 arch/arm/src/s32k1xx/s32k1xx_flexcan.c        |  105 +-
 arch/arm/src/s32k1xx/s32k1xx_lpi2c.c          |  899 +++++++++---
 arch/arm/src/s32k1xx/s32k1xx_lpspi.c          |  445 +++++-
 arch/arm/src/s32k1xx/s32k1xx_pminitialize.c   |    5 +
 arch/arm/src/s32k1xx/s32k1xx_serial.c         | 1212 ++++++++++++++---
 arch/arm/src/s32k1xx/s32k1xx_serial.h         |  109 ++
 boards/Kconfig                                |   12 +
 boards/arm/s32k1xx/mr-bms771/Kconfig          |   27 +
 boards/arm/s32k1xx/mr-bms771/README.txt       |  142 ++
 .../s32k1xx/mr-bms771/configs/bms/defconfig   |  142 ++
 .../mr-bms771/configs/bmsdebug/defconfig      |  150 ++
 .../mr-bms771/configs/bmstrace/defconfig      |  159 +++
 .../s32k1xx/mr-bms771/configs/nsh/defconfig   |   43 +
 boards/arm/s32k1xx/mr-bms771/include/board.h  |  156 +++
 .../s32k1xx/mr-bms771/include/nsh_romfsimg.h  |   90 ++
 .../mr-bms771/include/rc.sysinit.template     |    8 +
 .../s32k1xx/mr-bms771/include/rcS.template    |    7 +
 .../arm/s32k1xx/mr-bms771/include/smbus_sbd.h |  201 +++
 .../arm/s32k1xx/mr-bms771/scripts/Make.defs   |   49 +
 boards/arm/s32k1xx/mr-bms771/scripts/flash.ld |  139 ++
 .../s32k1xx/mr-bms771/scripts/mr-bms771.jlink |   21 +
 .../arm/s32k1xx/mr-bms771/scripts/s32k146.cfg |   61 +
 boards/arm/s32k1xx/mr-bms771/scripts/sram.ld  |  116 ++
 boards/arm/s32k1xx/mr-bms771/src/Makefile     |   70 +
 boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h  |  162 +++
 .../s32k1xx/mr-bms771/src/s32k1xx_appinit.c   |   82 ++
 .../s32k1xx/mr-bms771/src/s32k1xx_autoleds.c  |  150 ++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c  |   82 ++
 .../s32k1xx/mr-bms771/src/s32k1xx_bringup.c   |  242 ++++
 .../mr-bms771/src/s32k1xx_clockconfig.c       |  181 +++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c  |  494 +++++++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c   |   84 ++
 .../mr-bms771/src/s32k1xx_nrstcheck_procfs.c  |  329 +++++
 .../mr-bms771/src/s32k1xx_periphclocks.c      |  148 ++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c |   66 +
 .../s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c |  925 +++++++++++++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c   |  169 +++
 .../s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c   |  113 ++
 .../arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c   |   67 +
 .../s32k1xx/mr-bms771/src/s32k1xx_userleds.c  |  122 ++
 .../rddrone-bms772/configs/bms/defconfig      |  143 ++
 .../rddrone-bms772/configs/bmsdebug/defconfig |  149 ++
 .../rddrone-bms772/configs/bmstrace/defconfig |  158 +++
 .../rddrone-bms772/include/rcS.template       |    7 +-
 .../rddrone-bms772/src/rddrone-bms772.h       |    4 -
 .../rddrone-bms772/src/s32k1xx_clockconfig.c  |    1 -
 .../src/s32k1xx_nrstcheck_procfs.c            |    3 +
 .../rddrone-bms772/src/s32k1xx_periphclocks.c |   12 +
 net/can/can_recvmsg.c                         |    6 +-
 net/utils/net_lock.c                          |    2 +-
 sched/semaphore/sem_trywait.c                 |    7 +-
 61 files changed, 8404 insertions(+), 632 deletions(-)
 create mode 100644 arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
 create mode 100644 boards/arm/s32k1xx/mr-bms771/Kconfig
 create mode 100644 boards/arm/s32k1xx/mr-bms771/README.txt
 create mode 100644 boards/arm/s32k1xx/mr-bms771/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/mr-bms771/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/mr-bms771/configs/bmstrace/defconfig
 create mode 100644 boards/arm/s32k1xx/mr-bms771/configs/nsh/defconfig
 create mode 100644 boards/arm/s32k1xx/mr-bms771/include/board.h
 create mode 100644 boards/arm/s32k1xx/mr-bms771/include/nsh_romfsimg.h
 create mode 100644 boards/arm/s32k1xx/mr-bms771/include/rc.sysinit.template
 create mode 100644 boards/arm/s32k1xx/mr-bms771/include/rcS.template
 create mode 100644 boards/arm/s32k1xx/mr-bms771/include/smbus_sbd.h
 create mode 100644 boards/arm/s32k1xx/mr-bms771/scripts/Make.defs
 create mode 100644 boards/arm/s32k1xx/mr-bms771/scripts/flash.ld
 create mode 100644 boards/arm/s32k1xx/mr-bms771/scripts/mr-bms771.jlink
 create mode 100644 boards/arm/s32k1xx/mr-bms771/scripts/s32k146.cfg
 create mode 100644 boards/arm/s32k1xx/mr-bms771/scripts/sram.ld
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/Makefile
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_appinit.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_autoleds.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_bringup.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_clockconfig.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_nrstcheck_procfs.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_periphclocks.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c
 create mode 100644 boards/arm/s32k1xx/mr-bms771/src/s32k1xx_userleds.c
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
 create mode 100644 boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig

diff --git a/arch/arm/src/s32k1xx/Kconfig b/arch/arm/src/s32k1xx/Kconfig
index 57ee616db5..cbeae097f4 100644
--- a/arch/arm/src/s32k1xx/Kconfig
+++ b/arch/arm/src/s32k1xx/Kconfig
@@ -200,6 +200,7 @@ menu "S32K1XX Peripheral Selection"
 config S32K1XX_EDMA
 	bool "eDMA"
 	default n
+	select ARCH_DMA
 
 config S32K1XX_ENET
 	bool "Ethernet"
@@ -634,12 +635,102 @@ config S32K1XX_LPSPI_DWORD
 	bool "DWORD up to 64 bit transfer support"
 	default n
 
+config S32K1XX_LPSPI_DMA
+	bool "SPI DMA"
+	depends on S32K1XX_EDMA
+	default n
+	---help---
+		Use DMA to improve SPI transfer performance.
+
+config S32K1XX_LPSPI0_DMA
+	bool "LPSPI0 DMA"
+	default n
+	depends on S32K1XX_LPSPI0 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI0 transfer performance.
+
+config S32K1XX_LPSPI1_DMA
+	bool "LPSPI1 DMA"
+	default n
+	depends on S32K1XX_LPSPI1 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI1 transfer performance.
+
+config S32K1XX_LPSPI2_DMA
+	bool "LPSPI2 DMA"
+	default n
+	depends on S32K1XX_LPSPI2 && S32K1XX_LPSPI_DMA
+	---help---
+		Use DMA to improve LPSPI2 transfer performance.
+
+config S32K1XX_LPSPI_DMATHRESHOLD
+	int "SPI DMA threshold"
+	default 4
+	depends on S32K1XX_LPSPI_DMA
+	---help---
+		When SPI DMA is enabled, small DMA transfers will still be performed
+		by polling logic.  But we need a threshold value to determine what
+		is small.
+
+
 config S32K1XX_LPSPI_HWPCS
 	bool "Use native hardware peripheral chip selects instead of GPIO pins"
 	default n
 	
 endmenu # LPSPI Configuration
 
+menu "LPI2C Configuration"
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_DMA
+	bool "I2C DMA Support"
+	default n
+	depends on S32K1XX_LPI2C && S32K1XX_EDMA && !I2C_POLLED
+	---help---
+		This option enables the DMA for I2C transfers.
+		Note: The user can define CONFIG_I2C_DMAPRIO: a custom priority value
+		for the I2C dma streams, else the default priority level is set to
+		medium.
+
+config S32K1XX_LPI2C_DMA_MAXMSG
+	int "Maximum number messages that will be DMAed"
+	default 8
+	depends on S32K1XX_LPI2C_DMA
+	---help---
+		This option set the mumber of mesg that can be in a transfer.
+		It is used to allocate space for the 16 bit LPI2C commands
+		that will be DMA-ed to the LPI2C device.
+
+config S32K1XX_LPI2C_DYNTIMEO
+	bool "Use dynamic timeouts"
+	default n
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_DYNTIMEO_USECPERBYTE
+	int "Timeout Microseconds per Byte"
+	default 500
+	depends on S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_DYNTIMEO_STARTSTOP
+	int "Timeout for Start/Stop (Milliseconds)"
+	default 1000
+	depends on S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_TIMEOSEC
+	int "Timeout seconds"
+	default 0
+	depends on S32K1XX_LPI2C
+
+config S32K1XX_LPI2C_TIMEOMS
+	int "Timeout Milliseconds"
+	default 500
+	depends on S32K1XX_LPI2C && !S32K1XX_LPI2C_DYNTIMEO
+
+config S32K1XX_LPI2C_TIMEOTICKS
+	int "Timeout for Done and Stop (ticks)"
+	default 500
+	depends on S32K1XX_LPI2C && !S32K1XX_LPI2C_DYNTIMEO
+
 menu "LPI2C0 Master Configuration"
 	depends on S32K1XX_LPI2C0
 
@@ -647,6 +738,11 @@ config LPI2C0_BUSYIDLE
 	int "Bus idle timeout period in clock cycles"
 	default 0
 
+config LPI2C0_DMA
+	bool "Enable DMA for I2C0"
+	default n
+	depends on S32K1XX_LPI2C_DMA
+
 config LPI2C0_FILTSCL
 	int "I2C master digital glitch filters for SCL input in clock cycles"
 	default 0
@@ -677,6 +773,11 @@ endmenu # LPI2C0 Slave Configuration
 menu "LPI2C1 Master Configuration"
 	depends on S32K1XX_LPI2C1
 
+config LPI2C1_DMA
+	bool "Enable DMA for I2C1"
+	default n
+	depends on S32K1XX_LPI2C_DMA
+
 config LPI2C1_BUSYIDLE
 	int "Bus idle timeout period in clock cycles"
 	default 0
@@ -707,6 +808,23 @@ config LPI2C1_SLAVE_BUS
 		the LPI2C master.  These pins need to be defined in the board.h.
 
 endmenu # LPI2C1 Slave Configuration
+endmenu # LPI2C Configuration
+
+menu "LPUART Configuration"
+comment "LP Uart Driver Configuration"
+
+
+config S32K1XX_LPUART_RXDMA_BUFFER_SIZE
+	int "Rx DMA buffer size"
+	default 64
+	depends on LPUART0_RXDMA || LPUART1_RXDMA || LPUART2_RXDMA
+	---help---
+		The DMA buffer size when using RX DMA to emulate a FIFO.
+
+		When streaming data, the generic serial layer will be called
+		every time the FIFO receives half this number of bytes.
+
+endmenu # LPUART Configuration
 
 menu "Ethernet Configuration"
 	depends on S32K1XX_ENET
@@ -855,4 +973,159 @@ config PROGMEM_SIZE
 
 endmenu
 
+menu "arch PM configuration"
+depends on PM
+
+menu "PM configuration for PM_STANDBY mode"
+
+choice
+	prompt "MCU power mode during PM_STANDBY"
+	default VLPR_STANDBY
+
+config RUN_STANDBY
+	bool "MCU in RUN mode during PM_STANDBY"
+	---help---
+		The MCU should remain in RUN mode during PM_STANDBY
+
+config VLPR_STANDBY
+	bool "MCU in VLPR mode during PM_STANDBY"
+	---help---
+		The MCU should enter VLPR (very low power run) mode during PM_STANDBY
+
+endchoice # MCU power mode
+
+menuconfig PM_SPI_STANDBY
+	bool "Enable SPI in PM_STANDBY mode"
+	default n
+	depends on SPI
+	---help---
+		Enable PM configuration for SPI
+
+if PM_SPI_STANDBY
+
+config PM_SPI0_STANDBY
+	bool "Enable LPSPI0 in PM_STANDBY mode"
+	default n
+	depends on S32K1XX_LPSPI0
+
+config PM_SPI1_STANDBY
+	bool "Enable LPSPI1 in PM_STANDBY mode"
+	default n
+	depends on S32K1XX_LPSPI1
+
+endif # PM_SPI_STANDBY
+
+menuconfig PM_SERIAL_STANDBY
+	bool "Enable serial in PM_STANDBY mode"
+	default n
+	depends on SERIAL
+	---help---
+		Enable PM configuration for SERIAL
+
+if PM_SERIAL_STANDBY
+
+config PM_CONSOLE_STANDBY
+	bool "Enable serial console in PM_STANDBY"
+	default n
+	depends on SERIAL_CONSOLE
+	select PM_SERIAL0_STANDBY if LPUART0_SERIAL_CONSOLE
+	select PM_SERIAL1_STANDBY if LPUART1_SERIAL_CONSOLE
+	select PM_SERIAL2_STANDBY if LPUART2_SERIAL_CONSOLE
+
+config PM_SERIAL0_STANDBY
+	bool "Enable LPUART0 in PM_STANDBY mode"
+	default n
+	depends on S32K1XX_LPUART0
+
+config PM_SERIAL1_STANDBY
+	bool "Enable LPUART1 in PM_STANDBY mode"
+	default n
+	depends on S32K1XX_LPUART1
+
+config PM_SERIAL2_STANDBY
+	bool "Enable LPUART2 in PM_STANDBY mode"
+	default n
+	depends on S32K1XX_LPUART2
+
+endif # PM_SERIAL_STANDBY
+
+endmenu # PM configuration for PM_STANDBY mode
+
+menu "PM configuration for PM_SLEEP mode"
+
+choice
+	prompt "MCU power mode during PM_SLEEP"
+	default VLPR_SLEEP
+
+config RUN_SLEEP
+	bool "MCU in RUN mode during PM_SLEEP"
+	---help---
+		The MCU should remain in RUN mode during PM_SLEEP
+
+config VLPR_SLEEP
+	bool "MCU in VLPR mode during PM_SLEEP"
+	---help---
+		The MCU should enter VLPR (very low power run) mode during PM_SLEEP
+
+endchoice # MCU power mode
+
+menuconfig PM_SPI_SLEEP
+	bool "Enable SPI in PM_SLEEP mode"
+	default n
+	depends on SPI
+	---help---
+		Enable PM configuration for SPI
+
+if PM_SPI_SLEEP
+
+menuconfig PM_SPI0_SLEEP
+	bool "Enable LPSPI0 in PM_SLEEP"
+	default n
+	depends on S32K1XX_LPSPI0
+
+menuconfig PM_SPI1_SLEEP
+	bool "Enable LPSPI1 in PM_SLEEP"
+	default n
+	depends on S32K1XX_LPSPI1
+
+endif # PM_SPI_SLEEP
+
+menuconfig PM_SERIAL_SLEEP
+	bool "Enable serial in PM_SLEEP mode"
+	default n
+	depends on SERIAL
+	---help---
+		Enable PM configuration for SERIAL
+
+if PM_SERIAL_SLEEP
+
+config PM_CONSOLE_SLEEP
+	bool "Enable serial console in PM_SLEEP"
+	default n
+	depends on SERIAL_CONSOLE
+	select PM_SERIAL0_SLEEP if LPUART0_SERIAL_CONSOLE
+	select PM_SERIAL1_SLEEP if LPUART1_SERIAL_CONSOLE
+	select PM_SERIAL2_SLEEP if LPUART2_SERIAL_CONSOLE
+
+config PM_SERIAL0_SLEEP
+	bool "Enable LPUART0 in PM_SLEEP mode"
+	default n
+	depends on S32K1XX_LPUART0
+
+config PM_SERIAL1_SLEEP
+	bool "Enable LPUART1 in PM_SLEEP mode"
+	default n
+	depends on S32K1XX_LPUART1
+
+config PM_SERIAL2_SLEEP
+	bool "Enable LPUART2 in PM_SLEEP mode"
+	default n
+	depends on S32K1XX_LPUART2
+
+endif # PM_SERIAL_SLEEP
+
+endmenu # PM configuration for PM_SLEEP mode
+
+endmenu # arch PM configuration
+
 endif # ARCH_CHIP_S32K1XX
diff --git a/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h b/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
new file mode 100644
index 0000000000..d4dab6eeba
--- /dev/null
+++ b/arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
@@ -0,0 +1,86 @@
+/****************************************************************************
+ * arch/arm/src/s32k1xx/hardware/s32k14x_dmamux.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+#ifndef __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H
+#define __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Peripheral DMA request channels */
+
+#define S32K1XX_DMACHAN_DISABLED                   0  /* Disabled DMA Request */
+#define S32K1XX_DMACHAN_LPUART0_RX                 2  /* lpuart0  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART0_TX                 3  /* lpuart0  Transmit DMA Request */
+#define S32K1XX_DMACHAN_LPUART1_RX                 4  /* lpuart1  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART1_TX                 5  /* lpuart1  Transmit DMA Request */
+#define S32K1XX_DMACHAN_LPUART2_RX                 6  /* lpuart2  Receive DMA Request */
+#define S32K1XX_DMACHAN_LPUART2_TX                 7  /* lpuart2  Transmit DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER0            10 /* flexio FlexIO Shifter0 DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER1            11 /* flexio FlexIO Shifter1 DMA Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER2            12 /* flexio / SAI1  FlexIO Shifter2 DMA Request / SAI1 DMA RX Request */
+#define S32K1XX_DMACHAN_FLEXIO_SHIFTER3            13 /* flexio / SAI1  FlexIO Shifter3 DMA Request / SAI1 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI0_RX                  14 /* lpspi0 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI0_TX                  15 /* lpspi0 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI1_RX                  16 /* lpspi1 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI1_TX                  17 /* lpspi1 DMA TX Request */
+#define S32K1XX_DMACHAN_LPSPI2_RX                  18 /* lpspi2 DMA RX Request */
+#define S32K1XX_DMACHAN_LPSPI2_TX                  19 /* lpspi2 DMA TX Request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_0             20 /* ftm1 Channel 0 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_1             21 /* ftm1 Channel 1 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_2             22 /* ftm1 Channel 2 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_3             23 /* ftm1 Channel 3 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_4             24 /* ftm1 Channel 4 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_5             25 /* ftm1 Channel 5 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_6             26 /* ftm1 Channel 6 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM1_CHANNEL_7             27 /* ftm1 Channel 7 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_0             28 /* ftm2 Channel 0 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_1             29 /* ftm2 Channel 1 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_2             30 /* ftm2 Channel 2 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_3             31 /* ftm2 Channel 3 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_4             32 /* ftm2 Channel 4 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_5             33 /* ftm2 Channel 5 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_6             34 /* ftm2 Channel 6 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM2_CHANNEL_7             35 /* ftm2 Channel 7 DMA transfer request */
+#define S32K1XX_DMACHAN_FTM0_OR_CH0_CH7            36 /* ftm0 'OR' of FTM0 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM3_OR_CH0_CH7            37 /* ftm3 'OR' of FTM3 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM4_OR_CH0_CH7            38 /* ftm4 'OR' of FTM4 channel 0 - 7 */
+#define S32K1XX_DMACHAN_FTM5_OR_CH0_CH7            39 /* ftm5 'OR' of FTM5 channel 0 - 7 */
+#define S32K1XX_DMACHAN_ADC0                       42 /* ftm6 'OR' of FTM6 channel 0 - 7 */
+#define S32K1XX_DMACHAN_ADC1                       43 /* ftm7 'OR' of FTM7 channel 0 - 7 */
+#define S32K1XX_DMACHAN_LPI2C0_RX                  44 /* lpi2c0 DMA RX Request */
+#define S32K1XX_DMACHAN_LPI2C0_TX                  45 /* lpi2c0 DMA TX Request */
+#define S32K1XX_DMACHAN_PDB0                       46 /* pdb0 DMA request */
+#define S32K1XX_DMACHAN_PDB1                       47 /* pdb1 DMA request */
+#define S32K1XX_DMACHAN_CMP0                       48 /* cmp0 DMA request */
+#define S32K1XX_DMACHAN_PORTA                      49 /* PORT PORTA DMA request */
+#define S32K1XX_DMACHAN_PORTB                      50 /* PORT PORTB DMA request */
+#define S32K1XX_DMACHAN_PORTC                      51 /* PORT PORTC DMA request */
+#define S32K1XX_DMACHAN_PORTD                      52 /* PORT PORTD DMA request */
+#define S32K1XX_DMACHAN_PORTE                      53 /* PORT PORTE DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN0                   54 /* flexcan0 DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN1                   55 /* flexcan1 DMA request */
+#define S32K1XX_DMACHAN_FLEXCAN2                   56 /* flexcan2 DMA request */
+#define S32K1XX_DMACHAN_LPTMR0                     59 /* lptmr0 LPTIMER DMA request */
+#define S32K1XX_DMACHAN_DMAMUX_ALWAYS_ENABLED0     62 /* Always On DMA request */
+#define S32K1XX_DMACHAN_DMAMUX_ALWAYS_ENABLED1     63 /* Always On DMA request */
+
+#endif /* __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K14X_DMAMUX_H */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
index 577bb2d0e8..3e97643b3e 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_dmamux.h
@@ -28,6 +28,12 @@
 #include <nuttx/config.h>
 #include <hardware/s32k1xx_memorymap.h>
 
+#if defined(CONFIG_ARCH_CHIP_S32K11X)
+#  include <hardware/s32k11x_dmamux.h>
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
+#  include <hardware/s32k14x_dmamux.h>
+#endif
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -36,7 +42,7 @@
 
 #if defined(CONFIG_ARCH_CHIP_S32K11X)
 #  define S32K1XX_NDMACH  4
-#elif defined(CONFIG_ARCH_CHIP_S32K14X
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
 #  define S32K1XX_NDMACH  16
 #endif
 
@@ -46,7 +52,7 @@
 
 /* DMAMUX Register Addresses ************************************************/
 
-#define S32K1XX_DMAMUX_CHCFG(n)         (S32K1XX_DMAMUX_BASE + S32K1XX_DMAMUX_CHCFG_OFFSET(n)) n=1..15 */
+#define S32K1XX_DMAMUX_CHCFG(n)         (S32K1XX_DMAMUX_BASE + S32K1XX_DMAMUX_CHCFG_OFFSET(n)) /* n=1..15 */
 
 /* DMAMUX Register Bitfield Definitions *************************************/
 
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
index 1d8604584c..ff9bad7d4f 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_edma.h
@@ -34,7 +34,7 @@
 
 #if defined(CONFIG_ARCH_CHIP_S32K11X)
 #  define S32K1XX_EDMA_NCHANNELS              4
-#elif defined(CONFIG_ARCH_CHIP_S32K14x)
+#elif defined(CONFIG_ARCH_CHIP_S32K14X)
 #  define S32K1XX_EDMA_NCHANNELS              16
 #else
 #  error "Unknown number of DMA channels for this S32K1xx part"
@@ -837,8 +837,8 @@
  * Public Types
  ****************************************************************************/
 
-/* In-memory representation of the 32-byte Transfer Control Descriptor
- * (TCD)
+/* Hardware representation of the 32-byte Transfer
+ * Control Descriptor (TCD)
  */
 
 struct s32k1xx_edmatcd_s
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
index b9740b7ccc..dbdc70255a 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_lpi2c.h
@@ -239,7 +239,7 @@
 /* LPI2C Master Config Register 1  */
 
 #define LPI2C_MCFGR1_PRESCALE_MASK          (7 << 0)  /* Clock Prescaler Bit Mask */
-#  define LPI2C_MCFGR1_PRESCALE(n)          (n & LPI2C_MCFGR1_PRESCALE_MASK)
+#  define LPI2C_MCFGR1_PRESCALE(n)          ((n) & LPI2C_MCFGR1_PRESCALE_MASK)
 #  define LPI2C_MCFGR1_PRESCALE_1           (0)
 #  define LPI2C_MCFGR1_PRESCALE_2           (1)
 #  define LPI2C_MCFGR1_PRESCALE_4           (2)
@@ -254,7 +254,7 @@
                                                       /* Bits 15-11 Reserved */
 #define LPI2C_MCFGR1_MATCFG_SHIFT           (16)
 #define LPI2C_MCFGR1_MATCFG_MASK            (7 << LPI2C_MCFGR1_MATCFG_SHIFT)  /* Match Configuration Bit Mask */
-#  define LPI2C_MCFGR1_MATCFG(n)            ((n << LPI2C_MCFGR1_MATCFG_SHIFT) & LPI2C_MCFGR1_MATCFG_MASK)
+#  define LPI2C_MCFGR1_MATCFG(n)            (((n) << LPI2C_MCFGR1_MATCFG_SHIFT) & LPI2C_MCFGR1_MATCFG_MASK)
 #  define LPI2C_MCFGR1_MATCFG_DISABLE       (0 << LPI2C_MCFGR1_MATCFG_SHIFT)
                                                      /* LPI2C_MCFG1_MATCFG = 001b Reserved */
 #  define LPI2C_MCFGR1_MATCFG2              (2 << LPI2C_MCFGR1_MATCFG_SHIFT)
@@ -266,7 +266,7 @@
                                                     /* Bits 23-19 Reserved */
 #define LPI2C_MCFGR1_PINCFG_SHIFT           (24)
 #define LPI2C_MCFGR1_PINCFG_MASK            (7 << LPI2C_MCFGR1_PINCFG_SHIFT)  /* Pin Configuration Bit Mask */
-#  define LPI2C_MCFGR1_PINCFG(n)            ((n << LPI2C_MCFGR1_PINCFG_SHIFT) & LPI2C_MCFGR1_PINCFG_MASK)
+#  define LPI2C_MCFGR1_PINCFG(n)            (((n) << LPI2C_MCFGR1_PINCFG_SHIFT) & LPI2C_MCFGR1_PINCFG_MASK)
 #  define LPI2C_MCFGR1_PINCFG0              (0 << LPI2C_MCFGR1_PINCFG_SHIFT)
 #  define LPI2C_MCFGR1_PINCFG1              (1 << LPI2C_MCFGR1_PINCFG_SHIFT)
 #  define LPI2C_MCFGR1_PINCFG2              (2 << LPI2C_MCFGR1_PINCFG_SHIFT)
@@ -281,17 +281,17 @@
 
 #define LPI2C_MCFG2_BUSIDLE_MASK            (0xfff << 0)  /* Bus Idle Timeout Period in Clock Cycles */
 #define LPI2C_MCFG2_BUSIDLE_DISABLE         (0)
-#  define LPI2C_MCFG2_BUSIDLE(n)            (n & LPI2C_MCFG2_BUSIDLE_MASK)
+#  define LPI2C_MCFG2_BUSIDLE(n)            ((n) & LPI2C_MCFG2_BUSIDLE_MASK)
                                                      /* Bits 15-12 Reserved */
 #define LPI2C_MCFG2_FILTSCL_SHIFT           (16)
 #define LPI2C_MCFG2_FILTSCL_MASK            (15 << LPI2C_MCFG2_FILTSCL_SHIFT)  /* Glitch Filter SCL */
 #define LPI2C_MCFG2_FILTSCL_DISABLE         (0 << LPI2C_MCFG2_FILTSCL_SHIFT)
-#  define LPI2C_MCFG2_FILTSCL_CYCLES(n)     ((n << LPI2C_MCFG2_FILTSCL_SHIFT) & LPI2C_MCFG2_FILTSCL_MASK)
+#  define LPI2C_MCFG2_FILTSCL_CYCLES(n)     (((n) << LPI2C_MCFG2_FILTSCL_SHIFT) & LPI2C_MCFG2_FILTSCL_MASK)
                                                      /* Bits 23-20 Reserved */
 #define LPI2C_MCFG2_FILTSDA_SHIFT           (24)
 #define LPI2C_MCFG2_FILTSDA_MASK            (15 << LPI2C_MCFG2_FILTSDA_SHIFT)  /* Glitch Filter SDA */
 #define LPI2C_MCFG2_FILTSDA_DISABLE         (0 << LPI2C_MCFG2_FILTSDA_SHIFT)
-#  define LPI2C_MCFG2_FILTSDA_CYCLES(n)     ((n << LPI2C_MCFG2_FILTSDA_SHIFT) & LPI2C_MCFG2_FILTSDA_MASK)
+#  define LPI2C_MCFG2_FILTSDA_CYCLES(n)     (((n) << LPI2C_MCFG2_FILTSDA_SHIFT) & LPI2C_MCFG2_FILTSDA_MASK)
                                                      /* Bits 31-28 Reserved */
 
 /* LPI2C Master Config Register 3  */
@@ -299,56 +299,56 @@
                                                      /* Bits 7-0 Reserved */
 #define LPI2C_MCFG3_PINLOW_SHIFT            (8)
 #define LPI2C_MCFG3_PINLOW_MASK             (0xfff << LPI2C_MCFG3_PINLOW_SHIFT)  /* Configure The Pin Low Timeout in Clock Cycles */
-#  define LPI2C_MCFG3_PINLOW_CYCLES(n)      ((n << LPI2C_MCFG3_PINLOW_SHIFT) & LPI2C_MCFG3_PINLOW_MASK)
+#  define LPI2C_MCFG3_PINLOW_CYCLES(n)      (((n) << LPI2C_MCFG3_PINLOW_SHIFT) & LPI2C_MCFG3_PINLOW_MASK)
                                                      /* Bits 31-20 Reserved */
 
 /* LPI2C Master Data Match Register  */
 
 #define LPI2C_MDMR_MATCH0_SHIFT             (0)
 #define LPI2C_MDMR_MATCH0_MASK              (0xff << LPI2C_MDMR_MATCH0_SHIFT)  /* Match 0 Value */
-#  define LPI2C_MDMR_MATCH0(n)              ((n << LPI2C_MDMR_MATCH0_SHIFT) & LPI2C_MDMR_MATCH0_MASK)
+#  define LPI2C_MDMR_MATCH0(n)              (((n) << LPI2C_MDMR_MATCH0_SHIFT) & LPI2C_MDMR_MATCH0_MASK)
                                                      /* Bits 15-8 Reserved */
 #define LPI2C_MDMR_MATCH1_SHIFT             (16)
 #define LPI2C_MDMR_MATCH1_MASK              (0xff << LPI2C_MDMR_MATCH1_SHIFT)  /* Match 1 Value */
-#  define LPI2C_MDMR_MATCH1(n)              ((n << LPI2C_MDMR_MATCH1_SHIFT) & LPI2C_MDMR_MATCH1_MASK)
+#  define LPI2C_MDMR_MATCH1(n)              (((n) << LPI2C_MDMR_MATCH1_SHIFT) & LPI2C_MDMR_MATCH1_MASK)
                                                      /* Bits 31-24 Reserved */
 
 /* LPI2C Master Clock Configuration Register 0 */
 
 #define LPI2C_MCCR0_CLKLO_SHIFT             (0)
 #define LPI2C_MCCR0_CLKLO_MASK              (0x3f << LPI2C_MCCR0_CLKLO_SHIFT)  /* Clock Low Period */
-#  define LPI2C_MCCR0_CLKLO(n)              ((n << LPI2C_MCCR0_CLKLO_SHIFT) & LPI2C_MCCR0_CLKLO_MASK)
+#  define LPI2C_MCCR0_CLKLO(n)              (((n) << LPI2C_MCCR0_CLKLO_SHIFT) & LPI2C_MCCR0_CLKLO_MASK)
                                                      /* Bits 7-6 Reserved */
 #define LPI2C_MCCR0_CLKHI_SHIFT             (8)
 #define LPI2C_MCCR0_CLKHI_MASK              (0x3f << LPI2C_MCCR0_CLKHI_SHIFT)  /* Clock High Period */
-#  define LPI2C_MCCR0_CLKHI(n)              ((n << LPI2C_MCCR0_CLKHI_SHIFT) & LPI2C_MCCR0_CLKHI_MASK)
+#  define LPI2C_MCCR0_CLKHI(n)              (((n) << LPI2C_MCCR0_CLKHI_SHIFT) & LPI2C_MCCR0_CLKHI_MASK)
                                                      /* Bits 15-14 Reserved */
 #define LPI2C_MCCR0_SETHOLD_SHIFT           (16)
 #define LPI2C_MCCR0_SETHOLD_MASK            (0x3f << LPI2C_MCCR0_SETHOLD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR0_SETHOLD(n)            ((n << LPI2C_MCCR0_SETHOLD_SHIFT) & LPI2C_MCCR0_SETHOLD_MASK)
+#  define LPI2C_MCCR0_SETHOLD(n)            (((n) << LPI2C_MCCR0_SETHOLD_SHIFT) & LPI2C_MCCR0_SETHOLD_MASK)
                                                      /* Bits 23-22 Reserved */
 #define LPI2C_MCCR0_DATAVD_SHIFT            (24)
 #define LPI2C_MCCR0_DATAVD_MASK             (0x3f << LPI2C_MCCR0_DATAVD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR0_DATAVD(n)             ((n << LPI2C_MCCR0_DATAVD_SHIFT) & LPI2C_MCCR0_DATAVD_MASK)
+#  define LPI2C_MCCR0_DATAVD(n)             (((n) << LPI2C_MCCR0_DATAVD_SHIFT) & LPI2C_MCCR0_DATAVD_MASK)
                                                      /* Bits 31-30 Reserved */
 
 /* LPI2C Master Clock Configuration Register 1 */
 
 #define LPI2C_MCCR1_CLKLO_SHIFT             (0)
 #define LPI2C_MCCR1_CLKLO_MASK              (0x3f << LPI2C_MCCR1_CLKLO_SHIFT)  /* Clock Low Period */
-#  define LPI2C_MCCR1_CLKLO(n)              ((n << LPI2C_MCCR1_CLKLO_SHIFT) & LPI2C_MCCR1_CLKLO_MASK)
+#  define LPI2C_MCCR1_CLKLO(n)              (((n) << LPI2C_MCCR1_CLKLO_SHIFT) & LPI2C_MCCR1_CLKLO_MASK)
                                                      /* Bits 7-6 Reserved */
 #define LPI2C_MCCR1_CLKHI_SHIFT             (8)
 #define LPI2C_MCCR1_CLKHI_MASK              (0x3f << LPI2C_MCCR1_CLKHI_SHIFT)  /* Clock High Period */
-#  define LPI2C_MCCR1_CLKHI(n)              ((n << LPI2C_MCCR1_CLKHI_SHIFT) & LPI2C_MCCR1_CLKHI_MASK)
+#  define LPI2C_MCCR1_CLKHI(n)              (((n) << LPI2C_MCCR1_CLKHI_SHIFT) & LPI2C_MCCR1_CLKHI_MASK)
                                                      /* Bits 15-14 Reserved */
 #define LPI2C_MCCR1_SETHOLD_SHIFT           (16)
 #define LPI2C_MCCR1_SETHOLD_MASK            (0x3f << LPI2C_MCCR1_SETHOLD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR1_SETHOLD(n)            ((n << LPI2C_MCCR1_SETHOLD_SHIFT) & LPI2C_MCCR1_SETHOLD_MASK)
+#  define LPI2C_MCCR1_SETHOLD(n)            (((n) << LPI2C_MCCR1_SETHOLD_SHIFT) & LPI2C_MCCR1_SETHOLD_MASK)
                                                      /* Bits 23-22 Reserved */
 #define LPI2C_MCCR1_DATAVD_SHIFT            (24)
 #define LPI2C_MCCR1_DATAVD_MASK             (0x3f << LPI2C_MCCR1_DATAVD_SHIFT)  /* Setup Hold Delay */
-#  define LPI2C_MCCR1_DATAVD(n)             ((n << LPI2C_MCCR1_DATAVD_SHIFT) & LPI2C_MCCR1_DATAVD_MASK)
+#  define LPI2C_MCCR1_DATAVD(n)             (((n) << LPI2C_MCCR1_DATAVD_SHIFT) & LPI2C_MCCR1_DATAVD_MASK)
                                                      /* Bits 31-30 Reserved */
 
 /* LPI2C Master FIFO Control Register */
@@ -356,13 +356,13 @@
 #define LPI2C_MFCR_TXWATER_SHIFT            (0)
 #define LPI2C_MFCR_TXWATER_MASK             (3 << LPI2C_MFCR_TXWATER_SHIFT)  /* Transmit FIFO Watermark*/
 
-#  define LPI2C_MFCR_TXWATER(n)             ((n << LPI2C_MFCR_TXWATER_SHIFT) &  LPI2C_MFCR_TXWATER_MASK)  /* Transmit FIFO Watermark*/
+#  define LPI2C_MFCR_TXWATER(n)             (((n) << LPI2C_MFCR_TXWATER_SHIFT) &  LPI2C_MFCR_TXWATER_MASK)  /* Transmit FIFO Watermark*/
 
                                                      /* Bits 15-2 Reserved */
 #define LPI2C_MFCR_RXWATER_SHIFT            (16)
 #define LPI2C_MFCR_RXWATER_MASK             (3 << LPI2C_MFCR_RXWATER_SHIFT)  /* Receive FIFO Watermark */
 
-#  define LPI2C_MFCR_RXWATER(n)             ((n << LPI2C_MFCR_RXWATER_SHIFT) &  LPI2C_MFCR_RXWATER_MASK)  /* Transmit FIFO Watermark*/
+#  define LPI2C_MFCR_RXWATER(n)             (((n) << LPI2C_MFCR_RXWATER_SHIFT) &  LPI2C_MFCR_RXWATER_MASK)  /* Transmit FIFO Watermark*/
 
                                                      /* Bits 31-18 Reserved */
 
@@ -381,10 +381,10 @@
 
 #define LPI2C_MTDR_DATA_SHIFT               (0)
 #define LPI2C_MTDR_DATA_MASK                (0xff << LPI2C_MTDR_DATA_SHIFT)  /* Transmit Data */
-#  define LPI2C_MTDR_DATA(n)                (n & LPI2C_MTDR_DATA_MASK)
+#  define LPI2C_MTDR_DATA(n)                ((n) & LPI2C_MTDR_DATA_MASK)
 #define LPI2C_MTDR_CMD_SHIFT                (8)
 #define LPI2C_MTDR_CMD_MASK                 (7 << LPI2C_MTDR_CMD_SHIFT)  /* Command Data */
-#  define LPI2C_MTDR_CMD(n)                 ((n << LPI2C_MTDR_CMD_SHIFT) & LPI2C_MTDR_CMD_MASK)
+#  define LPI2C_MTDR_CMD(n)                 (((n) << LPI2C_MTDR_CMD_SHIFT) & LPI2C_MTDR_CMD_MASK)
 #  define LPI2C_MTDR_CMD_TXD                (0 << LPI2C_MTDR_CMD_SHIFT)
 #  define LPI2C_MTDR_CMD_RXD                (1 << LPI2C_MTDR_CMD_SHIFT)
 #  define LPI2C_MTDR_CMD_STOP               (2 << LPI2C_MTDR_CMD_SHIFT)
@@ -478,7 +478,7 @@
                                                       /* Bits 15-14 Reserved */
 #define LPI2C_SCFG1_ADDRCFG_SHIFT           (16)
 #define LPI2C_SCFG1_ADDRCFG_MASK            (7 << LPI2C_SCFG1_ADDRCFG_SHIFT)  /* Address Configuration Bit Mask */
-#  define LPI2C_SCFG1_ADDRCFG(n)            ((n << LPI2C_SCFG1_ADDRCFG_SHIFT) & LPI2C_SCFG1_ADDRCFG_MASK)
+#  define LPI2C_SCFG1_ADDRCFG(n)            (((n) << LPI2C_SCFG1_ADDRCFG_SHIFT) & LPI2C_SCFG1_ADDRCFG_MASK)
 #  define LPI2C_SCFG1_ADDRCFG0              (0 << LPI2C_SCFG1_ADDRCFG_SHIFT)
 #  define LPI2C_SCFG1_ADDRCFG1              (2 << LPI2C_SCFG1_ADDRCFG_SHIFT)
 #  define LPI2C_SCFG1_ADDRCFG2              (2 << LPI2C_SCFG1_ADDRCFG_SHIFT)
@@ -492,21 +492,21 @@
 /* LPI2C Slave Configuration Register 2  */
 
 #define LPI2C_SCFG2_CLKHOLD_MASK            (15 << 0) /* Clock Hold Time */
-#  define LPI2C_SCFG2_CLKHOLD(n)            (n & LPI2C_SCFG2_CLKHOLD_MASK)
+#  define LPI2C_SCFG2_CLKHOLD(n)            ((n) & LPI2C_SCFG2_CLKHOLD_MASK)
                                                       /* Bits 7-4 Reserved */
 #define LPI2C_SCFG2_DATAVD_SHIFT            (8)
 #define LPI2C_SCFG2_DATAVD_MASK             (0x3f << LPI2C_SCFG2_DATAVD_SHIFT)  /* Data Valid Delay */
-#  define LPI2C_SCFG2_DATAVD(n)             ((n << LPI2C_SCFG2_DATAVD_SHIFT) & LPI2C_SCFG2_DATAVD_MASK)
+#  define LPI2C_SCFG2_DATAVD(n)             (((n) << LPI2C_SCFG2_DATAVD_SHIFT) & LPI2C_SCFG2_DATAVD_MASK)
                                                       /* Bits 15-14 Reserved */
 #define LPI2C_SCFG2_FILTSCL_SHIFT           (16)
 #define LPI2C_SCFG2_FILTSCL_MASK            (15 << LPI2C_SCFG2_FILTSCL_SHIFT)  /* Glitch Filter SCL */
 #define LPI2C_SCFG2_FILTSCL_DISABLE         (0 << LPI2C_SCFG2_FILTSCL_SHIFT)
-#  define LPI2C_SCFG2_FILTSCL_CYCLES(n)     ((n << LPI2C_SCFG2_FILTSCL_SHIFT) & LPI2C_SCFG2_FILTSCL_MASK)
+#  define LPI2C_SCFG2_FILTSCL_CYCLES(n)     (((n) << LPI2C_SCFG2_FILTSCL_SHIFT) & LPI2C_SCFG2_FILTSCL_MASK)
                                                       /* Bits 23-20 Reserved */
 #define LPI2C_SCFG2_FILTSDA_SHIFT           (24)
 #define LPI2C_SCFG2_FILTSDA_MASK            (15 << LPI2C_SCFG2_FILTSDA_SHIFT)  /* Glitch Filter SDA */
 #define LPI2C_SCFG2_FILTSDA_DISABLE         (0 << LPI2C_SCFG2_FILTSDA_SHIFT)
-#  define LPI2C_SCFG2_FILTSDA_CYCLES(n)     ((n << LPI2C_SCFG2_FILTSDA_SHIFT) & LPI2C_SCFG2_FILTSDA_MASK)
+#  define LPI2C_SCFG2_FILTSDA_CYCLES(n)     (((n) << LPI2C_SCFG2_FILTSDA_SHIFT) & LPI2C_SCFG2_FILTSDA_MASK)
                                                       /* Bits 31-28 Reserved */
 
 /* LPI2C Slave Address Match Register  */
@@ -514,11 +514,11 @@
                                                       /* Bit 0 Reserved */
 #define LPI2C_SAMR_ADDR0_SHIFT              (1)
 #define LPI2C_SAMR_ADDR0_MASK               (0x3ff << LPI2C_SAMR_ADDR0_SHIFT)  /* Address 0 Value */
-#  define LPI2C_SAMR_ADDR0(n)               ((n << LPI2C_SAMR_ADDR0_SHIFT) & LPI2C_SAMR_ADDR0_MASK)
+#  define LPI2C_SAMR_ADDR0(n)               (((n) << LPI2C_SAMR_ADDR0_SHIFT) & LPI2C_SAMR_ADDR0_MASK)
                                                       /* Bits 16-11 Reserved */
 #define LPI2C_SAMR_ADDR1_SHIFT              (17)
 #define LPI2C_SAMR_ADDR1_MASK               (0x3ff << LPI2C_SAMR_ADDR1_SHIFT)  /* Address 1 Value */
-#  define LPI2C_SAMR_ADDR1(n)               ((n << LPI2C_SAMR_ADDR1_SHIFT) & LPI2C_SAMR_ADDR1_MASK)
+#  define LPI2C_SAMR_ADDR1(n)               (((n) << LPI2C_SAMR_ADDR1_SHIFT) & LPI2C_SAMR_ADDR1_MASK)
                                                       /* Bits 31-27 Reserved */
 
 /* LPI2C Slave Address Status Register  */
@@ -538,14 +538,14 @@
 
 #define LPI2C_STDR_DATA_SHIFT               (0)
 #define LPI2C_STDR_DATA_MASK                (0xff << LPI2C_STDR_DATA_SHIFT)  /* Transmit Data */
-#  define LPI2C_STDR_DATA(n)                ((n << LPI2C_STDR_DATA_SHIFT) & LPI2C_STDR_DATA_MASK)
+#  define LPI2C_STDR_DATA(n)                (((n) << LPI2C_STDR_DATA_SHIFT) & LPI2C_STDR_DATA_MASK)
                                                       /* Bits 31-8 Reserved */
 
 /* LPI2C Slave Receive Data Register  */
 
 #define LPI2C_SRDR_DATA_SHIFT               (0)
 #define LPI2C_SRDR_DATA_MASK                (0xff << LPI2C_SRDR_DATA_SHIFT)  /* Receive Data */
-#  define LPI2C_SRDR_DATA(n)                ((n << LPI2C_SRDR_DATA_SHIFT) & LPI2C_SRDR_DATA_MASK)
+#  define LPI2C_SRDR_DATA(n)                (((n) << LPI2C_SRDR_DATA_SHIFT) & LPI2C_SRDR_DATA_MASK)
                                                       /* Bits 8-31 Reserved */
 
 #endif /* __ARCH_ARM_SRC_S32K1XX_HARDWARE_S32K1XX_LPI2C_H */
diff --git a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
index dc7e6f5b62..e12dec7a5a 100644
--- a/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
+++ b/arch/arm/src/s32k1xx/hardware/s32k1xx_memorymap.h
@@ -34,8 +34,8 @@
 #define S32K1XX_AIPS_LITE_BASE   0x40000000  /* Peripheral bridge (AIPS-Lite) */
 #  define S32K1XX_FLASHCFG_BASE  0x40000400  /* FLASH Configuration bytes */
 #  define S32K1XX_MSCM_BASE      0x40001000  /* MSCM */
-#  define S32K1XX_DMAC_BASE      0x40008000  /* DMA controller */
-#  define S32K1XX_DMADESC_BASE   0x40008000  /* DMA transfer control descriptors */
+#  define S32K1XX_EDMA_BASE      0x40008000  /* EDMA controller */
+#  define S32K1XX_EDMADESC_BASE  0x40008000  /* EDMA transfer control descriptors */
 #  define S32K1XX_MPU_BASE       0x4000d000  /* MPU */
 #  define S32K1XX_GPIOCTL_BASE   0x4000f000  /* GPIO controller */
 #  define S32K1XX_GPIOALIAS_BASE 0x400ff000  /* GPIO controller (alias) */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
index 4b4be95c99..37f99dda0b 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.c
@@ -2546,13 +2546,6 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
 
   DEBUGASSERT(clkcfg != NULL);
 
-#ifdef CONFIG_PM
-  /* Register to receive power management callbacks */
-
-  ret = pm_register(&g_clock_pmcb);
-  DEBUGASSERT(ret == OK);
-#endif
-
   /* Set SCG configuration */
 
   ret = s32k1xx_scg_config(&clkcfg->scg);
@@ -2564,7 +2557,7 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
 
       /* Set PCC configuration */
 
-      s32k1xx_periphclocks(clkcfg->pcc.count, clkcfg->pcc.pclks);
+      s32k1xx_periphclocks(num_of_peripheral_clocks_0, clkcfg->pcc.pclks);
 
       /* Set SIM configuration */
 
@@ -2578,6 +2571,29 @@ int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg)
   return ret;
 }
 
+/****************************************************************************
+ * Name: s32k1xx_clock_pm_register
+ *
+ * Description:
+ *   This function is called after OS and PM init in order to register to
+ *   receive power management event callbacks.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Values:
+ *   None
+ *
+ ****************************************************************************/
+#ifdef CONFIG_PM
+void s32k1xx_clock_pm_register(void)
+{
+  /* Register to receive power management callbacks */
+
+  pm_register(&g_clock_pmcb);
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_get_coreclk
  *
diff --git a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
index 588e79a6d5..01cd3fd470 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_clockconfig.h
@@ -86,6 +86,8 @@
  * Public Types
  ****************************************************************************/
 
+extern const unsigned int num_of_peripheral_clocks_0;
+
 /* Clock Configuration ******************************************************/
 
 enum scg_system_clock_type_e
@@ -412,7 +414,6 @@ struct sim_clock_config_s
 struct peripheral_clock_config_s;      /* Forward reference */
 struct pcc_config_s
 {
-  unsigned int count;                            /* Number of peripherals to be configured */
   const struct peripheral_clock_config_s *pclks; /* The peripheral clock configuration array */
 };
 
@@ -525,6 +526,24 @@ enum scg_system_clock_mode_e s32k1xx_set_runmode(enum scg_system_clock_mode_e
 
 int s32k1xx_clockconfig(const struct clock_configuration_s *clkcfg);
 
+/****************************************************************************
+ * Name: s32k1xx_clock_pm_register
+ *
+ * Description:
+ *   This function is called after OS and PM init in order to register to
+ *   receive power management event callbacks.
+ *
+ * Input Parameters:
+ *   None
+ *
+ * Returned Values:
+ *   None
+ *
+ ****************************************************************************/
+#ifdef CONFIG_PM
+void s32k1xx_clock_pm_register(void);
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_get_coreclk
  *
diff --git a/arch/arm/src/s32k1xx/s32k1xx_edma.c b/arch/arm/src/s32k1xx/s32k1xx_edma.c
index 1236b5fd9a..b0fb9c070a 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_edma.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_edma.c
@@ -86,22 +86,16 @@
  */
 
 #ifdef CONFIG_ARMV7M_DCACHE
-/* Align to the cache line size which we assume is >= 8 */
-
-#  define EDMA_ALIGN        ARMV7M_DCACHE_LINESIZE
-#  define EDMA_ALIGN_MASK   (EDMA_ALIGN-1)
-#  define EDMA_ALIGN_UP(n)  (((n) + EDMA_ALIGN_MASK) & ~EDMA_ALIGN_MASK)
-
+#  define EDMA_ALIGN  ARMV7M_DCACHE_LINESIZE
 #else
-/* Special alignment is not required in this case,
- * but we will align to 8-bytes
- */
+/* 32 byte alignment for TCDs is required for scatter gather */
 
-#  define EDMA_ALIGN        8
-#  define EDMA_ALIGN_MASK   7
-#  define EDMA_ALIGN_UP(n)  (((n) + 7) & ~7)
+#define EDMA_ALIGN        32
 #endif
 
+#define EDMA_ALIGN_MASK   (EDMA_ALIGN - 1)
+#define EDMA_ALIGN_UP(n)  (((n) + EDMA_ALIGN_MASK) & ~EDMA_ALIGN_MASK)
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
@@ -119,10 +113,10 @@ enum s32k1xx_dmastate_e
 
 struct s32k1xx_dmach_s
 {
-  uint8_t chan;                   /* DMA channel number (0-S32K1XX_EDMA_NCHANNELS) */
-  bool inuse;                     /* true: The DMA channel is in use */
-  uint8_t ttype;                  /* Transfer type: M2M, M2P, P2M, or P2P */
-  uint8_t state;                  /* Channel state.  See enum s32k1xx_dmastate_e */
+  uint8_t  chan;                  /* DMA channel number (0-S32K1XX_EDMA_NCHANNELS) */
+  bool     inuse;                 /* true: The DMA channel is in use */
+  uint8_t  state;                 /* Channel state.  See enum s32k1xx_dmastate_e */
+  uint8_t  dmamux;                /* The DMAMUX channel selection */
   uint32_t flags;                 /* DMA channel flags */
   edma_callback_t callback;       /* Callback invoked when the DMA completes */
   void *arg;                      /* Argument passed to callback function */
@@ -338,18 +332,13 @@ static inline void s32k1xx_tcd_chanlink(uint8_t flags,
 
   if (linkch == NULL || flags == EDMA_CONFIG_LINKTYPE_LINKNONE)
     {
-#if 0 /* Already done */
       /* No link or no link channel provided */
 
-      /* Disable minor links */
-
-      tcd->citer &= ~EDMA_TCD_CITER_ELINK;
-      tcd->biter &= ~EDMA_TCD_BITER_ELINK;
+      /* Disable minor links is done in s32k1xx_tcd_configure */
 
       /* Disable major link */
 
       tcd->csr   &= ~EDMA_TCD_CSR_MAJORELINK;
-#endif
     }
   else if (flags == EDMA_CONFIG_LINKTYPE_MINORLINK) /* Minor link config */
     {
@@ -405,13 +394,18 @@ static inline void s32k1xx_tcd_configure(struct s32k1xx_edmatcd_s *tcd,
   tcd->attr     = EDMA_TCD_ATTR_SSIZE(config->ssize) |  /* Transfer Attributes */
                   EDMA_TCD_ATTR_DSIZE(config->dsize);
   tcd->nbytes   = config->nbytes;
-  tcd->slast    = tcd->slast;
+  tcd->slast    = config->flags & EDMA_CONFIG_LOOPSRC ?
+                                  -(config->iter * config->nbytes) : 0;
   tcd->daddr    = config->daddr;
   tcd->doff     = config->doff;
   tcd->citer    = config->iter & EDMA_TCD_CITER_CITER_MASK;
   tcd->biter    = config->iter & EDMA_TCD_BITER_BITER_MASK;
-  tcd->csr      = EDMA_TCD_CSR_DREQ; /* Assume last transfer */
-  tcd->dlastsga = 0;
+  tcd->csr      = config->flags & EDMA_CONFIG_LOOP_MASK ?
+                                  0 : EDMA_TCD_CSR_DREQ;
+  tcd->csr      |= config->flags & EDMA_CONFIG_INTHALF ?
+                                  EDMA_TCD_CSR_INTHALF : 0;
+  tcd->dlastsga = config->flags & EDMA_CONFIG_LOOPDEST ?
+                                  -(config->iter * config->nbytes) : 0;
 
   /* And special case flags */
 
@@ -440,6 +434,10 @@ static void s32k1xx_tcd_instantiate(struct s32k1xx_dmach_s *dmach,
 
   /* Push tcd into hardware TCD register */
 
+  /* Clear DONE bit first, otherwise ESG cannot be set */
+
+  putreg16(0,             base + S32K1XX_EDMA_TCD_CSR_OFFSET);
+
   putreg32(tcd->saddr,    base + S32K1XX_EDMA_TCD_SADDR_OFFSET);
   putreg16(tcd->soff,     base + S32K1XX_EDMA_TCD_SOFF_OFFSET);
   putreg16(tcd->attr,     base + S32K1XX_EDMA_TCD_ATTR_OFFSET);
@@ -450,9 +448,6 @@ static void s32k1xx_tcd_instantiate(struct s32k1xx_dmach_s *dmach,
   putreg16(tcd->citer,    base + S32K1XX_EDMA_TCD_CITER_ELINK_OFFSET);
   putreg32(tcd->dlastsga, base + S32K1XX_EDMA_TCD_DLASTSGA_OFFSET);
 
-  /* Clear DONE bit first, otherwise ESG cannot be set */
-
-  putreg16(0,             base + S32K1XX_EDMA_TCD_CSR_OFFSET);
   putreg16(tcd->csr,      base + S32K1XX_EDMA_TCD_CSR_OFFSET);
 
   putreg16(tcd->biter,    base + S32K1XX_EDMA_TCD_BITER_ELINK_OFFSET);
@@ -488,25 +483,25 @@ static void s32k1xx_dmaterminate(struct s32k1xx_dmach_s *dmach, int result)
   regval8         = EDMA_CERQ(chan);
   putreg8(regval8, S32K1XX_EDMA_CERQ);
 
-  /* Clear CSR to disable channel. Because if the given channel started,
-   * transfer CSR will be not zero. Because if it is the last transfer, DREQ
-   * will be set.  If not, ESG will be set.
-   */
-
   regaddr         = S32K1XX_EDMA_TCD_CSR(chan);
   putreg16(0, regaddr);
 
   /* Cancel next TCD transfer. */
 
   regaddr         = S32K1XX_EDMA_TCD_DLASTSGA(chan);
-  putreg16(0, regaddr);
+  putreg32(0, regaddr);
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Return all allocated TCDs to the free list */
 
   for (tcd = dmach->head; tcd != NULL; tcd = next)
     {
-      next = (struct s32k1xx_edmatcd_s *)tcd->dlastsga;
+      /* If channel looped to itself we are done
+       * if not continue to free tcds in chain
+       */
+
+       next = dmach->flags & EDMA_CONFIG_LOOPDEST ?
+              NULL : (struct s32k1xx_edmatcd_s *)tcd->dlastsga;
       s32k1xx_tcd_free(tcd);
     }
 
@@ -514,15 +509,6 @@ static void s32k1xx_dmaterminate(struct s32k1xx_dmach_s *dmach, int result)
   dmach->tail = NULL;
 #endif
 
-  /* Check for an Rx (memory-to-peripheral/memory-to-memory) DMA transfer */
-
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_PERIPH2MEM)
-    {
-      /* Invalidate the cache to force reloads from memory. */
-
-#warning Missing logic
-    }
-
   /* Perform the DMA complete callback */
 
   if (dmach->callback)
@@ -556,13 +542,13 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
 {
   struct s32k1xx_dmach_s *dmach;
   uintptr_t regaddr;
-  uint32_t regval32;
-  uint16_t regval16;
-  uint8_t regval8;
-  uint8_t chan;
-  int result;
+  uint32_t  regval32;
+  uint16_t  regval16;
+  uint8_t   regval8;
+  uint8_t   chan;
+  int       result;
 
-  /* 'arg' should the DMA channel instance. */
+  /* 'arg' should be the DMA channel instance. */
 
   dmach = (struct s32k1xx_dmach_s *)arg;
   DEBUGASSERT(dmach != NULL);
@@ -584,7 +570,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
       /* Clear the pending eDMA channel interrupt */
 
       regval8 = EDMA_CINT(chan);
-      putreg32(regval8, S32K1XX_EDMA_CINT);
+      putreg8(regval8, S32K1XX_EDMA_CINT);
 
       /* Get the eDMA TCD Control and Status register value. */
 
@@ -604,7 +590,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
       else
         {
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
-          /* Perform the end-of-major-cycle DMA callback */
+          /* Perform the half or end-of-major-cycle DMA callback */
 
           if (dmach->callback != NULL)
             {
@@ -612,7 +598,7 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
                               false, OK);
             }
 
-          return;
+          return OK;
 #else
           /* Otherwise the interrupt was not expected! */
 
@@ -623,8 +609,18 @@ static int s32k1xx_edma_interrupt(int irq, void *context, void *arg)
 
       /* Terminate the transfer when it is done. */
 
-      s32k1xx_dmaterminate(dmach, result);
+      if ((dmach->flags & EDMA_CONFIG_LOOP_MASK) == 0)
+        {
+          s32k1xx_dmaterminate(dmach, result);
+        }
+      else if (dmach->callback != NULL)
+        {
+          dmach->callback((DMACH_HANDLE)dmach, dmach->arg,
+                          true, result);
+        }
     }
+
+  return OK;
 }
 
 /****************************************************************************
@@ -661,7 +657,7 @@ static int s32k1xx_error_interrupt(int irq, void *context, void *arg)
           /* Clear the pending error interrupt status. */
 
           regval8 = EDMA_CERR(chan);
-          putreg32(regval8, S32K1XX_EDMA_CERR);
+          putreg8(regval8, S32K1XX_EDMA_CERR);
 
           /* Remove the bit from the sample ERR register so that perhaps we
            * can exit this loop early.
@@ -755,24 +751,12 @@ void weak_function arm_dma_initialize(void)
 
   /* Attach DMA interrupt vectors. */
 
-  irq_attach(S32K1XX_IRQ_DMACH0,  s32k1xx_edma_interrupt, &g_edma.dmach[0]);
-  irq_attach(S32K1XX_IRQ_DMACH1,  s32k1xx_edma_interrupt, &g_edma.dmach[1]);
-  irq_attach(S32K1XX_IRQ_DMACH2,  s32k1xx_edma_interrupt, &g_edma.dmach[2]);
-  irq_attach(S32K1XX_IRQ_DMACH3,  s32k1xx_edma_interrupt, &g_edma.dmach[3]);
-#if S32K1XX_EDMA_NCHANNELS > 4
-  irq_attach(S32K1XX_IRQ_DMACH4,  s32k1xx_edma_interrupt, &g_edma.dmach[4]);
-  irq_attach(S32K1XX_IRQ_DMACH5,  s32k1xx_edma_interrupt, &g_edma.dmach[5]);
-  irq_attach(S32K1XX_IRQ_DMACH6,  s32k1xx_edma_interrupt, &g_edma.dmach[6]);
-  irq_attach(S32K1XX_IRQ_DMACH7,  s32k1xx_edma_interrupt, &g_edma.dmach[7]);
-  irq_attach(S32K1XX_IRQ_DMACH8,  s32k1xx_edma_interrupt, &g_edma.dmach[8]);
-  irq_attach(S32K1XX_IRQ_DMACH9,  s32k1xx_edma_interrupt, &g_edma.dmach[9]);
-  irq_attach(S32K1XX_IRQ_DMACH10, s32k1xx_edma_interrupt, &g_edma.dmach[10]);
-  irq_attach(S32K1XX_IRQ_DMACH11, s32k1xx_edma_interrupt, &g_edma.dmach[11]);
-  irq_attach(S32K1XX_IRQ_DMACH12, s32k1xx_edma_interrupt, &g_edma.dmach[12]);
-  irq_attach(S32K1XX_IRQ_DMACH13, s32k1xx_edma_interrupt, &g_edma.dmach[13]);
-  irq_attach(S32K1XX_IRQ_DMACH14, s32k1xx_edma_interrupt, &g_edma.dmach[14]);
-  irq_attach(S32K1XX_IRQ_DMACH15, s32k1xx_edma_interrupt, &g_edma.dmach[15]);
-#endif
+  for (i = 0; i < S32K1XX_EDMA_NCHANNELS; i++)
+    {
+      irq_attach(S32K1XX_IRQ_DMACH0 + i,
+                 s32k1xx_edma_interrupt, &g_edma.dmach[i]);
+    }
+
   /* Attach the DMA error interrupt vector */
 
   irq_attach(S32K1XX_IRQ_DMACH_ERR, s32k1xx_error_interrupt, NULL);
@@ -790,6 +774,14 @@ void weak_function arm_dma_initialize(void)
 
       regaddr = S32K1XX_EDMA_TCD_CSR(i);
       putreg16(0, regaddr);
+
+      /* Set all TCD entries to 0 so that biter and citer
+       * will be 0 when DONE is not set so that s32k1xx_dmach_getcount
+       * reports 0.
+       */
+
+      memset((void *)S32K1XX_EDMA_TCD_BASE(i), 0,
+             sizeof(struct s32k1xx_edmatcd_s));
     }
 
   /* Clear all pending DMA channel interrupts */
@@ -800,24 +792,10 @@ void weak_function arm_dma_initialize(void)
    * controller).
    */
 
-  up_enable_irq(S32K1XX_IRQ_DMACH0);
-  up_enable_irq(S32K1XX_IRQ_DMACH1);
-  up_enable_irq(S32K1XX_IRQ_DMACH2);
-  up_enable_irq(S32K1XX_IRQ_DMACH3);
-#if S32K1XX_EDMA_NCHANNELS > 4
-  up_enable_irq(S32K1XX_IRQ_DMACH4);
-  up_enable_irq(S32K1XX_IRQ_DMACH5);
-  up_enable_irq(S32K1XX_IRQ_DMACH6);
-  up_enable_irq(S32K1XX_IRQ_DMACH7);
-  up_enable_irq(S32K1XX_IRQ_DMACH8);
-  up_enable_irq(S32K1XX_IRQ_DMACH9);
-  up_enable_irq(S32K1XX_IRQ_DMACH10);
-  up_enable_irq(S32K1XX_IRQ_DMACH11);
-  up_enable_irq(S32K1XX_IRQ_DMACH12);
-  up_enable_irq(S32K1XX_IRQ_DMACH13);
-  up_enable_irq(S32K1XX_IRQ_DMACH14);
-  up_enable_irq(S32K1XX_IRQ_DMACH15);
-#endif
+  for (i = 0; i < S32K1XX_EDMA_NCHANNELS; i++)
+    {
+      up_enable_irq(S32K1XX_IRQ_DMACH0 + i);
+    }
 
   /* Enable the DMA error interrupt */
 
@@ -837,7 +815,6 @@ void weak_function arm_dma_initialize(void)
  *            Settings include:
  *
  *            DMAMUX_CHCFG_SOURCE     Chip-specific DMA source (required)
- *            DMAMUX_CHCFG_AON        DMA Channel Always Enable (optional)
  *            DMAMUX_CHCFG_TRIG       DMA Channel Trigger Enable (optional)
  *            DMAMUX_CHCFG_ENBL       DMA Mux Channel Enable (required)
  *
@@ -858,7 +835,7 @@ void weak_function arm_dma_initialize(void)
  *
  ****************************************************************************/
 
-DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
+DMACH_HANDLE s32k1xx_dmach_alloc(uint8_t dmamux, uint8_t dchpri)
 {
   struct s32k1xx_dmach_s *dmach;
   unsigned int chndx;
@@ -884,6 +861,7 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
           dmach        = candidate;
           dmach->inuse = true;
           dmach->state = S32K1XX_DMA_IDLE;
+          dmach->dmamux = dmamux;
 
           /* Clear any pending interrupts on the channel */
 
@@ -896,10 +874,9 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
           regval8 = EDMA_CERQ(chndx);
           putreg8(regval8, S32K1XX_EDMA_CERQ);
 
-          /* Set the DMAMUX register associated with this channel */
+          /* Disable the associated DMAMUX for now */
 
-          regaddr = S32K1XX_DMAMUX_CHCFG(chndx);
-          putreg32(dmamux, regaddr);
+          putreg8(0, S32K1XX_DMAMUX_CHCFG(chndx));
           break;
         }
     }
@@ -936,7 +913,6 @@ DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri)
 void s32k1xx_dmach_free(DMACH_HANDLE handle)
 {
   struct s32k1xx_dmach_s *dmach = (struct s32k1xx_dmach_s *)handle;
-  uintptr_t regaddr;
   uint8_t regval8;
 
   dmainfo("dmach: %p\n", dmach);
@@ -958,8 +934,7 @@ void s32k1xx_dmach_free(DMACH_HANDLE handle)
 
   /* Disable the associated DMAMUX */
 
-  regaddr = S32K1XX_DMAMUX_CHCFG(dmach->chan);
-  putreg32(0, regaddr);
+  putreg8(0, S32K1XX_DMAMUX_CHCFG(dmach->chan));
 }
 
 /****************************************************************************
@@ -995,12 +970,16 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   struct s32k1xx_edmatcd_s *tcd;
   struct s32k1xx_edmatcd_s *prev;
+  uint16_t mask = config->flags & EDMA_CONFIG_INTMAJOR ? 0 :
+                                  EDMA_TCD_CSR_INTMAJOR;
 #endif
   uintptr_t regaddr;
   uint16_t regval16;
 
   DEBUGASSERT(dmach != NULL);
-  dmainfo("dmach%u: %p config: %p\n", dmach, config);
+  dmainfo("dmach%u: %p config: %p\n", dmach->chan, dmach, config);
+
+  dmach->flags  = config->flags;
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Scatter/gather DMA is supported */
@@ -1029,7 +1008,6 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
       dmach->head  = tcd;
       dmach->tail  = tcd;
-      dmach->ttype = config->ttype;
 
       /* And instantiate the first TCD in the DMA channel TCD registers. */
 
@@ -1037,11 +1015,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
     }
   else
     {
-      /* Cannot mix transfer types (only because of cache-related operations.
-       * this restriction could be removed with some effort).
-       */
+      /* Cannot mix transfer types */
 
-      if (dmach->ttype != config->ttype)
+      if (dmach->flags & EDMA_CONFIG_LOOP_MASK)
         {
           s32k1xx_tcd_free(tcd);
           return -EINVAL;
@@ -1053,8 +1029,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
       prev           = dmach->tail;
       regval16       = prev->csr;
-      regval16      &= ~EDMA_TCD_CSR_DREQ;
+      regval16      &= ~(EDMA_TCD_CSR_DREQ | mask);
       regval16      |= EDMA_TCD_CSR_ESG;
+
       prev->csr      = regval16;
 
       prev->dlastsga = (uint32_t)tcd;
@@ -1076,7 +1053,7 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
 
           regaddr   = S32K1XX_EDMA_TCD_CSR(dmach->chan);
           regval16  = getreg16(regaddr);
-          regval16 &= ~EDMA_TCD_CSR_DREQ;
+          regval16 &= ~(EDMA_TCD_CSR_DREQ | mask);
           regval16 |= EDMA_TCD_CSR_ESG;
           putreg16(regval16, regaddr);
 
@@ -1115,34 +1092,9 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
   modifyreg16(regaddr, 0, EDMA_TCD_CSR_INTMAJOR);
 #endif
 
-  /* Check for an Rx (memory-to-peripheral/memory-to-memory) DMA transfer */
+  /* Set the DMAMUX source and enable and optional trigger */
 
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_PERIPH2MEM)
-    {
-      /* Invalidate caches associated with the destination DMA memory.
-       * REVISIT:  nbytes is the number of bytes transferred on each
-       * minor loop.  The following is only valid when the major loop
-       * is one.
-       */
-
-      up_invalidate_dcache((uintptr_t)config->daddr,
-                           (uintptr_t)config->daddr + config->nbytes);
-    }
-
-  /* Check for an Tx (peripheral-to-memory/memory-to-memory) DMA transfer */
-
-  if (dmach->ttype == EMDA_MEM2MEM || dmach->ttype == EMDA_MEM2PERIPH)
-    {
-      /* Clean caches associated with the source DMA memory.
-       * REVISIT:  nbytes is the number of bytes transferred on each
-       * minor loop.  The following is only valid when the major loop
-       * is one.
-       */
-#warning Missing logic
-
-      up_clean_dcache((uintptr_t)config->saddr,
-                      (uintptr_t)config->saddr + config->nbytes);
-    }
+  putreg8(dmach->dmamux, S32K1XX_DMAMUX_CHCFG(dmach->chan));
 
   dmach->state = S32K1XX_DMA_CONFIGURED;
   return OK;
@@ -1155,10 +1107,10 @@ int s32k1xx_dmach_xfrsetup(DMACH_HANDLE *handle,
  *   Start the DMA transfer.  This function should be called after the final
  *   call to s32k1xx_dmach_xfrsetup() in order to avoid race conditions.
  *
- *   At the conclusion of each major DMA loop, a callback to the user
- *   provided function is made:  |For "normal" DMAs, this will correspond to
- *   the DMA DONE interrupt; for scatter gather DMAs, multiple interrupts
- *   will be generated with the final being the DONE interrupt.
+ *   At the conclusion of each major DMA loop, a callback to
+ *   the user-provided function is made: For "normal" DMAs, this will
+ *   correspond to the DMA DONE interrupt; for scatter gather DMAs,
+ *   this will be generated with the final TCD.
  *
  *   At the conclusion of the DMA, the DMA channel is reset, all TCDs are
  *   freed, and the callback function is called with the the success/fail
@@ -1191,14 +1143,13 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
 
   DEBUGASSERT(dmach != NULL && dmach->state == S32K1XX_DMA_CONFIGURED);
   chan            = dmach->chan;
-  dmainfo("dmach%u: %p callback: %p arg: %p\n", dmach, chan, callback, arg);
+  dmainfo("dmach%u: %p callback: %p arg: %p\n", chan, dmach, callback, arg);
 
   /* Save the callback info.  This will be invoked when the DMA completes */
 
   flags           = spin_lock_irqsave(NULL);
   dmach->callback = callback;
   dmach->arg      = arg;
-  dmach->state    = S32K1XX_DMA_ACTIVE;
 
 #if CONFIG_S32K1XX_EDMA_NTCD > 0
   /* Although it is not recommended, it might be possible to call this
@@ -1208,6 +1159,8 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
   if (dmach->state != S32K1XX_DMA_ACTIVE)
 #endif
     {
+      dmach->state    = S32K1XX_DMA_ACTIVE;
+
       /* Enable channel ERROR interrupts */
 
       regval8         = EDMA_SEEI(chan);
@@ -1216,7 +1169,7 @@ int s32k1xx_dmach_start(DMACH_HANDLE handle, edma_callback_t callback,
       /* Enable the DMA request for this channel */
 
       regval8         = EDMA_SERQ(chan);
-      putreg8(regval8, S32K1XX_EDMA_SERQ_OFFSET);
+      putreg8(regval8, S32K1XX_EDMA_SERQ);
     }
 
   spin_unlock_irqrestore(NULL, flags);
diff --git a/arch/arm/src/s32k1xx/s32k1xx_edma.h b/arch/arm/src/s32k1xx/s32k1xx_edma.h
index cd29a6d4e2..ac85a0a03f 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_edma.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_edma.h
@@ -122,6 +122,18 @@
 #  define EDMA_CONFIG_LINKTYPE_MINORLINK (1 << EDMA_CONFIG_LINKTYPE_SHIFT) /* Channel link after each minor loop */
 #  define EDMA_CONFIG_LINKTYPE_MAJORLINK (2 << EDMA_CONFIG_LINKTYPE_SHIFT) /* Channel link when major loop count exhausted */
 
+#define EDMA_CONFIG_LOOP_SHIFT           (2) /* Bits 2-3: Loop type */
+#define EDMA_CONFIG_LOOP_MASK            (3 << EDMA_CONFIG_LOOP_SHIFT)
+#  define EDMA_CONFIG_LOOPNONE           (0 << EDMA_CONFIG_LOOP_SHIFT) /* No looping */
+#  define EDMA_CONFIG_LOOPSRC            (1 << EDMA_CONFIG_LOOP_SHIFT) /* Source looping */
+#  define EDMA_CONFIG_LOOPDEST           (2 << EDMA_CONFIG_LOOP_SHIFT) /* Dest looping */
+
+#define EDMA_CONFIG_INTHALF              (1 << 4) /* Bits 4: Int on HALF */
+#define EDMA_CONFIG_INTMAJOR             (1 << 5) /* Bits 5: Int on all Major completion
+                                                   * Default is only on last completion
+                                                   * if using scatter gather
+                                                   */
+
 /****************************************************************************
  * Public Types
  ****************************************************************************/
@@ -130,19 +142,19 @@ typedef void *DMACH_HANDLE;
 typedef void (*edma_callback_t)(DMACH_HANDLE handle,
                                 void *arg, bool done, int result);
 
-/* eDMA transfer type */
-
-enum s32k1xx_edma_xfrtype_e
-{
-  EDMA_MEM2MEM = 0,      /* Transfer from memory to memory */
-  EDMA_PERIPH2MEM,       /* Transfer from peripheral to memory */
-  EDMA_MEM2PERIPH,       /* Transfer from memory to peripheral */
-};
-
 /* This structure holds the source/destination transfer attribute
  * configuration.
  */
 
+/* eDMA transfer sizes */
+
+enum s32k1xx_edma_sizes_e
+{
+  EDMA_8BIT    = 0,      /* Transfer data size 8 */
+  EDMA_16BIT   = 1,      /* Transfer data size 16 */
+  EDMA_32BIT   = 2,      /* Transfer data size 32 */
+};
+
 struct s32k1xx_edma_xfrconfig_s
 {
     uint32_t saddr;      /* Source data address. */
@@ -153,7 +165,6 @@ struct s32k1xx_edma_xfrconfig_s
     uint8_t  flags;      /* See EDMA_CONFIG_* definitions */
     uint8_t  ssize;      /* Source data transfer size (see TCD_ATTR_SIZE_* definitions in rdware/. */
     uint8_t  dsize;      /* Destination data transfer size. */
-    uint8_t  ttype;      /* Transfer type (see enum s32k1xx_edma_xfrtype_e). */
 #ifdef CONFIG_S32K1XX_EDMA_EMLIM
     uint16_t nbytes;     /* Bytes to transfer in a minor loop */
 #else
@@ -264,7 +275,7 @@ extern "C"
  *
  ****************************************************************************/
 
-DMACH_HANDLE s32k1xx_dmach_alloc(uint32_t dmamux, uint8_t dchpri);
+DMACH_HANDLE s32k1xx_dmach_alloc(uint8_t dmamux, uint8_t dchpri);
 
 /****************************************************************************
  * Name: s32k1xx_dmach_free
diff --git a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
index 5b6d2f9b5e..c92dc5b897 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_flexcan.c
@@ -41,6 +41,7 @@
 #include <nuttx/signal.h>
 #include <nuttx/net/netdev.h>
 #include <nuttx/net/can.h>
+#include <netpacket/can.h>
 
 #include "arm_internal.h"
 #include "chip.h"
@@ -502,9 +503,6 @@ static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze);
 static uint32_t s32k1xx_waitmcr_change(uint32_t base,
                                        uint32_t mask,
                                        uint32_t target_state);
-static uint32_t s32k1xx_waitesr2_change(uint32_t base,
-                                       uint32_t mask,
-                                       uint32_t target_state);
 
 /* Interrupt handling */
 
@@ -1219,26 +1217,6 @@ static void s32k1xx_setenable(uint32_t base, uint32_t enable)
   s32k1xx_waitmcr_change(base, CAN_MCR_LPMACK, 1);
 }
 
-static uint32_t s32k1xx_waitesr2_change(uint32_t base, uint32_t mask,
-                                       uint32_t target_state)
-{
-  const uint32_t timeout = 1000;
-  uint32_t wait_ack;
-
-  for (wait_ack = 0; wait_ack < timeout; wait_ack++)
-    {
-      uint32_t state = (getreg32(base + S32K1XX_CAN_ESR2_OFFSET) & mask);
-      if (state == target_state)
-        {
-          return true;
-        }
-
-      up_udelay(10);
-    }
-
-  return false;
-}
-
 static void s32k1xx_setfreeze(uint32_t base, uint32_t freeze)
 {
   uint32_t regval;
@@ -1398,9 +1376,7 @@ static void s32k1xx_txavail_work(void *arg)
        * packet.
        */
 
-      if (s32k1xx_waitesr2_change(priv->base,
-                             (CAN_ESR2_IMB | CAN_ESR2_VPS),
-                             (CAN_ESR2_IMB | CAN_ESR2_VPS)))
+      if (!s32k1xx_txringfull(priv))
         {
           /* No, there is space for another transfer.  Poll the network for
            * new XMIT data.
@@ -1452,6 +1428,65 @@ static int s32k1xx_txavail(struct net_driver_s *dev)
   return OK;
 }
 
+#ifdef CONFIG_NETDEV_CAN_FILTER_IOCTL
+static int s32k1xx_extfilter(struct s32k1xx_driver_s *priv, bool add, struct can_ioctl_filter_s *arg)
+{
+  int i;
+
+  if(arg->ftype != CAN_FILTER_MASK)
+    {
+      return -ENOTSUP;
+    }
+
+  /* Enter freeze mode */
+
+  s32k1xx_setfreeze(priv->base, 1);
+  if (!s32k1xx_waitfreezeack_change(priv->base, 1))
+    {
+      ninfo("FLEXCAN: freeze fail\n");
+      return -1;
+    }
+
+  /* Single filter support for now */
+
+  if (add)
+    {
+      for (i = 0; i < RXMBCOUNT; i++)
+        {
+          /* Setup mask */
+
+          putreg32(arg->fid2 | (1 << 30), priv->base + S32K1XX_CAN_RXIMR_OFFSET(i));
+
+          /* Setup filter */
+          priv->rx[i].id.ext = arg->fid1;
+        }
+    }
+  else
+    {
+      for (i = 0; i < RXMBCOUNT; i++)
+        {
+          /* Reset mask */
+
+          putreg32(0x0, priv->base + S32K1XX_CAN_RXIMR_OFFSET(i));
+
+          /* Reset filter */
+          priv->rx[i].id.ext = 0x0;
+        }
+    }
+
+  /* Exit freeze mode */
+  
+  s32k1xx_setfreeze(priv->base, 0);
+  if (!s32k1xx_waitfreezeack_change(priv->base, 0))
+    {
+      ninfo("FLEXCAN: unfreeze fail\n");
+      return -1;
+    }
+
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Function: s32k1xx_ioctl
  *
@@ -1470,7 +1505,7 @@ static int s32k1xx_txavail(struct net_driver_s *dev)
  *
  ****************************************************************************/
 
-#ifdef CONFIG_NETDEV_CAN_BITRATE_IOCTL
+#ifdef CONFIG_NETDEV_IOCTL
 static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
                          unsigned long arg)
 {
@@ -1481,6 +1516,7 @@ static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
 
   switch (cmd)
     {
+#ifdef CONFIG_NETDEV_CAN_BITRATE_IOCTL
       case SIOCGCANBITRATE: /* Get bitrate from a CAN controller */
         {
           struct can_ioctl_data_s *req =
@@ -1543,6 +1579,21 @@ static int s32k1xx_ioctl(struct net_driver_s *dev, int cmd,
             }
         }
         break;
+#endif
+
+#ifdef CONFIG_NETDEV_CAN_FILTER_IOCTL
+      case SIOCACANEXTFILTER: /* Add hardware-level extended ID filter */
+        {
+          ret = s32k1xx_extfilter(priv, true, (struct can_ioctl_filter_s *)arg);
+        }
+        break;
+
+      case SIOCDCANEXTFILTER: /* Delete hardware-level extended ID filter */
+        {
+          ret = s32k1xx_extfilter(priv, false, (struct can_ioctl_filter_s *)arg);
+        }
+        break;
+#endif
 
       default:
         ret = -ENOTTY;
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
index 1a900fc724..aa581b70cb 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpi2c.c
@@ -43,7 +43,9 @@
 #include <arch/irq.h>
 
 #include "arm_internal.h"
+#include "s32k1xx_edma.h"
 #include "s32k1xx_pin.h"
+#include "hardware/s32k1xx_dmamux.h"
 #include "hardware/s32k1xx_pinmux.h"
 #include "s32k1xx_lpi2c.h"
 #include "s32k1xx_periphclocks.h"
@@ -67,24 +69,24 @@
 
 /* Interrupt wait timeout in seconds and milliseconds */
 
-#if !defined(CONFIG_S32K1XX_I2CTIMEOSEC) && !defined(CONFIG_S32K1XX_I2CTIMEOMS)
-#  define CONFIG_S32K1XX_I2CTIMEOSEC 0
-#  define CONFIG_S32K1XX_I2CTIMEOMS  500   /* Default is 500 milliseconds */
-#elif !defined(CONFIG_S32K1XX_I2CTIMEOSEC)
-#  define CONFIG_S32K1XX_I2CTIMEOSEC 0     /* User provided milliseconds */
-#elif !defined(CONFIG_S32K1XX_I2CTIMEOMS)
-#  define CONFIG_S32K1XX_I2CTIMEOMS  0     /* User provided seconds */
+#if !defined(CONFIG_S32K1XX_LPI2CTIMEOSEC) && !defined(CONFIG_S32K1XX_LPI2CTIMEOMS)
+#  define CONFIG_S32K1XX_LPI2CTIMEOSEC 0
+#  define CONFIG_S32K1XX_LPI2CTIMEOMS  500   /* Default is 500 milliseconds */
+#elif !defined(CONFIG_S32K1XX_LPI2CTIMEOSEC)
+#  define CONFIG_S32K1XX_LPI2CTIMEOSEC 0     /* User provided milliseconds */
+#elif !defined(CONFIG_S32K1XX_LPI2CTIMEOMS)
+#  define CONFIG_S32K1XX_LPI2CTIMEOMS  0     /* User provided seconds */
 #endif
 
 /* Interrupt wait time timeout in system timer ticks */
 
-#ifndef CONFIG_S32K1XX_I2CTIMEOTICKS
-#  define CONFIG_S32K1XX_I2CTIMEOTICKS \
-    (SEC2TICK(CONFIG_S32K1XX_I2CTIMEOSEC) + MSEC2TICK(CONFIG_S32K1XX_I2CTIMEOMS))
+#ifndef CONFIG_S32K1XX_LPI2CTIMEOTICKS
+#  define CONFIG_S32K1XX_LPI2CTIMEOTICKS \
+    (SEC2TICK(CONFIG_S32K1XX_LPI2CTIMEOSEC) + MSEC2TICK(CONFIG_S32K1XX_LPI2CTIMEOMS))
 #endif
 
-#ifndef CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP
-#  define CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP TICK2USEC(CONFIG_S32K1XX_I2CTIMEOTICKS)
+#ifndef CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP
+#  define CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP TICK2USEC(CONFIG_S32K1XX_LPI2CTIMEOTICKS)
 #endif
 
 /* Debug ********************************************************************/
@@ -111,6 +113,8 @@
 #define MKI2C_OUTPUT(p) (((p) & (~_PIN_MODE_MASK)) | GPIO_OUTPUT | GPIO_OUTPUT_ONE)
 #define MKI2C_INPUT(p)  (((p) & (~_PIN_MODE_MASK)) | GPIO_INPUT)
 
+#define LPI2C_MSR_LIMITED_ERROR_MASK (LPI2C_MSR_ERROR_MASK & ~(LPI2C_MSR_FEF))
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
@@ -163,6 +167,10 @@ struct s32k1xx_lpi2c_config_s
 #ifndef CONFIG_I2C_POLLED
   uint32_t irq;               /* Event IRQ */
 #endif
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  uint32_t        dma_rxreqsrc;  /* DMA mux rx source */
+  uint32_t        dma_txreqsrc;  /* DMA mux tx source */
+#endif
 };
 
 /* I2C Device Private Data */
@@ -202,6 +210,11 @@ struct s32k1xx_lpi2c_priv_s
   struct s32k1xx_trace_s trace[CONFIG_I2C_NTRACE];
 #endif
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  DMACH_HANDLE rxdma;                                  /* rx DMA handle */
+  DMACH_HANDLE txdma;                                  /* tx DMA handle */
+  uint16_t     cmnds[CONFIG_S32K1XX_LPI2C_DMA_MAXMSG]; /* Commands */
+#endif
   uint32_t status;             /* End of transfer SR2|SR1 status */
 };
 
@@ -222,10 +235,10 @@ s32k1xx_lpi2c_modifyreg(struct s32k1xx_lpi2c_priv_s *priv,
 static inline int
 s32k1xx_lpi2c_sem_wait(struct s32k1xx_lpi2c_priv_s *priv);
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
 static uint32_t
 s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs);
-#endif /* CONFIG_S32K1XX_I2C_DYNTIMEO */
+#endif /* CONFIG_S32K1XX_LPI2C_DYNTIMEO */
 
 static inline int
 s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv);
@@ -273,6 +286,13 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 static int s32k1xx_lpi2c_reset(struct i2c_master_s *dev);
 #endif
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_rxdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                                  int result);
+static void s32k1xx_txdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                                  int result);
+#endif
+
 /****************************************************************************
  * Private Data
  ****************************************************************************/
@@ -318,6 +338,10 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c0_config =
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C0M,
 #endif
+#ifdef CONFIG_LPI2C0_DMA
+  .dma_rxreqsrc    = S32K1XX_DMACHAN_LPI2C0_RX,
+  .dma_txreqsrc    = S32K1XX_DMACHAN_LPI2C0_TX,
+#endif
 };
 
 static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c0_priv =
@@ -348,6 +372,10 @@ static const struct s32k1xx_lpi2c_config_s s32k1xx_lpi2c1_config =
 #ifndef CONFIG_I2C_POLLED
   .irq        = S32K1XX_IRQ_LPI2C1M,
 #endif
+#ifdef CONFIG_LPI2C1_DMA
+  .dma_rxreqsrc    = S32K1XX_DMACHAN_LPI2C1_RX,
+  .dma_txreqsrc    = S32K1XX_DMACHAN_LPI2C1_TX,
+#endif
 };
 
 static struct s32k1xx_lpi2c_priv_s s32k1xx_lpi2c1_priv =
@@ -439,7 +467,7 @@ s32k1xx_lpi2c_sem_wait(struct s32k1xx_lpi2c_priv_s *priv)
  *
  ****************************************************************************/
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
 static uint32_t s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs)
 {
   size_t bytecount = 0;
@@ -456,7 +484,7 @@ static uint32_t s32k1xx_lpi2c_toticks(int msgc, struct i2c_msg_s *msgs)
    * factor.
    */
 
-  return USEC2TICK(CONFIG_S32K1XX_I2C_DYNTIMEO_USECPERBYTE * bytecount);
+  return USEC2TICK(CONFIG_S32K1XX_LPI2C_DYNTIMEO_USECPERBYTE * bytecount);
 }
 #endif
 
@@ -478,47 +506,53 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   flags = enter_critical_section();
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma == NULL && priv->txdma == NULL)
+    {
+#endif
+      /* Clear the TX and RX FIFOs */
+
+      s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
+                              LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+
   /* Enable Interrupts when master mode */
 
-  if (priv->config->mode == LPI2C_MASTER)
-    {
-      if ((priv->flags & I2C_M_READ) != 0)
-        {
-          regval = LPI2C_MIER_TDIE | LPI2C_MIER_RDIE | LPI2C_MIER_NDIE | \
-                   LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
-        }
-      else
+      if (priv->config->mode == LPI2C_MASTER)
         {
-          regval = LPI2C_MIER_TDIE | LPI2C_MIER_NDIE | \
-                   LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+          if ((priv->flags & I2C_M_READ) != 0)
+            {
+              regval = LPI2C_MIER_TDIE | LPI2C_MIER_RDIE | LPI2C_MIER_NDIE |
+                       LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
+              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+            }
+          else
+            {
+              regval = LPI2C_MIER_TDIE | LPI2C_MIER_NDIE | \
+                       LPI2C_MIER_ALIE | LPI2C_MIER_SDIE;
+              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, regval);
+            }
         }
-    }
 
-  /* Enable Interrupts when slave mode */
+      /* Enable Interrupts when slave mode */
 
-  else
-    {
+      else
+        {
 #warning Missing logic for I2C Slave mode
+        }
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
     }
+#endif
 
-  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
-   * are currently disabled but will be temporarily re-enabled below when
-   * nxsem_tickwait_uninterruptible() sleeps.
-   */
-
-  priv->intstate = INTSTATE_WAITING;
   do
     {
       /* Wait until either the transfer is complete or the timeout expires */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
       ret = nxsem_tickwait_uninterruptible(&priv->sem_isr,
                      s32k1xx_lpi2c_toticks(priv->msgc, priv->msgv));
 #else
       ret = nxsem_tickwait_uninterruptible(&priv->sem_isr,
-                                           CONFIG_S32K1XX_I2CTIMEOTICKS);
+                                           CONFIG_S32K1XX_LPI2CTIMEOTICKS);
 #endif
       if (ret < 0)
         {
@@ -541,16 +575,12 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Disable I2C interrupts */
 
-  /* Enable Interrupts when master mode */
-
   if (priv->config->mode == LPI2C_MASTER)
     {
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0);
     }
 
 #if 0
-  /* Enable Interrupts when slave mode */
-
   else
     {
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_SIER_OFFSET, 0);
@@ -571,18 +601,11 @@ s32k1xx_lpi2c_sem_waitdone(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Get the timeout value */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
   timeout = s32k1xx_lpi2c_toticks(priv->msgc, priv->msgv);
 #else
-  timeout = CONFIG_S32K1XX_I2CTIMEOTICKS;
+  timeout = CONFIG_S32K1XX_LPI2CTIMEOTICKS;
 #endif
-
-  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
-   * are currently disabled but will be temporarily re-enabled below when
-   * nxsem_tickwait_uninterruptible() sleeps.
-   */
-
-  priv->intstate = INTSTATE_WAITING;
   start = clock_systime_ticks();
 
   do
@@ -631,10 +654,10 @@ s32k1xx_lpi2c_sem_waitstop(struct s32k1xx_lpi2c_priv_s *priv)
 
   /* Select a timeout */
 
-#ifdef CONFIG_S32K1XX_I2C_DYNTIMEO
-  timeout = USEC2TICK(CONFIG_S32K1XX_I2C_DYNTIMEO_STARTSTOP);
+#ifdef CONFIG_S32K1XX_LPI2C_DYNTIMEO
+  timeout = USEC2TICK(CONFIG_S32K1XX_LPI2C_DYNTIMEO_STARTSTOP);
 #else
-  timeout = CONFIG_S32K1XX_I2CTIMEOTICKS;
+  timeout = CONFIG_S32K1XX_LPI2CTIMEOTICKS;
 #endif
 
   /* Wait as stop might still be in progress; but stop might also
@@ -755,6 +778,81 @@ s32k1xx_lpi2c_sem_destroy(struct s32k1xx_lpi2c_priv_s *priv)
 #endif
 }
 
+/****************************************************************************
+ * Name: s32k1xx_rxdma_callback
+ *
+ * Description:
+ *   This function performs the next I2C operation
+ *
+ ****************************************************************************/
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_rxdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)arg;
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0,
+                              LPI2C_MIER_SDIE);
+
+  if (result == OK)
+    {
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+          s32k1xx_lpi2c_sendstop(priv);
+        }
+    }
+  else
+    {
+      uint32_t status = s32k1xx_lpi2c_getstatus(priv);
+
+      if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+        {
+          i2cerr("ERROR: MSR: status: 0x0%" PRIx32 "\n", status);
+
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
+        }
+    }
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_txdma_callback
+ *
+ * Description:
+ *   This function performs the next I2C operation
+ *
+ ****************************************************************************/
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static void s32k1xx_txdma_callback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)arg;
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0,
+                              LPI2C_MIER_SDIE);
+
+  if (result == OK)
+    {
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_sendstop(priv);
+        }
+    }
+  else
+    {
+      uint32_t status = s32k1xx_lpi2c_getstatus(priv);
+
+      if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+        {
+          i2cerr("ERROR: MSR: status: 0x0%" PRIx32 "\n", status);
+
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
+        }
+    }
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_trace*
  *
@@ -1080,10 +1178,10 @@ s32k1xx_lpi2c_sendstart(struct s32k1xx_lpi2c_priv_s *priv,
 
   /* Generate START condition and send the address */
 
-  /* Turn off auto_stop option */
+  /* Disable AUTOSTOP and NAK Ignore */
 
   s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET,
-                          LPI2C_MCFGR1_IGNACK, 0);
+                          LPI2C_MCFGR1_IGNACK | LPI2C_MCFGR1_AUTOSTOP, 0);
 
   do
     {
@@ -1142,6 +1240,20 @@ s32k1xx_lpi2c_getstatus(struct s32k1xx_lpi2c_priv_s *priv)
   return s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MSR_OFFSET);
 }
 
+/****************************************************************************
+ * Name: imxrt_lpi2c_getenabledints
+ *
+ * Description:
+ *   Get 32-bit status
+ *
+ ****************************************************************************/
+
+static inline uint32_t
+s32k1xx_lpi2c_getenabledints(struct s32k1xx_lpi2c_priv_s *priv)
+{
+  return s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MIER_OFFSET);
+}
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_isr_process
  *
@@ -1154,208 +1266,278 @@ static int s32k1xx_lpi2c_isr_process(struct s32k1xx_lpi2c_priv_s *priv)
 {
   uint32_t status = s32k1xx_lpi2c_getstatus(priv);
 
-  /* Check for new trace setup */
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  uint32_t current_status = status;
 
-  s32k1xx_lpi2c_tracenew(priv, status);
+  /* Condition the status with only the enabled interrupts */
 
-  /* After an error we can get a STOP Detect Flag  */
+  status &= s32k1xx_lpi2c_getenabledints(priv);
 
-  if (priv->intstate == INTSTATE_DONE && (status & LPI2C_MSR_SDF) != 0)
+  if (priv->rxdma != NULL || priv->txdma != NULL)
     {
-      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
-      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_SDF);
-    }
-
-  /* Check if there is more bytes to send */
+      /* Is there an Error condition */
 
-  else if (((priv->flags & I2C_M_READ) == 0) &&
-           (status & LPI2C_MSR_TDF) != 0)
-    {
-      if (priv->dcnt > 0)
+      if (current_status & LPI2C_MSR_LIMITED_ERROR_MASK)
         {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE, priv->dcnt);
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
-                             LPI2C_MTDR_CMD_TXD |
-                             LPI2C_MTDR_DATA(*priv->ptr++));
-          priv->dcnt--;
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
 
-          if ((priv->msgc <= 0) && (priv->dcnt == 0))
-            {
-              s32k1xx_lpi2c_sendstop(priv);
-            }
-        }
-    }
+          /* Return the full error status */
 
-  /* Check if there is more bytes to read */
+          priv->status = current_status;
+        }
 
-  else if (((priv->flags & I2C_M_READ) != 0) &&
-           (status & LPI2C_MSR_RDF) != 0)
-    {
-      /* Read a byte, if dcnt goes < 0, then read dummy bytes to ack ISRs */
+      /* End of packet or Stop */
 
-      if (priv->dcnt > 0)
+      if ((status & (LPI2C_MSR_SDF | LPI2C_MSR_EPF)) != 0)
         {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_RCVBYTE, priv->dcnt);
-
-          /* No interrupts or contex switches should occur in the following
-           * sequence. Otherwise, additional bytes may be sent by the device.
-           */
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
 
-#ifdef CONFIG_I2C_POLLED
-          irqstate_t flags = enter_critical_section();
-#endif
+          /* Acknowledge End of packet or Stop */
 
-          /* Receive a byte */
+          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, status &
+                                                           (LPI2C_MSR_SDF |
+                                                           LPI2C_MSR_EPF));
 
-          *priv->ptr++ =
-            s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET) &
-            LPI2C_MRDR_DATA_MASK;
+          /* Mark that this transaction stopped */
 
-          priv->dcnt--;
+          priv->msgv = NULL;
+          priv->msgc = 0;
+          priv->dcnt = -1;
 
-#ifdef CONFIG_I2C_POLLED
-          leave_critical_section(flags);
-#endif
-          if ((priv->msgc <= 0) && (priv->dcnt == 0))
+          if (priv->intstate == INTSTATE_WAITING)
             {
-              s32k1xx_lpi2c_sendstop(priv);
-            }
-        }
-      else
-        {
-          s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET);
-        }
-    }
+              /* inform the thread that transfer is complete
+               * and wake it up
+               */
 
-  if (priv->dcnt <= 0)
-    {
-      if (priv->msgc > 0 && priv->msgv != NULL)
-        {
-          priv->ptr   = priv->msgv->buffer;
-          priv->dcnt  = priv->msgv->length;
-          priv->flags = priv->msgv->flags;
+              s32k1xx_dmach_stop(priv->txdma);
+              s32k1xx_dmach_stop(priv->rxdma);
 
-          if ((priv->msgv->flags & I2C_M_NOSTART) == 0)
-            {
-              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STARTRESTART,
-                                     priv->msgc);
-              s32k1xx_lpi2c_sendstart(priv, priv->msgv->addr);
-            }
-          else
-            {
-              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_NOSTART, priv->msgc);
+              priv->intstate = INTSTATE_DONE;
+              nxsem_post(&priv->sem_isr);
             }
+        }
 
-          priv->msgv++;
-          priv->msgc--;
+          /* Clear the error */
 
-          if ((priv->flags & I2C_M_READ) != 0)
-            {
-#ifndef CONFIG_I2C_POLLED
-              /* Stop TX interrupt */
+          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
+                            (current_status & (LPI2C_MSR_NDF |
+                                               LPI2C_MSR_ALF |
+                                               LPI2C_MSR_FEF)));
 
-              s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
-                                    LPI2C_MIER_TDIE, LPI2C_MIER_RDIE);
+      return OK;
+    }
 #endif
-              /* Set LPI2C in read mode */
 
-              s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
-                                 LPI2C_MTDR_CMD_RXD |
-                                 LPI2C_MTDR_DATA((priv->dcnt - 1)));
-            }
-          else
-            {
-              /* Send the first byte from tx buffer */
+  /* Check for new trace setup */
+
+  s32k1xx_lpi2c_tracenew(priv, status);
 
+  if ((status & LPI2C_MSR_LIMITED_ERROR_MASK) == 0)
+    {
+      /* Check if there is more bytes to send */
+
+      if (((priv->flags & I2C_M_READ) == 0) &&
+               (status & LPI2C_MSR_TDF) != 0)
+        {
+          if (priv->dcnt > 0)
+            {
               s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE, priv->dcnt);
               s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
                                  LPI2C_MTDR_CMD_TXD |
                                  LPI2C_MTDR_DATA(*priv->ptr++));
               priv->dcnt--;
+
+              /* Last byte of last message? */
+
               if ((priv->msgc <= 0) && (priv->dcnt == 0))
                 {
-                  s32k1xx_lpi2c_sendstop(priv);
+                  if ((priv->flags & I2C_M_NOSTOP) == 0)
+                    {
+                      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                      /* Do this once */
+
+                      priv->flags |= I2C_M_NOSTOP;
+                      s32k1xx_lpi2c_sendstop(priv);
+                    }
                 }
             }
         }
-      else if (priv->msgv && ((status & LPI2C_MSR_SDF) != 0))
-        {
-          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
-          s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
-                             LPI2C_MSR_SDF);
 
-          /* Check is there thread waiting for this event (there should be) */
+      /* Check if there is more bytes to read */
 
-#ifndef CONFIG_I2C_POLLED
-          if (priv->intstate == INTSTATE_WAITING)
-            {
-              /* Update Status once at the end */
+      else if (((priv->flags & I2C_M_READ) != 0) &&
+               (status & LPI2C_MSR_RDF) != 0)
+        {
+          /* Read a byte, if dcnt goes < 0, read dummy bytes to ack ISRs */
 
-              priv->status = status;
+          if (priv->dcnt > 0)
+            {
+              s32k1xx_lpi2c_traceevent(priv, I2CEVENT_RCVBYTE, priv->dcnt);
 
-              /* inform the thread that transfer is complete
-               * and wake it up
+              /* No interrupts or context switches should occur in the
+               * following sequence. Otherwise, additional bytes may be
+               * sent by the device.
                */
 
-              nxsem_post(&priv->sem_isr);
-              priv->intstate = INTSTATE_DONE;
+    #ifdef CONFIG_I2C_POLLED
+              irqstate_t flags = enter_critical_section();
+    #endif
+
+              /* Receive a byte */
+
+              *priv->ptr++ = s32k1xx_lpi2c_getreg(priv,
+                                                S32K1XX_LPI2C_MRDR_OFFSET) &
+                                                LPI2C_MRDR_DATA_MASK;
+              priv->dcnt--;
+
+    #ifdef CONFIG_I2C_POLLED
+              leave_critical_section(flags);
+    #endif
+              /* Last byte of last message? */
+
+              if ((priv->msgc <= 0) && (priv->dcnt == 0))
+                {
+                  if ((priv->flags & I2C_M_NOSTOP) == 0)
+                    {
+                      s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                      /* Do this once */
+
+                      priv->flags |= I2C_M_NOSTOP;
+                      s32k1xx_lpi2c_sendstop(priv);
+                    }
+                }
             }
-#else
-          priv->status = status;
-          priv->intstate = INTSTATE_DONE;
-#endif
-          /* Mark that this transaction stopped */
+          else
+            {
+              /* Read and discard data */
 
-          priv->msgv = NULL;
+              s32k1xx_lpi2c_getreg(priv, S32K1XX_LPI2C_MRDR_OFFSET);
+            }
         }
-#ifndef CONFIG_I2C_POLLED
-      else
+
+      /* Start the first or next message */
+
+      if (priv->dcnt <= 0 && (status & (LPI2C_MSR_EPF | LPI2C_MSR_SDF)) == 0)
         {
-          s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
-                                LPI2C_MIER_TDIE | LPI2C_MIER_RDIE, 0);
-        }
+          if (priv->msgc > 0 && priv->msgv != NULL)
+            {
+              priv->ptr   = priv->msgv->buffer;
+              priv->dcnt  = priv->msgv->length;
+              priv->flags = priv->msgv->flags;
+
+              if ((priv->flags & I2C_M_NOSTART) == 0)
+                {
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STARTRESTART,
+                                         priv->msgc);
+
+                  /* Do this once */
+
+                  priv->flags |= I2C_M_NOSTART;
+
+                  s32k1xx_lpi2c_sendstart(priv, priv->msgv->addr);
+                }
+              else
+                {
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_NOSTART,
+                                           priv->msgc);
+                }
+
+              priv->msgv++;
+              priv->msgc--;
+
+              if ((priv->flags & I2C_M_READ) != 0)
+                {
+#ifndef CONFIG_I2C_POLLED
+                  /* Stop TX interrupt */
+
+                  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                                        LPI2C_MIER_TDIE, LPI2C_MIER_RDIE);
 #endif
-    }
+                  /* Set LPI2C in read mode */
 
-  /* Check for errors */
+                  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
+                                     LPI2C_MTDR_CMD_RXD |
+                                     LPI2C_MTDR_DATA((priv->dcnt - 1)));
+                }
+              else
+                {
+                  /* Send the first byte from tx buffer */
 
-  if ((status & LPI2C_MSR_EPF) != 0)
-    {
-      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_EPF);
-    }
+                  s32k1xx_lpi2c_traceevent(priv, I2CEVENT_SENDBYTE,
+                                         priv->dcnt);
+                  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MTDR_OFFSET,
+                                     LPI2C_MTDR_CMD_TXD |
+                                     LPI2C_MTDR_DATA(*priv->ptr++));
+                  priv->dcnt--;
 
-  if ((status & LPI2C_MSR_ERROR_MASK) != 0)
+                  /* Last byte of last message? */
+
+                  if ((priv->msgc <= 0) && (priv->dcnt == 0))
+                    {
+                      if ((priv->flags & I2C_M_NOSTOP) == 0)
+                        {
+                          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+                          /* Do this once */
+
+                          priv->flags |= I2C_M_NOSTOP;
+                          s32k1xx_lpi2c_sendstop(priv);
+                        }
+                    }
+                }
+            }
+        }
+    }
+  else
     {
       s32k1xx_lpi2c_traceevent(priv, I2CEVENT_ERROR, 0);
 
-      /* Clear the TX and RX FIFOs */
+      priv->status = status;
 
-      s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
-                            LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+      if ((priv->flags & I2C_M_NOSTOP) == 0)
+        {
+          s32k1xx_lpi2c_traceevent(priv, I2CEVENT_STOP, 0);
+
+          /* Do this once */
+
+          priv->flags |= I2C_M_NOSTOP;
+          s32k1xx_lpi2c_sendstop(priv);
+        }
 
       /* Clear the error */
 
       s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET,
-                         (status & (LPI2C_MSR_NDF | LPI2C_MSR_ALF |
-                                    LPI2C_MSR_FEF)));
+                           (status & (LPI2C_MSR_NDF | LPI2C_MSR_ALF |
+                                      LPI2C_MSR_FEF | LPI2C_MSR_EPF)));
+    }
 
-#ifndef CONFIG_I2C_POLLED
-          if (priv->intstate == INTSTATE_WAITING)
-            {
-              /* Update Status once at the end */
+  /* Check for endof packet */
 
-              priv->status = status;
+  if ((status & (LPI2C_MSR_EPF | LPI2C_MSR_SDF)) != 0)
+    {
+      s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, status &
+                           (LPI2C_MSR_EPF | LPI2C_MSR_SDF));
 
-              /* inform the thread that transfer is complete
-               * and wake it up
-               */
+#ifndef CONFIG_I2C_POLLED
+      if (priv->intstate == INTSTATE_WAITING)
+        {
+          /* inform the thread that transfer is complete
+           * and wake it up
+           */
 
-              nxsem_post(&priv->sem_isr);
-              priv->intstate = INTSTATE_DONE;
-            }
-#else
-          priv->status = status;
           priv->intstate = INTSTATE_DONE;
+
+          s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                               LPI2C_MIER_TDIE | LPI2C_MIER_RDIE |
+                               LPI2C_MIER_NDIE | LPI2C_MIER_ALIE |
+                               LPI2C_MIER_SDIE | LPI2C_MIER_EPIE, 0);
+          nxsem_post(&priv->sem_isr);
+        }
+#else
+      priv->intstate = INTSTATE_DONE;
 #endif
     }
 
@@ -1491,6 +1673,239 @@ static int s32k1xx_lpi2c_deinit(struct s32k1xx_lpi2c_priv_s *priv)
  * Device Driver Operations
  ****************************************************************************/
 
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_command_configure
+ *
+ * Description:
+ *   Create a command TCD
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int
+s32k1xx_lpi2c_dma_command_configure(struct s32k1xx_lpi2c_priv_s
+                                    *priv, uint16_t *ccmd,
+                                     uint32_t ncmd)
+{
+  struct s32k1xx_edma_xfrconfig_s config;
+  memset(&config, 0, sizeof(config));
+
+  config.saddr  = (uint32_t) ccmd;
+  config.daddr  = priv->config->base + S32K1XX_LPI2C_MTDR_OFFSET;
+  config.soff   = sizeof(uint16_t);
+  config.doff   = 0;
+  config.iter   = 1;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_16BIT;
+  config.dsize  = EDMA_16BIT;
+  config.nbytes = sizeof(uint16_t) * ncmd;
+
+  up_clean_dcache((uintptr_t)config.saddr,
+                  (uintptr_t)config.saddr + config.nbytes);
+
+  return s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_data_configure
+ *
+ * Description:
+ *   Create a data TCD
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_dma_data_configure(struct s32k1xx_lpi2c_priv_s
+                                              *priv,
+                                              struct i2c_msg_s *msg)
+{
+  DMACH_HANDLE dma;
+  struct s32k1xx_edma_xfrconfig_s config;
+  memset(&config, 0, sizeof(config));
+
+  config.iter   = msg->length;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = sizeof(msg->buffer[0]);
+
+  if (msg->flags & I2C_M_READ)
+    {
+      dma           = priv->rxdma;
+      config.saddr  = priv->config->base + S32K1XX_LPI2C_MRDR_OFFSET;
+      config.daddr  = (uint32_t) msg->buffer;
+      config.soff   = 0;
+      config.doff   = sizeof(msg->buffer[0]);
+      up_invalidate_dcache((uintptr_t)msg->buffer,
+                           (uintptr_t)msg->buffer + msg->length);
+    }
+  else
+    {
+      dma           = priv->txdma;
+      config.saddr  = (uint32_t) msg->buffer;
+      config.daddr  = priv->config->base + S32K1XX_LPI2C_MTDR_OFFSET;
+      config.soff   = sizeof(msg->buffer[0]);
+      config.doff   = 0;
+      up_clean_dcache((uintptr_t)msg->buffer,
+                      (uintptr_t)msg->buffer + msg->length);
+    }
+
+  return s32k1xx_dmach_xfrsetup(dma, &config) ? 0 : msg->length;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_lpi2c_form_command_list
+ *
+ * Description:
+ *   Form the DMA command list
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_form_command_list(struct s32k1xx_lpi2c_priv_s
+                                              *priv, struct i2c_msg_s *msg,
+                                              int ncmds)
+{
+  ssize_t length = 0;
+
+  if (priv->flags & I2C_M_NOSTART)
+    {
+      if (priv->flags & I2C_M_READ)
+        {
+          /* No start read operation */
+
+          priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                 LPI2C_MTDR_DATA(msg->length - 1);
+        }
+    }
+  else
+    {
+      /* A start based read or write operation */
+
+      /* Create bus address with R/W */
+
+      uint16_t badd = (priv->flags & I2C_M_READ) ? I2C_READADDR8(msg->addr) :
+                                                   I2C_WRITEADDR8(msg->addr);
+
+      priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_START | LPI2C_MTDR_DATA(badd);
+
+      if (badd & I2C_READBIT)
+        {
+          length =  msg->length;
+          while (length)
+            {
+              if (length > 256u)
+                {
+                  priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                         LPI2C_MTDR_DATA(256u - 1);
+                  length -= 256u;
+                }
+              else
+                {
+                  priv->cmnds[ncmds++] = LPI2C_MTDR_CMD_RXD |
+                                         LPI2C_MTDR_DATA(length - 1);
+                  length = 0;
+                }
+            }
+        }
+    }
+
+  return ncmds;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_lpi2c_dma_transfer
+ *
+ * Description:
+ *   DMA based I2C transfer function
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+static int s32k1xx_lpi2c_dma_transfer(struct s32k1xx_lpi2c_priv_s *priv)
+{
+  int m;
+  int ntotcmds = 0;
+  int ncmds = 0;
+  uint16_t *ccmnd = NULL;
+
+  /* Disable Interrupts */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET, 0);
+
+  /* Disable DMA */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MDER_OFFSET, LPI2C_MDER_TDDE |
+                                                       LPI2C_MDER_RDDE, 0);
+
+  /* Enable AUTOSTOP and NAK Ignore */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCFGR1_OFFSET, 0,
+                          LPI2C_MCFGR1_IGNACK | LPI2C_MCFGR1_AUTOSTOP);
+
+  /* Form chains of tcd to process the messages */
+
+  for (m = 0; m < priv->msgc; m++)
+    {
+      ncmds = 0;
+      priv->flags = priv->msgv[m].flags;
+
+      /* Form a command list */
+
+      ccmnd = &priv->cmnds[ntotcmds];
+
+      ncmds = s32k1xx_lpi2c_form_command_list(priv, &priv->msgv[m],
+                                              ntotcmds);
+
+      /* Have commands for this message ? */
+
+      if (ncmds != 0)
+        {
+          /* Build up a TCD with the command from this message */
+
+          s32k1xx_lpi2c_dma_command_configure(priv, ccmnd, ncmds - ntotcmds);
+
+          ntotcmds += ncmds;
+
+          DEBUGASSERT(ntotcmds < CONFIG_S32K1XX_LPI2C_DMA_MAXMSG);
+
+          s32k1xx_lpi2c_dma_data_configure(priv, &priv->msgv[m]);
+        }
+    }
+
+  /* Clear the TX and RX FIFOs */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MCR_OFFSET, 0,
+                          LPI2C_MCR_RTF | LPI2C_MCR_RRF);
+
+  /* Reset the Error bits */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MSR_OFFSET, LPI2C_MSR_NDF |
+                                                       LPI2C_MSR_ALF |
+                                                       LPI2C_MSR_FEF);
+
+  /* Enable the Iterrupts */
+
+  s32k1xx_lpi2c_putreg(priv, S32K1XX_LPI2C_MIER_OFFSET,
+                     LPI2C_MIER_NDIE | LPI2C_MIER_ALIE |
+                     LPI2C_MIER_PLTIE);
+
+  /* Start The DMA */
+
+  s32k1xx_dmach_start(priv->rxdma, s32k1xx_rxdma_callback, (void *)priv);
+  s32k1xx_dmach_start(priv->txdma, s32k1xx_txdma_callback, (void *)priv);
+
+  /* Enable the DMA Request */
+
+  s32k1xx_lpi2c_modifyreg(priv, S32K1XX_LPI2C_MDER_OFFSET, 0,
+                          LPI2C_MDER_TDDE | LPI2C_MDER_RDDE);
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_lpi2c_transfer
  *
@@ -1504,6 +1919,9 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 {
   struct s32k1xx_lpi2c_priv_s *priv = (struct s32k1xx_lpi2c_priv_s *)dev;
   int ret;
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  int m;
+#endif
 
   DEBUGASSERT(count > 0);
 
@@ -1544,14 +1962,39 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
 
   priv->status = 0;
 
-  /* Wait for ISR. If there was a timeout, fetch latest status to get
+  /* Signal the interrupt handler that we are waiting.  NOTE:  Interrupts
+   * are currently disabled but will be temporarily re-enabled below when
+   * nxsem_tickwait_uninterruptible() sleeps.
+   */
+
+  priv->intstate = INTSTATE_WAITING;
+
+  /* Wait for an ISR, if there was a timeout, fetch latest status to get
    * the BUSY flag.
    */
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma || priv->txdma)
+    {
+      s32k1xx_lpi2c_dma_transfer(priv);
+    }
+#endif
+
   if (s32k1xx_lpi2c_sem_waitdone(priv) < 0)
     {
-      ret = -ETIMEDOUT;
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+    if (priv->rxdma != NULL)
+      {
+        s32k1xx_dmach_stop(priv->rxdma);
+      }
 
+    if (priv->txdma != NULL)
+      {
+        s32k1xx_dmach_stop(priv->txdma);
+      }
+
+#endif
+      ret = -ETIMEDOUT;
       i2cerr("ERROR: Timed out: MCR: status: 0x%" PRIx32 "\n", priv->status);
     }
 
@@ -1582,6 +2025,18 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
           i2cerr("Transfer without start condition\n");
           ret = -EINVAL;
         }
+
+        /* TODO fix in a better way if stuck and I2C won't work anymore */
+
+        /* In case the I2C peripheral is stuck, reset it */
+
+        /* De-init the port */
+
+        s32k1xx_lpi2c_deinit(priv);
+
+        /* Re-init the port */
+
+        s32k1xx_lpi2c_init(priv);
     }
 
   /* Dump the trace result */
@@ -1595,6 +2050,20 @@ static int s32k1xx_lpi2c_transfer(struct i2c_master_s *dev,
   priv->dcnt = 0;
   priv->ptr = NULL;
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma)
+    {
+      for (m = 0; m < count; m++)
+        {
+          if (msgs[m].flags & I2C_M_READ)
+            {
+            up_invalidate_dcache((uintptr_t)msgs[m].buffer,
+                                (uintptr_t)msgs[m].buffer + msgs[m].length);
+            }
+        }
+    }
+#endif
+
   s32k1xx_lpi2c_sem_post(priv);
   return ret;
 }
@@ -1787,6 +2256,22 @@ struct i2c_master_s *s32k1xx_i2cbus_initialize(int port)
     {
       s32k1xx_lpi2c_sem_init(priv);
       s32k1xx_lpi2c_init(priv);
+
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+      if (priv->config->dma_txreqsrc != 0)
+        {
+          priv->txdma = s32k1xx_dmach_alloc(priv->config->dma_txreqsrc |
+                                        DMAMUX_CHCFG_ENBL, 0);
+          DEBUGASSERT(priv->txdma != NULL);
+        }
+
+      if (priv->config->dma_rxreqsrc != 0)
+        {
+          priv->rxdma = s32k1xx_dmach_alloc(priv->config->dma_rxreqsrc |
+                                        DMAMUX_CHCFG_ENBL, 0);
+          DEBUGASSERT(priv->rxdma != NULL);
+        }
+#endif
     }
 
   leave_critical_section(flags);
@@ -1828,6 +2313,22 @@ int s32k1xx_i2cbus_uninitialize(struct i2c_master_s *dev)
 
   /* Disable power and other HW resource (GPIO's) */
 
+#ifdef CONFIG_S32K1XX_LPI2C_DMA
+  if (priv->rxdma != NULL)
+    {
+      s32k1xx_dmach_stop(priv->rxdma);
+      s32k1xx_dmach_free(priv->rxdma);
+      priv->rxdma = NULL;
+    }
+
+  if (priv->txdma != NULL)
+    {
+      s32k1xx_dmach_stop(priv->txdma);
+      s32k1xx_dmach_free(priv->txdma);
+      priv->txdma = NULL;
+    }
+#endif
+
   s32k1xx_lpi2c_deinit(priv);
 
   /* Release unused resources */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
index 1fc9e2b412..de45122ef3 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_lpspi.c
@@ -77,6 +77,11 @@
 #include "s32k1xx_periphclocks.h"
 #include "s32k1xx_lpspi.h"
 
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+#  include "hardware/s32k1xx_dmamux.h"
+#  include "s32k1xx_edma.h"
+#endif
+
 #include <arch/board/board.h>
 
 #if defined(CONFIG_S32K1XX_LPSPI0) || defined(CONFIG_S32K1XX_LPSPI1) || \
@@ -94,16 +99,15 @@
 #  error "Interrupt driven SPI not yet supported"
 #endif
 
-#if defined(CONFIG_S32K1XX_LPSPI_DMA)
-#  error "DMA mode is not yet supported"
-#endif
-
 /* Can't have both interrupt driven SPI and SPI DMA */
 
 #if defined(CONFIG_S32K1XX_LPSPI_INTERRUPTS) && defined(CONFIG_S32K1XX_LPSPI_DMA)
 #  error "Cannot enable both interrupt mode and DMA mode for SPI"
 #endif
 
+#define  SPI_SR_CLEAR   (LPSPI_SR_WCF | LPSPI_SR_FCF | LPSPI_SR_TCF  | \
+                         LPSPI_SR_TEF | LPSPI_SR_REF | LPSPI_SR_DMF)
+
 /* Power management definitions */
 
 #if defined(CONFIG_PM) && !defined(CONFIG_S32K1XX_PM_SPI_ACTIVITY)
@@ -136,6 +140,16 @@ struct s32k1xx_lpspidev_s
 #ifdef CONFIG_S32K1XX_LPSPI_HWPCS
   uint32_t pcs;               /* Peripheral Chip Select currently used */
 #endif
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+  volatile uint32_t rxresult;   /* Result of the RX DMA */
+  volatile uint32_t txresult;   /* Result of the TX DMA */
+  const uint16_t    rxch;       /* The RX DMA channel number */
+  const uint16_t    txch;       /* The TX DMA channel number */
+  DMACH_HANDLE      rxdma;      /* DMA channel handle for RX transfers */
+  DMACH_HANDLE      txdma;      /* DMA channel handle for TX transfers */
+  sem_t             rxsem;      /* Wait for RX DMA to complete */
+  sem_t             txsem;      /* Wait for TX DMA to complete */
+#endif
 };
 
 enum s32k1xx_delay_e
@@ -174,6 +188,21 @@ void s32k1xx_lpspi_set_delay_scaler(struct s32k1xx_lpspidev_s *priv,
                                     uint32_t scaler,
                                     enum s32k1xx_delay_e type);
 
+/* DMA support */
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int         spi_dmarxwait(struct s32k1xx_lpspidev_s *priv);
+static int         spi_dmatxwait(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmarxwakeup(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmatxwakeup(struct s32k1xx_lpspidev_s *priv);
+static void        spi_dmarxcallback(DMACH_HANDLE handle, void *arg,
+                                     bool done, int result);
+static void        spi_dmatxcallback(DMACH_HANDLE handle, void *arg,
+                                     bool done, int result);
+static inline void spi_dmarxstart(struct s32k1xx_lpspidev_s *priv);
+static inline void spi_dmatxstart(struct s32k1xx_lpspidev_s *priv);
+#endif
+
 /* SPI methods */
 
 static int s32k1xx_lpspi_lock(struct spi_dev_s *dev, bool lock);
@@ -260,9 +289,9 @@ static struct s32k1xx_lpspidev_s g_lpspi0dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI0,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI0_RX,
-  .txch         = DMAMAP_LPSPI0_TX,
+#ifdef CONFIG_S32K1XX_LPSPI0_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI0_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI0_TX,
 #endif
 };
 #endif
@@ -310,9 +339,9 @@ static struct s32k1xx_lpspidev_s g_lpspi1dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI1,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI1_RX,
-  .txch         = DMAMAP_LPSPI1_TX,
+#ifdef CONFIG_S32K1XX_LPSPI1_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI1_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI1_TX,
 #endif
 };
 #endif
@@ -360,9 +389,9 @@ static struct s32k1xx_lpspidev_s g_lpspi2dev =
 #ifdef CONFIG_S32K1XX_LPSPI_INTERRUPTS
   .spiirq       = S32K1XX_IRQ_LPSPI2,
 #endif
-#ifdef CONFIG_S32K1XX_LPSPI_DMA
-  .rxch         = DMAMAP_LPSPI2_RX,
-  .txch         = DMAMAP_LPSPI2_TX,
+#ifdef CONFIG_S32K1XX_LPSPI2_DMA
+  .rxch         = S32K1XX_DMACHAN_LPSPI2_RX,
+  .txch         = S32K1XX_DMACHAN_LPSPI3_TX,
 #endif
 };
 #endif
@@ -637,8 +666,8 @@ void s32k1xx_lpspi_writebyte(struct s32k1xx_lpspidev_s *priv,
  *
  ****************************************************************************/
 
-static inline uint16_t s32k1xx_lpspi_9to16bitmode(
-    struct s32k1xx_lpspidev_s *priv)
+static inline uint16_t
+  s32k1xx_lpspi_9to16bitmode(struct s32k1xx_lpspidev_s *priv)
 {
   uint16_t ret;
 
@@ -1024,7 +1053,6 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
   struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)dev;
 
   uint32_t men;
-  uint32_t regval;
   uint32_t inclock;
   uint32_t prescaler;
   uint32_t best_prescaler;
@@ -1088,14 +1116,9 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
 
       /* Write the best values in the CCR register */
 
-      regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_CCR_OFFSET);
-      regval &= ~LPSPI_CCR_SCKDIV_MASK;
-      regval |= LPSPI_CCR_SCKDIV(best_scaler);
-      s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_CCR_OFFSET, regval);
-
       s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_TCR_OFFSET,
-                              LPSPI_TCR_PRESCALE_MASK,
-                              LPSPI_TCR_PRESCALE(best_prescaler));
+                                LPSPI_TCR_PRESCALE_MASK,
+                                LPSPI_TCR_PRESCALE(best_prescaler));
 
       priv->frequency = frequency;
       priv->actual = best_frequency;
@@ -1105,7 +1128,11 @@ static uint32_t s32k1xx_lpspi_setfrequency(struct spi_dev_s *dev,
       s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
                                     LPSPI_LAST_SCK_TO_PCS);
       s32k1xx_lpspi_set_delays(priv, 1000000000 / best_frequency,
-                                    LPSPI_BETWEEN_TRANSFER);
+                               LPSPI_BETWEEN_TRANSFER);
+
+      s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_CCR_OFFSET,
+                                LPSPI_CCR_SCKDIV_MASK,
+                                LPSPI_CCR_SCKDIV(best_scaler));
 
       /* Re-enable LPSPI if it was enabled previously */
 
@@ -1453,7 +1480,6 @@ static uint32_t s32k1xx_lpspi_send_dword(struct spi_dev_s *dev,
  *
  ****************************************************************************/
 
-#if !defined(CONFIG_S32K1XX_LPSPI_DMA) || defined(CONFIG_S32K1XX_DMACAPABLE)
 #if !defined(CONFIG_S32K1XX_LPSPI_DMA)
 static void s32k1xx_lpspi_exchange(struct spi_dev_s *dev,
                                    const void *txbuffer,
@@ -1513,8 +1539,18 @@ static void s32k1xx_lpspi_exchange_nodma(struct spi_dev_s *dev,
                    src += 5;
                    dwords = true;
                    break;
+              case 48:
+                   word = __builtin_bswap32(*(uint32_t *)&src[0]);
+                    // &scr[0]);(src[0] << 24) + (src[1] << 16)
+                    //       + (src[2] << 8) + src[3];
+                   word1 = (src[4] << 8) + src[5];
+                   src += 6;
+                   dwords = true;
+                   break;
 #endif
               default:
+              spierr("ERROR: Unsupported SPI framesize: %d\n", framesize);
+              spiinfo("Add framesize to this and below switch to use it. \n");
                       break;
               }
             }
@@ -1551,9 +1587,20 @@ static void s32k1xx_lpspi_exchange_nodma(struct spi_dev_s *dev,
                    dest[4] =  rword1      & 0xff;
                    dest += 5;
                    break;
+              case 48:
+                   dest[0] = (word >> 24) & 0xff;
+                   dest[1] = (word >> 16) & 0xff;
+                   dest[2] = (word >>  8) & 0xff;
+                   dest[3] =  word        & 0xff;
+                   dest[4] = (rword1 >> 8) & 0xff;
+                   dest[5] = (rword1 >> 0) & 0xff;
+                   dest += 6;
+                   break;
 #endif
 
               default:
+              spierr("ERROR: Unsupported SPI framesize: %d\n", framesize);
+              spiinfo("Add framesize to this and below switch to use it. \n");
 
                       break;
             }
@@ -1710,7 +1757,151 @@ static void s32k1xx_lpspi_exchange_nodma(struct spi_dev_s *dev,
         }
     }
 }
-#endif /* !CONFIG_S32K1XX_LPSPI_DMA || CONFIG_S32K1XX_DMACAPABLE */
+
+/****************************************************************************
+ * Name: spi_exchange (with DMA capability)
+ *
+ * Description:
+ *   Exchange a block of data on SPI using DMA
+ *
+ * Input Parameters:
+ *   dev      - Device-specific state data
+ *   txbuffer - A pointer to the buffer of data to be sent
+ *   rxbuffer - A pointer to a buffer in which to receive data
+ *   nwords   - the length of data to be exchanged in units of words.
+ *              The wordsize is determined by the number of bits-per-word
+ *              selected for the SPI interface.  If nbits <= 8, the data is
+ *              packed into uint8_t's; if nbits > 8, the data is packed into
+ *              uint16_t's
+ *
+ * Returned Value:
+ *   None
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void s32k1xx_lpspi_exchange(struct spi_dev_s *dev,
+                                   const void *txbuffer, void *rxbuffer,
+                                   size_t nwords)
+{
+  int                       ret;
+  size_t                    adjust;
+  ssize_t                   nbytes;
+  static uint8_t            rxdummy[4] aligned_data(4);
+  static const uint16_t     txdummy = 0xffff;
+  uint32_t                  regval;
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)dev;
+
+  DEBUGASSERT(priv != NULL);
+  DEBUGASSERT(priv && priv->spibase);
+  spiinfo("txbuffer=%p rxbuffer=%p nwords=%d\n", txbuffer, rxbuffer, nwords);
+
+  /* Convert the number of word to a number of bytes */
+
+  nbytes = (priv->nbits > 8) ? nwords << 2 : nwords;
+
+  /* Invalid DMA channels fall back to non-DMA method. */
+
+  if (priv->rxdma == NULL || priv->txdma == NULL
+#ifdef CONFIG_S32K1XX_LPSPI_DMATHRESHOLD
+      /* If this is a small SPI transfer, then let
+       * s32k1xx_lpspi_exchange_nodma() do the work.
+       */
+
+      || nbytes <= CONFIG_S32K1XX_LPSPI_DMATHRESHOLD
+#endif
+      )
+    {
+      s32k1xx_lpspi_exchange_nodma(dev, txbuffer, rxbuffer, nwords);
+      return;
+    }
+
+  /* ERR050456 workaround: Reset FIFOs using CR[RST] bit */
+
+  regval = s32k1xx_lpspi_getreg32(priv, S32K1XX_LPSPI_CFGR1_OFFSET);
+
+  s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_CR_OFFSET,
+                            LPSPI_CR_RTF | LPSPI_CR_RRF,
+                            LPSPI_CR_RTF | LPSPI_CR_RRF);
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_CFGR1_OFFSET, regval);
+
+  /* Clear all status bits */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_SR_OFFSET, SPI_SR_CLEAR);
+
+  /* disable DMA */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_DER_OFFSET, 0);
+
+  /* Set up the DMA */
+
+  adjust = (priv->nbits > 8) ? 2 : 1;
+
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  config.saddr  = priv->spibase + S32K1XX_LPSPI_RDR_OFFSET;
+  config.daddr  = (uint32_t)(rxbuffer ? rxbuffer : rxdummy);
+  config.soff   = 0;
+  config.doff   = rxbuffer ? adjust : 0;
+  config.iter   = nbytes;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.dsize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.nbytes = adjust;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = NULL;
+#endif
+  s32k1xx_dmach_xfrsetup(priv->rxdma, &config);
+
+  config.saddr  = (uint32_t) (txbuffer ? txbuffer : &txdummy);
+  config.daddr  = priv->spibase + S32K1XX_LPSPI_TDR_OFFSET;
+  config.soff   = txbuffer ? adjust : 0;
+  config.doff   = 0;
+  config.iter   = nbytes;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.dsize  = adjust == 1 ? EDMA_8BIT : EDMA_16BIT;
+  config.nbytes = adjust;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = NULL;
+#endif
+  s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+
+  /* Start the DMAs */
+
+  spi_dmarxstart(priv);
+  spi_dmatxstart(priv);
+
+  /* Invoke SPI DMA */
+
+  s32k1xx_lpspi_modifyreg32(priv, S32K1XX_LPSPI_DER_OFFSET,
+                            0, LPSPI_DER_TDDE | LPSPI_DER_RDDE);
+
+  /* Then wait for each to complete */
+
+  ret = spi_dmatxwait(priv);
+
+  if (ret < 0)
+    {
+      ret = spi_dmarxwait(priv);
+    }
+
+  /* Reset any status */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_SR_OFFSET,
+                         s32k1xx_lpspi_getreg32(priv,
+                                                S32K1XX_LPSPI_SR_OFFSET));
+
+  /* Disable DMA */
+
+  s32k1xx_lpspi_putreg32(priv, S32K1XX_LPSPI_DER_OFFSET, 0);
+
+  up_invalidate_dcache((uintptr_t)rxbuffer,
+                       (uintptr_t)rxbuffer + nbytes);
+}
+
+#endif  /* CONFIG_S32K1XX_SPI_DMA */
 
 /****************************************************************************
  * Name: s32k1xx_lpspi_sndblock
@@ -2017,6 +2208,174 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 }
 #endif
 
+/****************************************************************************
+ * Name: spi_dmarxwait
+ *
+ * Description:
+ *   Wait for DMA to complete.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int spi_dmarxwait(struct s32k1xx_lpspidev_s *priv)
+{
+  int ret;
+
+  /* Take the semaphore (perhaps waiting).  If the result is zero, then the
+   *  DMA must not really have completed.
+   */
+
+  do
+    {
+      ret = nxsem_wait_uninterruptible(&priv->rxsem);
+
+      /* The only expected error is ECANCELED which would occur if the
+       * calling thread were canceled.
+       */
+
+      DEBUGASSERT(ret == OK || ret == -ECANCELED);
+    }
+  while (priv->rxresult == 0 && ret == OK);
+
+  return ret;
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxwait
+ *
+ * Description:
+ *   Wait for DMA to complete.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static int spi_dmatxwait(struct s32k1xx_lpspidev_s *priv)
+{
+  int ret;
+
+  /* Take the semaphore (perhaps waiting).  If the result is zero, then the
+   * DMA must not really have completed.
+   */
+
+  do
+    {
+      ret = nxsem_wait_uninterruptible(&priv->txsem);
+
+      /* The only expected error is ECANCELED which would occur if the
+       * calling thread were canceled.
+       */
+
+      DEBUGASSERT(ret == OK || ret == -ECANCELED);
+    }
+  while (priv->txresult == 0 && ret == OK);
+
+  return ret;
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxwakeup
+ *
+ * Description:
+ *   Signal that DMA is complete
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmarxwakeup(struct s32k1xx_lpspidev_s *priv)
+{
+  nxsem_post(&priv->rxsem);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxwakeup
+ *
+ * Description:
+ *   Signal that DMA is complete
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmatxwakeup(struct s32k1xx_lpspidev_s *priv)
+{
+  nxsem_post(&priv->txsem);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxcallback
+ *
+ * Description:
+ *   Called when the RX DMA completes
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void spi_dmarxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)arg;
+
+  priv->rxresult = result | 0x80000000;  /* assure non-zero */
+  spi_dmarxwakeup(priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxcallback
+ *
+ * Description:
+ *   Called when the RX DMA completes
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static void spi_dmatxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                              int result)
+{
+  struct s32k1xx_lpspidev_s *priv = (struct s32k1xx_lpspidev_s *)arg;
+
+  /* Wake-up the SPI driver */
+
+  priv->txresult = result | 0x80000000;  /* assure non-zero */
+  spi_dmatxwakeup(priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmarxstart
+ *
+ * Description:
+ *   Start RX DMA
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmarxstart(struct s32k1xx_lpspidev_s *priv)
+{
+  priv->rxresult = 0;
+  s32k1xx_dmach_start(priv->rxdma, spi_dmarxcallback, priv);
+}
+#endif
+
+/****************************************************************************
+ * Name: spi_dmatxstart
+ *
+ * Description:
+ *   Start TX DMA
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+static inline void spi_dmatxstart(struct s32k1xx_lpspidev_s *priv)
+{
+  priv->txresult = 0;
+  s32k1xx_dmach_start(priv->txdma, spi_dmatxcallback, priv);
+}
+#endif
+
 /****************************************************************************
  * Name: up_pm_prepare
  *
@@ -2139,7 +2498,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
       count++;
 
-# endif     
+# endif
     }
     break;
 
@@ -2278,7 +2637,7 @@ struct spi_dev_s *s32k1xx_lpspibus_initialize(int bus)
   if (bus == 1)
     {
       #ifdef CONFIG_PM
-        #if defined(CONFIG_PM_SPI_STANDBY) || defined(CONFIG_PM_SPI_SLEEP) 
+        #if defined(CONFIG_PM_SPI_STANDBY) || defined(CONFIG_PM_SPI_SLEEP)
           int ret;
 
           /* Register to receive power management callbacks */
@@ -2339,6 +2698,36 @@ struct spi_dev_s *s32k1xx_lpspibus_initialize(int bus)
       spierr("ERROR: Unsupported SPI bus: %d\n", bus);
     }
 
+#ifdef CONFIG_S32K1XX_LPSPI_DMA
+  /* Initialize the SPI semaphores that is used to wait for DMA completion.
+   * This semaphore is used for signaling and, hence, should not have
+   * priority inheritance enabled.
+   */
+
+  if (priv->rxch && priv->txch)
+    {
+      if (priv->txdma == NULL && priv->rxdma == NULL)
+        {
+          nxsem_init(&priv->rxsem, 0, 0);
+          nxsem_init(&priv->txsem, 0, 0);
+
+          nxsem_set_protocol(&priv->rxsem, SEM_PRIO_NONE);
+          nxsem_set_protocol(&priv->txsem, SEM_PRIO_NONE);
+
+          priv->txdma = s32k1xx_dmach_alloc(priv->txch | DMAMUX_CHCFG_ENBL,
+                                            0);
+          priv->rxdma = s32k1xx_dmach_alloc(priv->rxch | DMAMUX_CHCFG_ENBL,
+                                            0);
+          DEBUGASSERT(priv->rxdma && priv->txdma);
+        }
+    }
+  else
+    {
+      priv->rxdma = NULL;
+      priv->txdma = NULL;
+    }
+#endif
+
   leave_critical_section(flags);
 
   return (struct spi_dev_s *)priv;
diff --git a/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
index 99278d24e5..4aa4ef9d0d 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_pminitialize.c
@@ -25,6 +25,7 @@
 #include <nuttx/config.h>
 #include <nuttx/power/pm.h>
 
+#include "s32k1xx_clockconfig.h"
 #include "arm_internal.h"
 
 #ifdef CONFIG_PM
@@ -56,6 +57,10 @@ void arm_pminitialize(void)
   /* Initialize the NuttX power management subsystem proper */
 
   pm_initialize();
+
+  /* Register clockconfig first to receive power management callbacks */
+
+  s32k1xx_clock_pm_register();
 }
 
 #endif /* CONFIG_PM */
diff --git a/arch/arm/src/s32k1xx/s32k1xx_serial.c b/arch/arm/src/s32k1xx/s32k1xx_serial.c
index e113182b28..35e5bedb47 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_serial.c
+++ b/arch/arm/src/s32k1xx/s32k1xx_serial.c
@@ -50,10 +50,13 @@
 #include "chip.h"
 #include "arm_internal.h"
 #include "hardware/s32k1xx_lpuart.h"
+#include "s32k1xx_edma.h"
+#include "hardware/s32k1xx_dmamux.h"
 #include "hardware/s32k1xx_pinmux.h"
 #include "s32k1xx_config.h"
 #include "s32k1xx_pin.h"
 #include "s32k1xx_lowputc.h"
+#include "s32k1xx_serial.h"
 
 #include "s32k1xx_periphclocks.h"
 
@@ -71,27 +74,45 @@
 /* First pick the console and ttys0.  This could be any of LPUART0-2 */
 
 #if defined(CONFIG_LPUART0_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart0port /* LPUART0 is console */
-#  define TTYS0_DEV           g_uart0port /* LPUART0 is ttyS0 */
+#  define CONSOLE_DEV         g_lpuart0priv /* LPUART0 is console */
+#  define TTYS0_DEV           g_lpuart0priv /* LPUART0 is ttyS0 */
 #  define UART1_ASSIGNED      1
+#  if defined(CONFIG_LPUART0_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART0_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #elif defined(CONFIG_LPUART1_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart1port /* LPUART1 is console */
-#  define TTYS0_DEV           g_uart1port /* LPUART1 is ttyS0 */
+#  define CONSOLE_DEV         g_lpuart1priv /* LPUART1 is console */
+#  define TTYS0_DEV           g_lpuart1priv /* LPUART1 is ttyS0 */
 #  define UART2_ASSIGNED      1
+#  if defined(CONFIG_LPUART1_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART1_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #elif defined(CONFIG_LPUART2_SERIAL_CONSOLE)
-#  define CONSOLE_DEV         g_uart2port /* LPUART2 is console */
-#  define TTYS0_DEV           g_uart2port /* LPUART2 is ttyS0 */
-#  define UART3_ASSIGNED      1
+#  define CONSOLE_DEV         g_lpuart2priv /* LPUART2 is console */
+#  define TTYS0_DEV           g_lpuart2priv /* LPUART2 is ttyS0 */
+#  define UART2_ASSIGNED      1
+#  if defined(CONFIG_LPUART2_RXDMA)
+#    define SERIAL_HAVE_CONSOLE_RXDMA 1
+#  endif
+#  if defined(CONFIG_LPUART2_TXDMA)
+#    define SERIAL_HAVE_CONSOLE_TXDMA 1
+#  endif
 #else
 #  undef CONSOLE_DEV                      /* No console */
 #  if defined(CONFIG_S32K1XX_LPUART0)
-#    define TTYS0_DEV         g_uart0port /* LPUART0 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart0priv /* LPUART0 is ttyS0 */
 #    define UART1_ASSIGNED    1
 #  elif defined(CONFIG_S32K1XX_LPUART1)
-#    define TTYS0_DEV         g_uart1port /* LPUART1 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart1priv /* LPUART1 is ttyS0 */
 #    define UART2_ASSIGNED    1
 #  elif defined(CONFIG_S32K1XX_LPUART2)
-#    define TTYS0_DEV         g_uart2port /* LPUART2 is ttyS0 */
+#    define TTYS0_DEV         g_lpuart2priv /* LPUART2 is ttyS0 */
 #    define UART3_ASSIGNED    1
 #  endif
 #endif
@@ -102,26 +123,30 @@
  */
 
 #if defined(CONFIG_S32K1XX_LPUART0) && !defined(UART1_ASSIGNED)
-#  define TTYS1_DEV           g_uart0port /* LPUART0 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart0priv /* LPUART0 is ttyS1 */
 #  define UART1_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART1) && !defined(UART2_ASSIGNED)
-#  define TTYS1_DEV           g_uart1port /* LPUART1 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart1priv /* LPUART1 is ttyS1 */
 #  define UART2_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART2) && !defined(UART3_ASSIGNED)
-#  define TTYS1_DEV           g_uart2port /* LPUART2 is ttyS1 */
+#  define TTYS1_DEV           g_lpuart2priv /* LPUART2 is ttyS1 */
 #  define UART3_ASSIGNED      1
 #endif
 
+#if defined(SERIAL_HAVE_CONSOLE_RXDMA) || defined(SERIAL_HAVE_CONSOLE_TXDMA)
+#  define SERIAL_HAVE_CONSOLE_DMA
+#endif
+
 /* Pick ttys2.  This could be one of LPUART0-2. It can't be LPUART0 because
  * that was either assigned as ttyS0 or ttys1.  One of LPUART0-2 could be the
  * console.  One of UART1-2 has already been assigned to ttys0 or ttyS1.
  */
 
 #if defined(CONFIG_S32K1XX_LPUART1) && !defined(UART2_ASSIGNED)
-#  define TTYS2_DEV           g_uart1port /* LPUART1 is ttyS2 */
+#  define TTYS2_DEV           g_lpuart1priv /* LPUART1 is ttyS2 */
 #  define UART2_ASSIGNED      1
 #elif defined(CONFIG_S32K1XX_LPUART2) && !defined(UART3_ASSIGNED)
-#  define TTYS2_DEV           g_uart2port /* LPUART2 is ttyS2 */
+#  define TTYS2_DEV           g_lpuart2priv /* LPUART2 is ttyS2 */
 #  define UART3_ASSIGNED      1
 #endif
 
@@ -140,12 +165,20 @@
 #if defined(CONFIG_PM_SERIAL2_STANDBY) || defined(CONFIG_PM_SERIAL2_SLEEP)
 #   define CONFIG_PM_SERIAL2
 #endif
+
+#if !defined(CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE)
+#  define CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE 32
+#endif
+
+#define RXDMA_BUFFER_SIZE   CONFIG_S32K1XX_SERIAL_RXDMA_BUFFER_SIZE
+
 /****************************************************************************
  * Private Types
  ****************************************************************************/
 
 struct s32k1xx_uart_s
 {
+  struct uart_dev_s dev;    /* Generic UART device */
   uint32_t uartbase;        /* Base address of UART registers */
   uint32_t baud;            /* Configured baud */
   uint32_t ie;              /* Saved enabled interrupts */
@@ -169,6 +202,23 @@ struct s32k1xx_uart_s
 #endif
 #ifdef CONFIG_SERIAL_RS485CONTROL
   uint8_t rs485mode:1;      /* We are in RS485 (RTS on TX) mode */
+#endif
+  /* TX DMA state */
+
+#ifdef SERIAL_HAVE_TXDMA
+  const unsigned int dma_txreqsrc;  /* DMAMUX source of TX DMA request */
+  DMACH_HANDLE       txdma;         /* currently-open trasnmit DMA stream */
+  sem_t              txdmasem;      /* Indicate TX DMA completion */
+#endif
+
+  /* RX DMA state */
+
+#ifdef SERIAL_HAVE_RXDMA
+  const unsigned int dma_rxreqsrc;  /* DMAMUX source of RX DMA request */
+  DMACH_HANDLE       rxdma;         /* currently-open receive DMA stream */
+  bool               rxenable;      /* DMA-based reception en/disable */
+  uint32_t           rxdmanext;     /* Next byte in the DMA buffer to be read */
+  char *const        rxfifo;        /* Receive DMA buffer */
 #endif
 };
 
@@ -191,12 +241,46 @@ static int  s32k1xx_attach(struct uart_dev_s *dev);
 static void s32k1xx_detach(struct uart_dev_s *dev);
 static int  s32k1xx_interrupt(int irq, void *context, void *arg);
 static int  s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg);
+#if !defined(SERIAL_HAVE_ONLY_RXDMA)
 static int  s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status);
 static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable);
 static bool s32k1xx_rxavailable(struct uart_dev_s *dev);
-static void s32k1xx_send(struct uart_dev_s *dev, int ch);
+#endif
+#if !defined(SERIAL_HAVE_ONLY_TXDMA)
 static void s32k1xx_txint(struct uart_dev_s *dev, bool enable);
+#endif
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+static bool s32k1xx_rxflowcontrol(struct uart_dev_s *dev,
+                                  unsigned int nbuffered, bool upper);
+#endif
+static void s32k1xx_send(struct uart_dev_s *dev, int ch);
 static bool s32k1xx_txready(struct uart_dev_s *dev);
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_send(struct uart_dev_s *dev);
+static void s32k1xx_dma_txint(struct uart_dev_s *dev, bool enable);
+static void s32k1xx_dma_txavailable(struct uart_dev_s *dev);
+static void s32k1xx_dma_txcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result);
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static int  s32k1xx_dma_setup(struct uart_dev_s *dev);
+static void s32k1xx_dma_shutdown(struct uart_dev_s *dev);
+#endif
+
+#ifdef SERIAL_HAVE_RXDMA
+static int  s32k1xx_dma_receive(struct uart_dev_s *dev,
+                                unsigned int *status);
+#ifdef CONFIG_PM
+static void s32k1xx_dma_reenable(struct s32k1xx_uart_s *priv);
+#endif
+static void s32k1xx_dma_rxint(struct uart_dev_s *dev, bool enable);
+static bool s32k1xx_dma_rxavailable(struct uart_dev_s *dev);
+
+static void s32k1xx_dma_rxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result);
+#endif
+
 static bool s32k1xx_txempty(struct uart_dev_s *dev);
 
 #ifdef CONFIG_PM
@@ -212,7 +296,8 @@ static int  up_pm_prepare(struct pm_callback_s *cb, int domain,
 
 /* Serial driver UART operations */
 
-static const struct uart_ops_s g_uart_ops =
+#if !defined(SERIAL_HAVE_ONLY_TXDMA) && !defined(SERIAL_HAVE_ONLY_RXDMA)
+static const struct uart_ops_s g_lpuart_ops =
 {
   .setup          = s32k1xx_setup,
   .shutdown       = s32k1xx_shutdown,
@@ -223,174 +308,307 @@ static const struct uart_ops_s g_uart_ops =
   .rxint          = s32k1xx_rxint,
   .rxavailable    = s32k1xx_rxavailable,
 #ifdef CONFIG_SERIAL_IFLOWCONTROL
-  .rxflowcontrol  = NULL,
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
 #endif
   .send           = s32k1xx_send,
   .txint          = s32k1xx_txint,
   .txready        = s32k1xx_txready,
   .txempty        = s32k1xx_txempty,
 };
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA) && defined(SERIAL_HAVE_TXDMA)
+static const struct uart_ops_s g_lpuart_rxtxdma_ops =
+{
+  .setup          = s32k1xx_dma_setup,
+  .shutdown       = s32k1xx_dma_shutdown,
+  .attach         = s32k1xx_attach,
+  .detach         = s32k1xx_detach,
+  .ioctl          = s32k1xx_ioctl,
+  .receive        = s32k1xx_dma_receive,
+  .rxint          = s32k1xx_dma_rxint,
+  .rxavailable    = s32k1xx_dma_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+  .send           = s32k1xx_send,
+  .txint          = s32k1xx_dma_txint,
+  .txready        = s32k1xx_txready,
+  .txempty        = s32k1xx_txempty,
+  .dmatxavail     = s32k1xx_dma_txavailable,
+  .dmasend        = s32k1xx_dma_send,
+};
+#endif
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_RXDMA)
+static const struct uart_ops_s g_lpuart_rxdma_ops =
+{
+  .setup          = s32k1xx_dma_setup,
+  .shutdown       = s32k1xx_dma_shutdown,
+  .attach         = s32k1xx_attach,
+  .detach         = s32k1xx_detach,
+  .ioctl          = s32k1xx_ioctl,
+  .receive        = s32k1xx_dma_receive,
+  .rxint          = s32k1xx_dma_rxint,
+  .rxavailable    = s32k1xx_dma_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+  .send           = s32k1xx_send,
+  .txint          = s32k1xx_txint,
+  .txready        = s32k1xx_txready,
+  .txempty        = s32k1xx_txempty,
+};
+#endif
+
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_TXDMA)
+static const struct uart_ops_s g_lpuart_txdma_ops =
+{
+    .setup          = s32k1xx_dma_setup,
+    .shutdown       = s32k1xx_dma_shutdown,
+    .attach         = s32k1xx_attach,
+    .detach         = s32k1xx_detach,
+    .ioctl          = s32k1xx_ioctl,
+    .receive        = s32k1xx_receive,
+    .rxint          = s32k1xx_rxint,
+    .rxavailable    = s32k1xx_rxavailable,
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+  .rxflowcontrol  = s32k1xx_rxflowcontrol,
+#endif
+    .send           = s32k1xx_send,
+    .txint          = s32k1xx_dma_txint,
+    .txready        = s32k1xx_txready,
+    .txempty        = s32k1xx_txempty,
+    .dmatxavail     = s32k1xx_dma_txavailable,
+    .dmasend        = s32k1xx_dma_send,
+};
+#endif
+
+/* Avoid unused warning */
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_RXDMA)
+const struct uart_ops_s *g_o0 = &g_lpuart_rxdma_ops;
+#endif
+#if !defined(SERIAL_HAVE_ONLY_DMA) && defined(SERIAL_HAVE_TXDMA)
+const struct uart_ops_s *g_o1 = &g_lpuart_txdma_ops;
+#endif
+
+/* I/O buffers */
+
+#ifdef CONFIG_LPUART0_RXDMA
+static char g_lpuart0rxfifo[RXDMA_BUFFER_SIZE];
+#endif
+
+# ifdef CONFIG_LPUART1_RXDMA
+static char g_lpuart1rxfifo[RXDMA_BUFFER_SIZE];
+#endif
+
+#ifdef CONFIG_LPUART2_RXDMA
+static char g_lpuart2rxfifo[RXDMA_BUFFER_SIZE];
+#endif
 
 /* I/O buffers */
 
 #ifdef CONFIG_S32K1XX_LPUART0
-static char g_uart0rxbuffer[CONFIG_LPUART0_RXBUFSIZE];
-static char g_uart0txbuffer[CONFIG_LPUART0_TXBUFSIZE];
+static char g_lpuart0rxbuffer[CONFIG_LPUART0_RXBUFSIZE];
+static char g_lpuart0txbuffer[CONFIG_LPUART0_TXBUFSIZE];
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART1
-static char g_uart1rxbuffer[CONFIG_LPUART1_RXBUFSIZE];
-static char g_uart1txbuffer[CONFIG_LPUART1_TXBUFSIZE];
+static char g_lpuart1rxbuffer[CONFIG_LPUART1_RXBUFSIZE];
+static char g_lpuart1txbuffer[CONFIG_LPUART1_TXBUFSIZE];
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART2
-static char g_uart2rxbuffer[CONFIG_LPUART2_RXBUFSIZE];
-static char g_uart2txbuffer[CONFIG_LPUART2_TXBUFSIZE];
+static char g_lpuart2rxbuffer[CONFIG_LPUART2_RXBUFSIZE];
+static char g_lpuart2txbuffer[CONFIG_LPUART2_TXBUFSIZE];
 #endif
 
 /* This describes the state of the S32K1XX lpuart0 port. */
 
 #ifdef CONFIG_S32K1XX_LPUART0
-static struct s32k1xx_uart_s g_uart0priv =
+static struct s32k1xx_uart_s g_lpuart0priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART0_RXBUFSIZE,
+        .buffer     = g_lpuart0rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART0_TXBUFSIZE,
+        .buffer     = g_lpuart0txbuffer,
+      },
+#  if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxtxdma_ops,
+#  elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxdma_ops,
+#  elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_txdma_ops,
+#  else
+        .ops       = &g_lpuart_ops,
+#  endif
+        .priv         = &g_lpuart0priv,
+      },
   .uartbase     = S32K1XX_LPUART0_BASE,
   .baud         = CONFIG_LPUART0_BAUD,
   .irq          = S32K1XX_IRQ_LPUART0,
   .parity       = CONFIG_LPUART0_PARITY,
   .bits         = CONFIG_LPUART0_BITS,
   .stopbits2    = CONFIG_LPUART0_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART0_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART0_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART0_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART0_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART0_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART0_RTS,
-#endif
+  .rts_gpio     = PIN_LPUART0_RTS,
+#  endif
 
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART0_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART0_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart0port =
-{
-  .recv         =
-  {
-    .size       = CONFIG_LPUART0_RXBUFSIZE,
-    .buffer     = g_uart0rxbuffer,
-  },
-  .xmit         =
-  {
-    .size       = CONFIG_LPUART0_TXBUFSIZE,
-    .buffer     = g_uart0txbuffer,
-  },
-  .ops          = &g_uart_ops,
-  .priv         = &g_uart0priv,
+#  endif
+#  ifdef CONFIG_LPUART0_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART0_TX,
+#  endif
+#  ifdef CONFIG_LPUART0_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART0_RX,
+  .rxfifo        = g_lpuart0rxfifo,
+#  endif
 };
 #endif
 
 /* This describes the state of the S32K1XX lpuart1 port. */
 
 #ifdef CONFIG_S32K1XX_LPUART1
-static struct s32k1xx_uart_s g_uart1priv =
+static struct s32k1xx_uart_s g_lpuart1priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART1_RXBUFSIZE,
+        .buffer     = g_lpuart1rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART1_TXBUFSIZE,
+        .buffer     = g_lpuart1txbuffer,
+      },
+#    if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_rxtxdma_ops,
+#    elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_rxdma_ops,
+#    elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+          .ops       = &g_lpuart_txdma_ops,
+#    else
+          .ops       = &g_lpuart_ops,
+#    endif
+          .priv           = &g_lpuart1priv,
+  },
+
   .uartbase     = S32K1XX_LPUART1_BASE,
   .baud         = CONFIG_LPUART1_BAUD,
   .irq          = S32K1XX_IRQ_LPUART1,
   .parity       = CONFIG_LPUART1_PARITY,
   .bits         = CONFIG_LPUART1_BITS,
   .stopbits2    = CONFIG_LPUART1_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART1_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART1_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART1_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART1_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART1_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART1_RTS,
-#endif
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+  .rts_gpio     = PIN_LPUART1_RTS,
+#  endif
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART1_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART1_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart1port =
-{
-  .recv           =
-    {
-      .size       = CONFIG_LPUART1_RXBUFSIZE,
-      .buffer     = g_uart1rxbuffer,
-    },
-  .xmit           =
-    {
-      .size       = CONFIG_LPUART1_TXBUFSIZE,
-      .buffer     = g_uart1txbuffer,
-    },
-  .ops            = &g_uart_ops,
-  .priv           = &g_uart1priv,
+#  endif
+#  ifdef CONFIG_LPUART1_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART1_TX,
+#  endif
+#  ifdef CONFIG_LPUART1_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART1_RX,
+  .rxfifo        = g_lpuart1rxfifo,
+#  endif
 };
 #endif
 
 #ifdef CONFIG_S32K1XX_LPUART2
-static struct s32k1xx_uart_s g_uart2priv =
+static struct s32k1xx_uart_s g_lpuart2priv =
 {
+  .dev =
+    {
+      .recv         =
+      {
+        .size       = CONFIG_LPUART2_RXBUFSIZE,
+        .buffer     = g_lpuart2rxbuffer,
+      },
+      .xmit         =
+      {
+        .size       = CONFIG_LPUART2_TXBUFSIZE,
+        .buffer     = g_lpuart2txbuffer,
+      },
+#  if defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxtxdma_ops,
+#  elif defined(CONFIG_LPUART1_RXDMA) && !defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_rxdma_ops,
+#  elif !defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_TXDMA)
+        .ops       = &g_lpuart_txdma_ops,
+#  else
+        .ops       = &g_lpuart_ops,
+#  endif
+        .priv           = &g_lpuart2priv,
+  },
+
   .uartbase     = S32K1XX_LPUART2_BASE,
   .baud         = CONFIG_LPUART2_BAUD,
   .irq          = S32K1XX_IRQ_LPUART2,
   .parity       = CONFIG_LPUART2_PARITY,
   .bits         = CONFIG_LPUART2_BITS,
   .stopbits2    = CONFIG_LPUART2_2STOP,
-#if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART2_OFLOWCONTROL)
+#  if defined(CONFIG_SERIAL_OFLOWCONTROL) && defined(CONFIG_LPUART2_OFLOWCONTROL)
   .oflow        = 1,
-  .cts_gpio     = GPIO_LPUART2_CTS,
-#endif
-#if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)
+  .cts_gpio     = PIN_LPUART2_CTS,
+#  endif
+#  if defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)
   .iflow        = 1,
-#endif
-# if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)) \
+#  endif
+#  if ((defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)) \
    || (defined(CONFIG_SERIAL_IFLOWCONTROL) && defined(CONFIG_LPUART2_IFLOWCONTROL)))
-  .rts_gpio     = GPIO_LPUART2_RTS,
-#endif
-#if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
+  .rts_gpio     = PIN_LPUART2_RTS,
+#  endif
+#  if (((defined(CONFIG_SERIAL_RS485CONTROL) || defined(CONFIG_SERIAL_IFLOWCONTROL))) \
     && defined(CONFIG_LPUART2_INVERTIFLOWCONTROL))
   .inviflow     = 1,
-#endif
+#  endif
 
-#if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)
+#  if defined(CONFIG_SERIAL_RS485CONTROL) && defined(CONFIG_LPUART2_RS485RTSCONTROL)
   .rs485mode    = 1,
-#endif
-};
-
-static struct uart_dev_s g_uart2port =
-{
-  .recv           =
-    {
-      .size       = CONFIG_LPUART2_RXBUFSIZE,
-      .buffer     = g_uart2rxbuffer,
-    },
-  .xmit           =
-    {
-      .size       = CONFIG_LPUART2_TXBUFSIZE,
-      .buffer     = g_uart2txbuffer,
-    },
-  .ops            = &g_uart_ops,
-  .priv           = &g_uart2priv,
+#  endif
+#  ifdef CONFIG_LPUART2_TXDMA
+  .dma_txreqsrc = S32K1XX_DMACHAN_LPUART2_TX,
+#  endif
+#  ifdef CONFIG_LPUART2_RXDMA
+  .dma_rxreqsrc = S32K1XX_DMACHAN_LPUART2_RX,
+  .rxfifo        = g_lpuart2rxfifo,
+# endif
 };
 #endif
 
@@ -426,6 +644,24 @@ static inline void s32k1xx_serialout(struct s32k1xx_uart_s *priv,
   putreg32(value, priv->uartbase + offset);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_nextrx
+ *
+ * Description:
+ *   Returns the index into the RX FIFO where the DMA will place the next
+ *   byte that it receives.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static int s32k1xx_dma_nextrx(struct s32k1xx_uart_s *priv)
+{
+  int dmaresidual = s32k1xx_dmach_getcount(priv->rxdma);
+
+  return RXDMA_BUFFER_SIZE - dmaresidual;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_disableuartint
  ****************************************************************************/
@@ -473,6 +709,132 @@ static inline void s32k1xx_restoreuartint(struct s32k1xx_uart_s *priv,
   spin_unlock_irqrestore(NULL, flags);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_setup
+ *
+ * Description:
+ *   Configure the LPUART baud, bits, parity, etc. This method is called the
+ *   first time that the serial port is opened.
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static int s32k1xx_dma_setup(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+#if defined(SERIAL_HAVE_RXDMA)
+  struct s32k1xx_edma_xfrconfig_s config;
+#endif
+  int result;
+
+  /* Do the basic UART setup first, unless we are the console */
+
+  if (!dev->isconsole)
+    {
+      result = s32k1xx_setup(dev);
+      if (result != OK)
+        {
+          return result;
+        }
+    }
+
+#if defined(SERIAL_HAVE_TXDMA)
+  /* Acquire the Tx DMA channel.  This should always succeed. */
+
+  if (priv->dma_txreqsrc != 0)
+    {
+      if (priv->txdma == NULL)
+        {
+          priv->txdma = s32k1xx_dmach_alloc(priv->dma_txreqsrc |
+                                            DMAMUX_CHCFG_ENBL, 0);
+          if (priv->txdma == NULL)
+            {
+              return -EBUSY;
+            }
+
+          nxsem_init(&priv->txdmasem, 0, 1);
+          nxsem_set_protocol(&priv->txdmasem, SEM_PRIO_NONE);
+        }
+
+      /* Enable Tx DMA for the UART */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_BAUD_OFFSET,
+                  0, LPUART_BAUD_TDMAE);
+    }
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA)
+  /* Acquire the Rx DMA channel.  This should always succeed. */
+
+  if (priv->dma_rxreqsrc != 0)
+    {
+      if (priv->rxdma == NULL)
+        {
+          priv->rxdma = s32k1xx_dmach_alloc(priv->dma_rxreqsrc |
+                                            DMAMUX_CHCFG_ENBL, 0);
+
+          if (priv->rxdma == NULL)
+            {
+              return -EBUSY;
+            }
+        }
+      else
+        {
+          s32k1xx_dmach_stop(priv->rxdma);
+        }
+
+      /* Configure for circular DMA reception into the RX FIFO */
+
+      config.saddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+      config.daddr  = (uint32_t)priv->rxfifo;
+      config.soff   = 0;
+      config.doff   = 1;
+      config.iter   = RXDMA_BUFFER_SIZE;
+      config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE |
+                      EDMA_CONFIG_LOOPDEST |
+                      EDMA_CONFIG_INTHALF  |
+                      EDMA_CONFIG_INTMAJOR;
+      config.ssize  = EDMA_8BIT;
+      config.dsize  = EDMA_8BIT;
+      config.nbytes = 1;
+    #ifdef CONFIG_KINETIS_EDMA_ELINK
+      config.linkch = 0;
+    #endif
+
+      s32k1xx_dmach_xfrsetup(priv->rxdma , &config);
+
+      /* Reset our DMA shadow pointer and Rx data availability count to
+       * match the address just programmed above.
+       */
+
+      priv->rxdmanext = 0;
+
+      /* Enable receive Rx DMA for the UART */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_BAUD_OFFSET,
+                  0, LPUART_BAUD_RDMAE);
+
+      /* Enable itnerrupt on Idel and erros */
+
+      modifyreg32(priv->uartbase + S32K1XX_LPUART_CTRL_OFFSET, 0,
+                  LPUART_CTRL_PEIE |
+                  LPUART_CTRL_FEIE |
+                  LPUART_CTRL_NEIE |
+                  LPUART_CTRL_ILIE);
+
+      /* Start the DMA channel, and arrange for callbacks at the half and
+       * full points in the FIFO.  This ensures that we have half a FIFO
+       * worth of time to claim bytes before they are overwritten.
+       */
+
+      s32k1xx_dmach_start(priv->rxdma, s32k1xx_dma_rxcallback, (void *)priv);
+    }
+#endif
+
+  return OK;
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_setup
  *
@@ -504,7 +866,13 @@ static int s32k1xx_setup(struct uart_dev_s *dev)
   config.usects     = priv->iflow;      /* Flow control on inbound side */
 #endif
 #ifdef CONFIG_SERIAL_OFLOWCONTROL
-  config.userts     = priv->oflow;      /* Flow control on outbound side */
+  /* Flow control on outbound side if not GPIO based */
+
+  if ((priv->rts_gpio & _PIN_MODE_MASK) != _PIN_MODE_GPIO)
+    {
+      config.userts = priv->oflow;
+    }
+
 #endif
 #ifdef CONFIG_SERIAL_RS485CONTROL
   config.users485   = priv->rs485mode;  /* Switch into RS485 mode */
@@ -556,6 +924,55 @@ static void s32k1xx_shutdown(struct uart_dev_s *dev)
   s32k1xx_serialout(priv, S32K1XX_LPUART_GLOBAL_OFFSET, 0);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_shutdown
+ *
+ * Description:
+ *   Disable the LPUART.  This method is called when the serial
+ *   port is closed
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) || defined(SERIAL_HAVE_TXDMA)
+static void s32k1xx_dma_shutdown(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Perform the normal UART shutdown */
+
+  s32k1xx_shutdown(dev);
+
+#if defined(SERIAL_HAVE_RXDMA)
+  /* Stop the RX DMA channel */
+
+  if (priv->dma_rxreqsrc != 0)
+    {
+      s32k1xx_dmach_stop(priv->rxdma);
+
+      /* Release the RX DMA channel */
+
+      s32k1xx_dmach_free(priv->rxdma);
+      priv->rxdma = NULL;
+    }
+#endif
+
+#if defined(SERIAL_HAVE_TXDMA)
+  /* Stop the TX DMA channel */
+
+  if (priv->dma_txreqsrc != 0)
+    {
+      s32k1xx_dmach_stop(priv->txdma);
+
+      /* Release the TX DMA channel */
+
+      s32k1xx_dmach_free(priv->txdma);
+      priv->txdma = NULL;
+      nxsem_destroy(&priv->txdmasem);
+    }
+#endif
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_attach
  *
@@ -651,10 +1068,11 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
        */
 
       usr  = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
-      usr &= (LPUART_STAT_RDRF | LPUART_STAT_TC | LPUART_STAT_OR |
-              LPUART_STAT_FE);
+      usr &= (LPUART_STAT_RDRF | LPUART_STAT_TDRE | LPUART_STAT_OR |
+              LPUART_STAT_FE | LPUART_STAT_NF | LPUART_STAT_PF |
+              LPUART_STAT_IDLE);
 
-      /* Clear serial overrun and framing errors */
+      /* Clear serial overrun, parity and framing errors */
 
       if ((usr & LPUART_STAT_OR) != 0)
         {
@@ -662,12 +1080,42 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
                             LPUART_STAT_OR);
         }
 
+      if ((usr & LPUART_STAT_NF) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_NF);
+        }
+
+      if ((usr & LPUART_STAT_PF) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_PF);
+        }
+
       if ((usr & LPUART_STAT_FE) != 0)
         {
           s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
                             LPUART_STAT_FE);
         }
 
+      if ((usr & (LPUART_STAT_FE | LPUART_STAT_PF | LPUART_STAT_NF)) != 0)
+        {
+          /* Discard data */
+
+          s32k1xx_serialin(priv, S32K1XX_LPUART_DATA_OFFSET);
+        }
+
+#ifdef SERIAL_HAVE_RXDMA
+      /* The line going to idle, deliver any fractions of RX data */
+
+      if ((usr & LPUART_STAT_IDLE) != 0)
+        {
+          s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                            LPUART_STAT_IDLE);
+          s32k1xx_dma_rxcallback(priv->rxdma, priv, false, LPUART_STAT_IDLE);
+        }
+#endif
+
       /* Handle incoming, receive bytes */
 
       if ((usr & LPUART_STAT_RDRF) != 0 &&
@@ -679,8 +1127,8 @@ static int s32k1xx_interrupt(int irq, void *context, void *arg)
 
       /* Handle outgoing, transmit bytes */
 
-      if ((usr & LPUART_STAT_TC) != 0 &&
-          (priv->ie & LPUART_CTRL_TCIE) != 0)
+      if ((usr & LPUART_STAT_TDRE) != 0 &&
+          (priv->ie & LPUART_CTRL_TIE) != 0)
         {
           uart_xmitchars(dev);
           handled = true;
@@ -702,7 +1150,8 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
 {
 #if defined(CONFIG_SERIAL_TIOCSERGSTRUCT) || defined(CONFIG_SERIAL_TERMIOS)
   struct inode *inode = filep->f_inode;
-  struct uart_dev_s *dev   = inode->i_private;
+  struct uart_dev_s *dev = inode->i_private;
+  irqstate_t flags;
 #endif
   int ret   = OK;
 
@@ -877,13 +1326,15 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
              * implement TCSADRAIN / TCSAFLUSH
              */
 
+            flags = spin_lock_irqsave(NULL);
             s32k1xx_disableuartint(priv, &ie);
-            ret = s32k1xx_setup(dev);
+            ret = dev->ops->setup(dev);
 
             /* Restore the interrupt state */
 
             s32k1xx_restoreuartint(priv, ie);
             priv->ie = ie;
+            spin_unlock_irqrestore(NULL, flags);
           }
       }
       break;
@@ -959,6 +1410,7 @@ static int s32k1xx_ioctl(struct file *filep, int cmd, unsigned long arg)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -968,6 +1420,7 @@ static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
   *status = rxd >> LPUART_DATA_STATUS_SHIFT;
   return (rxd & LPUART_DATA_MASK) >> LPUART_DATA_SHIFT;
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_rxint
@@ -977,6 +1430,7 @@ static int s32k1xx_receive(struct uart_dev_s *dev, unsigned int *status)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1003,6 +1457,7 @@ static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
   s32k1xx_serialout(priv, S32K1XX_LPUART_CTRL_OFFSET, regval);
   spin_unlock_irqrestore(NULL, flags);
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_rxavailable
@@ -1012,6 +1467,7 @@ static void s32k1xx_rxint(struct uart_dev_s *dev, bool enable)
  *
  ****************************************************************************/
 
+#ifndef SERIAL_HAVE_ONLY_RXDMA
 static bool s32k1xx_rxavailable(struct uart_dev_s *dev)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1022,6 +1478,359 @@ static bool s32k1xx_rxavailable(struct uart_dev_s *dev)
   regval = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
   return ((regval & LPUART_STAT_RDRF) != 0);
 }
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_rxflowcontrol
+ *
+ * Description:
+ *   Called when Rx buffer is full (or exceeds configured watermark levels
+ *   if CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS is defined).
+ *   Return true if UART activated RX flow control to block more incoming
+ *   data
+ *
+ * Input Parameters:
+ *   dev       - UART device instance
+ *   nbuffered - the number of characters currently buffered
+ *               (if CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS is
+ *               not defined the value will be 0 for an empty buffer or the
+ *               defined buffer size for a full buffer)
+ *   upper     - true indicates the upper watermark was crossed where
+ *               false indicates the lower watermark has been crossed
+ *
+ * Returned Value:
+ *   true if RX flow control activated.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_SERIAL_IFLOWCONTROL
+static bool s32k1xx_rxflowcontrol(struct uart_dev_s *dev,
+                                  unsigned int nbuffered, bool upper)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  bool use_swhs = false;
+
+#if defined(CONFIG_SERIAL_IFLOWCONTROL_WATERMARKS)
+  use_swhs = (priv->rts_gpio & _PIN_MODE_MASK) == _PIN_MODE_GPIO;
+#endif
+
+  if (use_swhs && priv->iflow && (priv->rts_gpio != 0))
+    {
+      /* Assert/de-assert nRTS set it high resume/stop sending */
+
+      s32k1xx_gpiowrite(priv->rts_gpio, upper);
+
+      if (upper)
+        {
+          /* With heavy Rx traffic, RXNE might be set and data pending.
+           * Returning 'true' in such case would cause RXNE left unhandled
+           * and causing interrupt storm. Sending end might be also be slow
+           * to react on nRTS, and returning 'true' here would prevent
+           * processing that data.
+           *
+           * Therefore, return 'false' so input data is still being processed
+           * until sending end reacts on nRTS signal and stops sending more.
+           */
+
+          return false;
+        }
+
+      return upper;
+    }
+  else
+    {
+      /* Is the RX buffer full? */
+
+      if (upper)
+        {
+          /* Disable Rx interrupt to prevent more data being from
+           * peripheral.  When hardware RTS is enabled, this will
+           * prevent more data from coming in.
+           *
+           * This function is only called when UART recv buffer is full,
+           * that is: "dev->recv.head + 1 == dev->recv.tail".
+           *
+           * Logic in "uart_read" will automatically toggle Rx interrupts
+           * when buffer is read empty and thus we do not have to re-
+           * enable Rx interrupts.
+           */
+
+          uart_disablerxint(dev);
+          return true;
+        }
+
+      /* No.. The RX buffer is empty */
+
+      else
+        {
+          /* We might leave Rx interrupt disabled if full recv buffer was
+           * read empty.  Enable Rx interrupt to make sure that more input is
+           * received.
+           */
+
+          uart_enablerxint(dev);
+        }
+    }
+
+  return false;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_receive
+ *
+ * Description:
+ *   Called (usually) from the interrupt level to receive one
+ *   character from the LPUART.  Error bits associated with the
+ *   receipt are provided in the return 'status'.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static int s32k1xx_dma_receive(struct uart_dev_s *dev, unsigned int *status)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  uint32_t nextrx = s32k1xx_dma_nextrx(priv);
+  int c = 0;
+
+  /* Check if more data is available */
+
+  if (nextrx != priv->rxdmanext)
+    {
+      /* Now read from the DMA buffer */
+
+      c = priv->rxfifo[priv->rxdmanext];
+
+      priv->rxdmanext++;
+
+      if (priv->rxdmanext == RXDMA_BUFFER_SIZE)
+        {
+          priv->rxdmanext = 0;
+        }
+    }
+
+  /* NOTE:  If no data is available, then we would return NULL which is,
+   * of course, valid binary data.  The protocol is that the upper half
+   * driver must call s32k1xx_dma_rxavailable prior to calling this
+   * function to assure that this never happens.
+   */
+
+  return c;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_reenable
+ *
+ * Description:
+ *   Call to re-enable RX DMA.
+ *
+ ****************************************************************************/
+
+#if defined(SERIAL_HAVE_RXDMA) && defined(CONFIG_PM)
+static void s32k1xx_dma_reenable(struct s32k1xx_uart_s *priv)
+{
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  /* Stop an reset the RX DMA */
+
+  s32k1xx_dmach_stop(priv->rxdma);
+
+  /* Configure for circular DMA reception into the RX FIFO */
+
+  config.saddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+  config.daddr  = (uint32_t) priv->rxfifo;
+  config.soff   = 0;
+  config.doff   = 1;
+  config.iter   = RXDMA_BUFFER_SIZE;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE |
+                  EDMA_CONFIG_LOOPDEST |
+                  EDMA_CONFIG_INTHALF |
+                  EDMA_CONFIG_INTMAJOR;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = 1;
+#ifdef CONFIG_KINETIS_EDMA_ELINK
+  config.linkch = 0;
+#endif
+
+  s32k1xx_dmach_xfrsetup(priv->rxdma, &config);
+
+  /* Reset our DMA shadow pointer and Rx data availability count to match
+   * the address just programmed above.
+   */
+
+  priv->rxdmanext = 0;
+
+  /* Start the DMA channel, and arrange for callbacks at the half and
+   * full points in the FIFO.  This ensures that we have half a FIFO
+   * worth of time to claim bytes before they are overwritten.
+   */
+
+  s32k1xx_dmach_start(priv->rxdma, s32k1xx_dma_rxcallback, (void *)priv);
+
+  /* Clear DMA suspended flag. */
+
+  /* priv->rxdmasusp  = false; DMA suspend not supported */
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_rxint
+ *
+ * Description:
+ *   Call to enable or disable RX interrupts
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static void s32k1xx_dma_rxint(struct uart_dev_s *dev, bool enable)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Enable/disable DMA reception.
+   *
+   * Note that it is not safe to check for available bytes and immediately
+   * pass them to uart_recvchars as that could potentially recurse back
+   * to us again.  Instead, bytes must wait until the next up_dma_poll or
+   * DMA event.
+   */
+
+  priv->rxenable = enable;
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_rxavailable
+ *
+ * Description:
+ *   Return true if the receive register is not empty
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static bool s32k1xx_dma_rxavailable(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Compare our receive pointer to the current DMA pointer, if they
+   * do not match, then there are bytes to be received.
+   */
+
+  return (s32k1xx_dma_nextrx(priv) != priv->rxdmanext);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_txcallback
+ *
+ * Description:
+ *   This function clears dma buffer at complete of DMA transfer and wakes up
+ *   threads waiting for space in buffer.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)arg;
+  /* Update 'nbytes' indicating number of bytes actually transferred by DMA.
+   * This is important to free TX buffer space by 'uart_xmitchars_done'.
+   */
+
+  priv->dev.dmatx.nbytes = priv->dev.dmatx.length + priv->dev.dmatx.nlength;
+
+  /* Adjust the pointers */
+
+  uart_xmitchars_done(&priv->dev);
+
+  /* Release waiter */
+
+  nxsem_post(&priv->txdmasem);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_txavailable
+ *
+ * Description:
+ *        Informs DMA that Tx data is available and is ready for transfer.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txavailable(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+
+  /* Only send when the DMA is idle */
+
+  nxsem_wait(&priv->txdmasem);
+
+  uart_xmitchars_dma(dev);
+}
+#endif
+
+/****************************************************************************
+ * Name: s32k1xx_dma_send
+ *
+ * Description:
+ *   Called (usually) from the interrupt level to start DMA transfer.
+ *   (Re-)Configures DMA Stream updating buffer and buffer length.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_send(struct uart_dev_s *dev)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev;
+  struct s32k1xx_edma_xfrconfig_s config;
+
+  /* We need to stop DMA before reconfiguration */
+
+  s32k1xx_dmach_stop(priv->txdma);
+
+  /* Reset the number sent */
+
+  dev->dmatx.nbytes = 0;
+
+  /* Make use of setup function to update buffer and its length for next
+   * transfer
+   */
+
+  config.iter   = dev->dmatx.length;
+  config.flags  = EDMA_CONFIG_LINKTYPE_LINKNONE;
+  config.ssize  = EDMA_8BIT;
+  config.dsize  = EDMA_8BIT;
+  config.nbytes = sizeof(dev->dmatx.buffer[0]);
+  config.saddr  = (uint32_t)dev->dmatx.buffer;
+  config.daddr  = priv->uartbase + S32K1XX_LPUART_DATA_OFFSET;
+  config.soff   = sizeof(dev->dmatx.buffer[0]);
+  config.doff   = 0;
+#ifdef CONFIG_S32K1XX_EDMA_ELINK
+  config.linkch  = 0;
+#endif
+
+  /* Setup first half */
+
+  s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+
+  /* Is this a split transfer? */
+
+  if (dev->dmatx.nbuffer)
+    {
+      config.iter   = priv->dev.dmatx.nlength;
+      config.saddr  = (uint32_t)priv->dev.dmatx.nbuffer;
+
+      s32k1xx_dmach_xfrsetup(priv->txdma, &config);
+    }
+
+  /* Start transmission with the callback on DMA completion */
+
+  s32k1xx_dmach_start(priv->txdma, s32k1xx_dma_txcallback, (void *)priv);
+}
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_send
@@ -1037,6 +1846,28 @@ static void s32k1xx_send(struct uart_dev_s *dev, int ch)
   s32k1xx_serialout(priv, S32K1XX_LPUART_DATA_OFFSET, (uint32_t)ch);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_txint
+ *
+ * Description:
+ *   Call to enable or disable TX interrupts from the UART.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_TXDMA
+static void s32k1xx_dma_txint(struct uart_dev_s *dev, bool enable)
+{
+  /* Nothing to do. */
+
+  /* In case of DMA transfer we do not want to make use of UART interrupts.
+   * Instead, we use DMA interrupts that are activated once during boot
+   * sequence. Furthermore we can use s32k1xx_dma_txcallback() to handle
+   * stuff at half DMA transfer or after transfer completion (depending on
+   * the configuration).
+   */
+}
+#endif
+
 /****************************************************************************
  * Name: s32k1xx_txint
  *
@@ -1045,6 +1876,7 @@ static void s32k1xx_send(struct uart_dev_s *dev, int ch)
  *
  ****************************************************************************/
 
+#if !defined(SERIAL_HAVE_ONLY_TXDMA)
 static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
 {
   struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)dev->priv;
@@ -1057,12 +1889,12 @@ static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
   if (enable)
     {
 #ifndef CONFIG_SUPPRESS_SERIAL_INTS
-      priv->ie |= LPUART_CTRL_TCIE;
+      priv->ie |= LPUART_CTRL_TIE;
 #endif
     }
   else
     {
-      priv->ie &= ~LPUART_CTRL_TCIE;
+      priv->ie &= ~LPUART_CTRL_TIE;
     }
 
   regval  = s32k1xx_serialin(priv, S32K1XX_LPUART_CTRL_OFFSET);
@@ -1071,6 +1903,7 @@ static void s32k1xx_txint(struct uart_dev_s *dev, bool enable)
   s32k1xx_serialout(priv, S32K1XX_LPUART_CTRL_OFFSET, regval);
   spin_unlock_irqrestore(NULL, flags);
 }
+#endif
 
 /****************************************************************************
  * Name: s32k1xx_txready
@@ -1106,6 +1939,48 @@ static bool s32k1xx_txempty(struct uart_dev_s *dev)
   return ((regval & LPUART_STAT_TDRE) != 0);
 }
 
+/****************************************************************************
+ * Name: s32k1xx_dma_rxcallback
+ *
+ * Description:
+ *   This function checks the current DMA state and calls the generic
+ *   serial stack when bytes appear to be available.
+ *
+ ****************************************************************************/
+
+#ifdef SERIAL_HAVE_RXDMA
+static void s32k1xx_dma_rxcallback(DMACH_HANDLE handle, void *arg, bool done,
+                                   int result)
+{
+  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)arg;
+  uint32_t sr;
+
+  if (priv->rxenable && s32k1xx_dma_rxavailable(&priv->dev))
+    {
+      uart_recvchars(&priv->dev);
+    }
+
+  /* Get the masked LPUART status word to check and clear error flags.
+   *
+   * When wake-up from low power mode was not fast enough, UART is resumed
+   * too late and sometimes exactly when character was coming over UART,
+   * resulting to frame error.
+   * If error flag is not cleared, Rx DMA will be stuck. Clearing errors
+   * will release Rx DMA.
+   */
+
+  sr = s32k1xx_serialin(priv, S32K1XX_LPUART_STAT_OFFSET);
+
+  if ((sr & (LPUART_STAT_OR | LPUART_STAT_NF | LPUART_STAT_FE)) != 0)
+    {
+      s32k1xx_serialout(priv, S32K1XX_LPUART_STAT_OFFSET,
+                        sr & (LPUART_STAT_OR |
+                              LPUART_STAT_NF |
+                              LPUART_STAT_FE));
+    }
+}
+#endif
+
 /****************************************************************************
  * Name: up_pm_notify
  *
@@ -1136,13 +2011,13 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
   peripheral_clock_source_t clock_source;
 
   #ifdef CONFIG_PM_SERIAL0
-    struct s32k1xx_uart_s *priv0 = g_uart0port.priv;
+    struct s32k1xx_uart_s *priv0 = g_lpuart0priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL1
-    struct s32k1xx_uart_s *priv1 = g_uart1port.priv;
+    struct s32k1xx_uart_s *priv1 = g_lpuart1priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL2
-    struct s32k1xx_uart_s *priv2 = g_uart2port.priv;
+    struct s32k1xx_uart_s *priv2 = g_lpuart2priv.dev.priv;
   #endif
 
   uint32_t ret_reg = 0;
@@ -1215,7 +2090,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart0port);
+      s32k1xx_shutdown(&g_lpuart0priv);
 
       /* change the clock config for the new mode */
 
@@ -1223,16 +2098,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart0port);
+      s32k1xx_shutdown(&g_lpuart0priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart0port);
+      s32k1xx_setup(&g_lpuart0priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart0port, true);
-      s32k1xx_txint(&g_uart0port, true);
+      s32k1xx_rxint(&g_lpuart0priv, true);
+      s32k1xx_txint(&g_lpuart0priv, true);
 
     #endif
     #ifdef CONFIG_PM_SERIAL1
@@ -1262,7 +2137,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart1port);
+      s32k1xx_shutdown(&g_lpuart1priv);
 
       /* change the clock config for the new mode */
 
@@ -1270,16 +2145,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart1port);
+      s32k1xx_shutdown(&g_lpuart1priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart1port);
+      s32k1xx_setup(&g_lpuart1priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart1port, true);
-      s32k1xx_txint(&g_uart1port, true);
+      s32k1xx_rxint(&g_lpuart1priv, true);
+      s32k1xx_txint(&g_lpuart1priv, true);
 
     #endif
     #ifdef CONFIG_PM_SERIAL2
@@ -1309,7 +2184,7 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart2port);
+      s32k1xx_shutdown(&g_lpuart2priv);
 
       /* change the clock config for the new mode */
 
@@ -1317,16 +2192,16 @@ static void up_pm_notify(struct pm_callback_s *cb, int domain,
 
       /* shutdown the LPUART1 (soft reset) */
 
-      s32k1xx_shutdown(&g_uart2port);
+      s32k1xx_shutdown(&g_lpuart2priv);
 
       /* set up the LPUART1 again for the new mode */
 
-      s32k1xx_setup(&g_uart2port);
+      s32k1xx_setup(&g_lpuart2priv);
 
       /* enable the interrupts */
 
-      s32k1xx_rxint(&g_uart2port, true);
-      s32k1xx_txint(&g_uart2port, true);
+      s32k1xx_rxint(&g_lpuart2priv, true);
+      s32k1xx_txint(&g_lpuart2priv, true);
 
     #endif
   }
@@ -1378,13 +2253,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
   peripheral_clock_source_t clock_source;
 
   #ifdef CONFIG_PM_SERIAL0
-    struct s32k1xx_uart_s *priv0 = (struct s32k1xx_uart_s *)g_uart0port.priv;
+    struct s32k1xx_uart_s *priv0 =
+        (struct s32k1xx_uart_s *)g_lpuart0priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL1
-    struct s32k1xx_uart_s *priv1 = (struct s32k1xx_uart_s *)g_uart1port.priv;
+    struct s32k1xx_uart_s *priv1 =
+        (struct s32k1xx_uart_s *)g_lpuart1priv.dev.priv;
   #endif
   #ifdef CONFIG_PM_SERIAL2
-    struct s32k1xx_uart_s *priv2 = (struct s32k1xx_uart_s *)g_uart2port.priv;
+    struct s32k1xx_uart_s *priv2 =
+        (struct s32k1xx_uart_s *)g_lpuart2priv.dev.priv;
   #endif
 
   uint32_t ret_reg = 0;
@@ -1461,7 +2339,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart0port);
+    s32k1xx_shutdown(&g_lpuart0priv);
 
     /* change the clock config for the new mode */
 
@@ -1469,16 +2347,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart0port);
+    s32k1xx_shutdown(&g_lpuart0priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart0port);
+    s32k1xx_setup(&g_lpuart0priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart0port, true);
-    s32k1xx_txint(&g_uart0port, true);
+    s32k1xx_rxint(&g_lpuart0priv, true);
+    s32k1xx_txint(&g_lpuart0priv, true);
 
   #endif
   #ifdef CONFIG_PM_SERIAL1
@@ -1508,7 +2386,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart1port);
+    s32k1xx_shutdown(&g_lpuart1priv);
 
     /* change the clock config for the new mode */
 
@@ -1516,16 +2394,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart1port);
+    s32k1xx_shutdown(&g_lpuart1priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart1port);
+    s32k1xx_setup(&g_lpuart1priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart1port, true);
-    s32k1xx_txint(&g_uart1port, true);
+    s32k1xx_rxint(&g_lpuart1priv, true);
+    s32k1xx_txint(&g_lpuart1priv, true);
 
   #endif
   #ifdef CONFIG_PM_SERIAL2
@@ -1555,7 +2433,7 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart2port);
+    s32k1xx_shutdown(&g_lpuart2priv);
 
     /* change the clock config for the new mode */
 
@@ -1563,16 +2441,16 @@ static int up_pm_prepare(struct pm_callback_s *cb, int domain,
 
     /* shutdown the LPUART1 (soft reset) */
 
-    s32k1xx_shutdown(&g_uart2port);
+    s32k1xx_shutdown(&g_lpuart2priv);
 
     /* set up the LPUART1 again for the new mode */
 
-    s32k1xx_setup(&g_uart2port);
+    s32k1xx_setup(&g_lpuart2priv);
 
     /* enable the interrupts */
 
-    s32k1xx_rxint(&g_uart2port, true);
-    s32k1xx_txint(&g_uart2port, true);
+    s32k1xx_rxint(&g_lpuart2priv, true);
+    s32k1xx_txint(&g_lpuart2priv, true);
 
   #endif
 
@@ -1606,8 +2484,8 @@ void s32k1xx_earlyserialinit(void)
    */
 
 #ifdef CONSOLE_DEV
-  CONSOLE_DEV.isconsole = true;
-  s32k1xx_setup(&CONSOLE_DEV);
+  CONSOLE_DEV.dev.isconsole = true;
+  s32k1xx_setup(&CONSOLE_DEV.dev);
 #endif
 }
 
@@ -1623,7 +2501,7 @@ void s32k1xx_earlyserialinit(void)
 void arm_serialinit(void)
 {
 #ifdef CONFIG_PM
-  #if defined(CONFIG_PM_SERIAL_STANDBY) || defined(CONFIG_PM_SERIAL_SLEEP) 
+  #if defined(CONFIG_PM_SERIAL_STANDBY) || defined(CONFIG_PM_SERIAL_SLEEP)
 
   int ret;
 
@@ -1636,17 +2514,20 @@ void arm_serialinit(void)
 #endif
 
 #ifdef CONSOLE_DEV
-  uart_register("/dev/console", &CONSOLE_DEV);
+  uart_register("/dev/console", &CONSOLE_DEV.dev);
+#  if defined(SERIAL_HAVE_CONSOLE_DMA)
+  s32k1xx_dma_setup(&CONSOLE_DEV.dev);
+#  endif
 #endif
 
   /* Register all UARTs */
 
-  uart_register("/dev/ttyS0", &TTYS0_DEV);
+  uart_register("/dev/ttyS0", &TTYS0_DEV.dev);
 #ifdef TTYS1_DEV
-  uart_register("/dev/ttyS1", &TTYS1_DEV);
+  uart_register("/dev/ttyS1", &TTYS1_DEV.dev);
 #endif
 #ifdef TTYS2_DEV
-  uart_register("/dev/ttyS2", &TTYS2_DEV);
+  uart_register("/dev/ttyS2", &TTYS2_DEV.dev);
 #endif
 }
 
@@ -1661,7 +2542,8 @@ void arm_serialinit(void)
 int up_putc(int ch)
 {
 #ifdef CONSOLE_DEV
-  struct s32k1xx_uart_s *priv = (struct s32k1xx_uart_s *)CONSOLE_DEV.priv;
+  struct s32k1xx_uart_s *priv =
+      (struct s32k1xx_uart_s *)CONSOLE_DEV.dev.priv;
   uint32_t ie;
 
   s32k1xx_disableuartint(priv, &ie);
diff --git a/arch/arm/src/s32k1xx/s32k1xx_serial.h b/arch/arm/src/s32k1xx/s32k1xx_serial.h
index e0c26f2a83..4b05fff5a8 100644
--- a/arch/arm/src/s32k1xx/s32k1xx_serial.h
+++ b/arch/arm/src/s32k1xx/s32k1xx_serial.h
@@ -34,6 +34,115 @@
  * Pre-processor Definitions
  ****************************************************************************/
 
+#if defined(CONFIG_S32K1XX_LPUART0) || defined(CONFIG_S32K1XX_LPUART1) || \
+    defined(CONFIG_S32K1XX_LPUART2)
+#  define HAVE_UART 1
+#endif
+
+/* Assume DMA is not used on the console UART */
+
+#undef SERIAL_HAVE_CONSOLE_RXDMA
+#undef SERIAL_HAVE_CONSOLE_TXDMA
+
+#if !defined(HAVE_UART) || !defined(CONFIG_ARCH_DMA)
+#  undef CONFIG_LPUART0_RXDMA
+#  undef CONFIG_LPUART0_TXDMA
+#  undef CONFIG_LPUART1_RXDMA
+#  undef CONFIG_LPUART1_TXDMA
+#  undef CONFIG_LPUART2_RXDMA
+#  undef CONFIG_LPUART2_TXDMA
+#endif
+
+/* Disable the DMA configuration on all unused LPUARTs */
+
+#ifndef CONFIG_S32K1XX_LPUART0
+#  undef CONFIG_LPUART0_RXDMA
+#  undef CONFIG_LPUART0_TXDMA
+#endif
+
+#ifndef CONFIG_S32K1XX_LPUART1
+#  undef CONFIG_LPUART1_RXDMA
+#  undef CONFIG_LPUART1_TXDMA
+#endif
+
+#ifndef CONFIG_S32K1XX_LPUART2
+#  undef CONFIG_LPUART2_RXDMA
+#  undef CONFIG_LPUART2_TXDMA
+#endif
+
+/* Is RX DMA available on any (enabled) LPUART? */
+
+#undef SERIAL_HAVE_RXDMA
+#if defined(CONFIG_LPUART0_RXDMA) || defined(CONFIG_LPUART1_RXDMA) || \
+    defined(CONFIG_LPUART2_RXDMA)
+#  define SERIAL_HAVE_RXDMA 1
+#endif
+
+/* Is TX DMA available on any (enabled) LPUART? */
+#undef SERIAL_HAVE_TXDMA
+#if defined(CONFIG_LPUART0_TXDMA) || defined(CONFIG_LPUART1_TXDMA) || \
+    defined(CONFIG_LPUART2_TXDMA)
+#    define SERIAL_HAVE_TXDMA 1
+#endif
+
+/* Is RX DMA used on all (enabled) LPUARTs */
+
+#define SERIAL_HAVE_ONLY_RXDMA 1
+#if defined(CONFIG_S32K1XX_LPUART0) && !defined(CONFIG_LPUART0_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#elif defined(CONFIG_S32K1XX_LPUART1) && !defined(CONFIG_LPUART1_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#elif defined(CONFIG_S32K1XX_LPUART2) && !defined(CONFIG_LPUART2_RXDMA)
+#  undef SERIAL_HAVE_ONLY_RXDMA
+#endif
+
+/* Is TX DMA used on all (enabled) LPUARTs */
+
+#define SERIAL_HAVE_ONLY_TXDMA 1
+#if defined(CONFIG_S32K1XX_LPUART0) && !defined(CONFIG_LPUART0_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#elif defined(CONFIG_S32K1XX_LPUART1) && !defined(CONFIG_LPUART1_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#elif defined(CONFIG_S32K1XX_LPUART2) && !defined(CONFIG_LPUART2_TXDMA)
+#  undef SERIAL_HAVE_ONLY_TXDMA
+#endif
+
+#undef SERIAL_HAVE_ONLY_DMA
+#if defined(SERIAL_HAVE_ONLY_RXDMA) && defined(SERIAL_HAVE_ONLY_TXDMA)
+#define SERIAL_HAVE_ONLY_DMA
+#endif
+
+/* Verify that DMA has been enabled and the DMA channel has been defined.
+ */
+
+#if defined(SERIAL_HAVE_TXDMA) || defined(SERIAL_HAVE_RXDMA)
+#  ifndef CONFIG_S32K1XX_EDMA
+#    error S32K1XX LPUART receive or transmit DMA requires CONFIG_S32K1XX_EDMA
+#  endif
+#endif
+
+#if defined(SERIAL_HAVE_RXDMA)
+/* Currently RS-485 support cannot be enabled when RXDMA is in use due to
+ * lack of testing.
+ */
+
+#  if (defined(CONFIG_LPUART0_RXDMA) && defined(CONFIG_LPUART0_RS485)) || \
+      (defined(CONFIG_LPUART1_RXDMA) && defined(CONFIG_LPUART1_RS485)) || \
+      (defined(CONFIG_LPUART2_RXDMA) && defined(CONFIG_LPUART2_RS485))
+#    error "RXDMA and RS-485 cannot be enabled at the same time for the same LPUART"
+#  endif
+#endif /* SERIAL_HAVE_RXDMA */
+
+/* Currently RS-485 support cannot be enabled when TXDMA is in use due to
+ * lack of testing.
+ */
+
+#if (defined(CONFIG_LPUART0_TXDMA) && defined(CONFIG_LPUART0_RS485)) || \
+    (defined(CONFIG_LPUART1_TXDMA) && defined(CONFIG_LPUART1_RS485)) || \
+    (defined(CONFIG_LPUART2_TXDMA) && defined(CONFIG_LPUART2_RS485))
+#  error "TXDMA and RS-485 cannot be enabled at the same time for the same LPUART"
+#endif
+
 /****************************************************************************
  * Public Types
  ****************************************************************************/
diff --git a/boards/Kconfig b/boards/Kconfig
index 22302dd4d7..0ad60e3849 100644
--- a/boards/Kconfig
+++ b/boards/Kconfig
@@ -1603,6 +1603,14 @@ config ARCH_BOARD_RDDRONE_BMS772
 		This options selects support for NuttX on the NXP RDDRONE-BMS772
 		board featuring the S32K144 Cortex-M4F.
 
+config ARCH_BOARD_MR_BMS771
+	bool "NXP MR-BMS771"
+	depends on ARCH_CHIP_S32K146
+	select ARCH_HAVE_LEDS
+	---help---
+		This options selects support for NuttX on the NXP MR-BMS771
+		board featuring the S32K146 Cortex-M4F.
+
 config ARCH_BOARD_S32K146EVB
 	bool "NXP S32K146EVB"
 	depends on ARCH_CHIP_S32K146
@@ -2717,6 +2725,7 @@ config ARCH_BOARD
 	default "s32k118evb"               if ARCH_BOARD_S32K118EVB
 	default "s32k144evb"               if ARCH_BOARD_S32K144EVB
 	default "rddrone-bms772"           if ARCH_BOARD_RDDRONE_BMS772
+	default "mr-bms771"                if ARCH_BOARD_MR_BMS771
 	default "s32k146evb"               if ARCH_BOARD_S32K146EVB
 	default "ucans32k146"              if ARCH_BOARD_UCANS32K146
 	default "s32k148evb"               if ARCH_BOARD_S32K148EVB
@@ -2891,6 +2900,9 @@ endif
 if ARCH_BOARD_RDDRONE_BMS772
 source "boards/arm/s32k1xx/rddrone-bms772/Kconfig"
 endif
+if ARCH_BOARD_MR_BMS771
+source "boards/arm/s32k1xx/mr-bms771/Kconfig"
+endif
 if ARCH_BOARD_S32K146EVB
 source "boards/arm/s32k1xx/s32k146evb/Kconfig"
 endif
diff --git a/boards/arm/s32k1xx/mr-bms771/Kconfig b/boards/arm/s32k1xx/mr-bms771/Kconfig
new file mode 100644
index 0000000000..5443173a8b
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/Kconfig
@@ -0,0 +1,27 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+
+if ARCH_BOARD_MR_BMS771
+
+config S32K1XX_NRSTCHECK_PROCFS
+	bool "MR-BMS771 nRST Check PROCFS entry"
+	default n
+	depends on FS_PROCFS
+	select FS_PROCFS_REGISTER
+	---help---
+		Self-test to check that the MCU reset pin is connected to an
+		external pull-up resistor (or an IC that pulls the pin high).
+		The input logic level is registered as a PROCFS entry.
+
+config SMBUS_SBD
+	bool "SMBus Smart Battery Data slave"
+	default n
+	depends on I2C_SLAVE
+	---help---
+		Simple SMBus/I2C slave providing battery management data,
+		specifically implementing a subset of the Smart Battery Data
+		Specification, Revision 1.1
+
+endif # ARCH_BOARD_MR_BMS771
diff --git a/boards/arm/s32k1xx/mr-bms771/README.txt b/boards/arm/s32k1xx/mr-bms771/README.txt
new file mode 100644
index 0000000000..54bb83e614
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/README.txt
@@ -0,0 +1,142 @@
+README
+======
+
+This directory holds the port to the NXP MR-BMS771 board with S32K146
+MCU.
+
+A NuttX compatible smart battery application for MR-BMS771 is also
+available. It contains additional drivers and example software to use
+most features of the battery management system.
+
+This application is currently published in a separate repository, but
+(parts) may eventually be upstreamed to Apache NuttX: 
+https://github.com/NXPHoverGames/MR-BMS771
+
+
+Contents
+========
+
+  o Status
+  o Serial Console
+  o LEDs
+  o Thread-Aware Debugging with Eclipse
+  o Configurations
+
+Status
+======
+
+  2020-11-02:  Configuration first published in separate GitHub repository.
+    Tested with the aforementioned BMS application.
+
+  2022-05-25:  Basic board configuration prepared for upstreaming to Apache NuttX.
+
+Serial Console
+==============
+
+  By default, the serial console will be provided on the DCD-LZ UART
+  (available on the 7-pin DCD-LZ debug connector J19):
+
+    DCD-LZ UART RX  PTC6  (LPUART1_RX)
+    DCD-LZ UART TX  PTC7  (LPUART1_TX)
+
+LEDs and Buttons
+================
+
+  LEDs
+  ----
+  The MR-BMS771 has one RGB LED:
+
+    RedLED    PTD16  (FTM0 CH1)
+    GreenLED  PTB13  (FTM0 CH1)
+    BlueLED   PTD15  (FTM0 CH0)
+
+  An output of '0' illuminates the LED.
+
+  If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in
+  any way.  The following definitions are used to access individual RGB
+  components (see mr-bms771.h):
+
+    GPIO_LED_R
+    GPIO_LED_G
+    GPIO_LED_B
+
+  The RGB components could, alternatively, be controlled through PWM using
+  the common RGB LED driver.
+
+  If CONFIG_ARCH_LEDs is defined, then NuttX will control the LEDs on board
+  the MR-BMS771.  The following definitions describe how NuttX controls
+  the LEDs:
+
+    ==========================================+========+========+=========
+                                                 RED     GREEN     BLUE
+    ==========================================+========+========+=========
+
+    LED_STARTED      NuttX has been started      OFF      OFF      OFF
+    LED_HEAPALLOCATE Heap has been allocated     OFF      OFF      ON
+    LED_IRQSENABLED  Interrupts enabled          OFF      OFF      ON
+    LED_STACKCREATED Idle stack created          OFF      ON       OFF
+    LED_INIRQ        In an interrupt                   (no change)
+    LED_SIGNAL       In a signal handler               (no change)
+    LED_ASSERTION    An assertion failed               (no change)
+    LED_PANIC        The system has crashed      FLASH    OFF      OFF
+    LED_IDLE         S32K146 in sleep mode             (no change)
+    ==========================================+========+========+=========
+
+Thread-Aware Debugging with Eclipse
+===================================
+
+  Thread-aware debugging is possible with openocd-nuttx
+  ( https://github.com/sony/openocd-nuttx ) and was tested together with the
+  Eclipse-based S32 Design Studio for Arm:  
+  https://www.nxp.com/design/software/development-software/s32-design-studio-ide/s32-design-studio-for-arm:S32DS-ARM
+
+  NOTE: This method was last tested with NuttX 8.2 and S32DS for Arm 2018.R1.
+  It may not work anymore with recent releases of NuttX and/or S32DS.
+
+  1. NuttX should be build with debug symbols enabled.
+
+  2. Build OpenOCD as described here (using the same parameters as well):
+     https://micro.ros.org/docs/tutorials/old/debugging/
+
+  3. A s32k146.cfg file is available in the scripts/ folder.  Start OpenOCD
+     with the following command (adapt the path info):
+     /usr/local/bin/openocd -f /usr/share/openocd/scripts/interface/jlink.cfg \
+     -f boards/s32k1xx/mr-bms771/scripts/s32k146.cfg -c init -c "reset halt"
+
+  4. Setup a GDB debug session in Eclipse.  The resulting debug window shows
+     the NuttX threads.  The full stack details can be viewed.
+
+Configurations
+==============
+
+  Common Information
+  ------------------
+  Each MR-BMS771 configuration is maintained in a sub-directory and can be
+  selected as follows:
+
+    tools/configure.sh mr-bms771:<subdir>
+
+  Where <subdir> is one of the sub-directories listed in the next paragraph.
+
+    NOTES (common for all configurations):
+
+    1. This configuration uses the mconf-based configuration tool.  To change
+       this configuration using that tool, you should:
+
+       a. Build and install the kconfig-mconf tool.  See nuttx/README.txt.
+          Also see additional README.txt files in the NuttX tools repository.
+
+       b. Execute 'make menuconfig' in nuttx/ in order to start the
+          reconfiguration process.
+
+    2. Unless otherwise stated, the serial console used is LPUART1 at
+       115,200 8N1.  This corresponds to the OpenSDA VCOM port.
+
+  Configuration Sub-directories
+  -----------------------------
+
+    nsh:
+    ---
+      Configures the NuttShell (nsh) located at apps/examples/nsh.  Support
+      for builtin applications is enabled, but in the base configuration the
+      only application selected is the "Hello, World!" example.
diff --git a/boards/arm/s32k1xx/mr-bms771/configs/bms/defconfig b/boards/arm/s32k1xx/mr-bms771/configs/bms/defconfig
new file mode 100644
index 0000000000..6cdf0d5818
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/configs/bms/defconfig
@@ -0,0 +1,142 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="mr-bms771"
+CONFIG_ARCH_BOARD_MR_BMS771=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K146=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=126976
+CONFIG_RAM_START=0x1fff0000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=27
+CONFIG_START_MONTH=1
+CONFIG_START_YEAR=2023
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/mr-bms771/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/mr-bms771/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..862115949a
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/configs/bmsdebug/defconfig
@@ -0,0 +1,150 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="mr-bms771"
+CONFIG_ARCH_BOARD_MR_BMS771=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K146=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEBUG_WARN=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=126976
+CONFIG_RAM_START=0x1fff0000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_BACKTRACE=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=27
+CONFIG_START_MONTH=1
+CONFIG_START_YEAR=2023
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/mr-bms771/configs/bmstrace/defconfig b/boards/arm/s32k1xx/mr-bms771/configs/bmstrace/defconfig
new file mode 100644
index 0000000000..59e2047f10
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/configs/bmstrace/defconfig
@@ -0,0 +1,159 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="mr-bms771"
+CONFIG_ARCH_BOARD_MR_BMS771=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K146=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_DRIVER_NOTE=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=126976
+CONFIG_RAM_START=0x1fff0000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_BACKTRACE=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_INSTRUMENTATION=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER_DEFAULT_MODE=0x0B
+CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER=y
+CONFIG_SCHED_INSTRUMENTATION_SWITCH=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SEGGER_RTT_BUFFER_SIZE_DOWN=2048
+CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=2048
+CONFIG_SEGGER_RTT_MAX_NUM_DOWN_BUFFERS=12
+CONFIG_SEGGER_RTT_MAX_NUM_UP_BUFFERS=12
+CONFIG_SEGGER_SYSVIEW=y
+CONFIG_SEGGER_SYSVIEW_RTT_BUFFER_SIZE=6144
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=27
+CONFIG_START_MONTH=1
+CONFIG_START_YEAR=2023
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_CONSOLE=y
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/mr-bms771/configs/nsh/defconfig b/boards/arm/s32k1xx/mr-bms771/configs/nsh/defconfig
new file mode 100644
index 0000000000..5423dcf849
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/configs/nsh/defconfig
@@ -0,0 +1,43 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_FPU is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="mr-bms771"
+CONFIG_ARCH_BOARD_MR_BMS771=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K146=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_EXAMPLES_HELLO=y
+CONFIG_FS_PROCFS=y
+CONFIG_HAVE_CXX=y
+CONFIG_HAVE_CXXINITIALIZE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=126976
+CONFIG_RAM_START=0x1fff0000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_SCHED_WAITPID=y
+CONFIG_START_DAY=8
+CONFIG_START_MONTH=11
+CONFIG_START_YEAR=2022
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSTEM_NSH=y
diff --git a/boards/arm/s32k1xx/mr-bms771/include/board.h b/boards/arm/s32k1xx/mr-bms771/include/board.h
new file mode 100644
index 0000000000..761b4eb1ca
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/include/board.h
@@ -0,0 +1,156 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/include/board.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+#ifndef __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_BOARD_H
+#define __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_BOARD_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Clocking *****************************************************************/
+
+/* The MR-BMS771 is fitted with a 32 MHz crystal */
+
+#define BOARD_XTAL_FREQUENCY                  32000000
+
+/* The S32K146 will run at 80 MHz in RUN mode */
+
+#define MR_BMS771_RUN_SYSCLK_FREQUENCY        80000000
+
+/* The S32K146 will run at 2 MHz in VLPR mode */
+
+#define MR_BMS771_VLPR_SYSCLK_FREQUENCY       2000000
+
+/* LED definitions **********************************************************/
+
+/* The MR-BMS771 has one RGB LED:
+ *
+ *   RedLED    PTD16  (FTM0 CH1)
+ *   GreenLED  PTB13  (FTM0 CH1)
+ *   BlueLED   PTD15  (FTM0 CH0)
+ *
+ * If CONFIG_ARCH_LEDS is not defined, then the user can control the LEDs in
+ * any way.  The following definitions are used to access individual RGB
+ * components.
+ *
+ * The RGB components could, alternatively be controlled through PWM using
+ * the common RGB LED driver.
+ */
+
+/* LED index values for use with board_userled() */
+
+#define BOARD_LED_R       0
+#define BOARD_LED_G       1
+#define BOARD_LED_B       2
+#define BOARD_NLEDS       3
+
+/* LED bits for use with board_userled_all() */
+
+#define BOARD_LED_R_BIT   (1 << BOARD_LED_R)
+#define BOARD_LED_G_BIT   (1 << BOARD_LED_G)
+#define BOARD_LED_B_BIT   (1 << BOARD_LED_B)
+
+/* If CONFIG_ARCH_LEDs is defined, then NuttX will control the LEDs on board
+ * the MR-BMS771.  The following definitions describe how NuttX controls
+ * the LEDs:
+ *
+ *      SYMBOL            Meaning                         LED state
+ *                                                        RED    GREEN  BLUE
+ *      ----------------  -----------------------------  -------------------
+ */
+
+#define LED_STARTED       1 /* NuttX has been started     OFF    OFF    OFF */
+#define LED_HEAPALLOCATE  2 /* Heap has been allocated    OFF    OFF    ON  */
+#define LED_IRQSENABLED   0 /* Interrupts enabled         OFF    OFF    ON  */
+#define LED_STACKCREATED  3 /* Idle stack created         OFF    ON     OFF */
+#define LED_INIRQ         0 /* In an interrupt           (No change)        */
+#define LED_SIGNAL        0 /* In a signal handler       (No change)        */
+#define LED_ASSERTION     0 /* An assertion failed       (No change)        */
+#define LED_PANIC         4 /* The system has crashed     FLASH  OFF    OFF */
+#undef  LED_IDLE            /* S32K146 is in sleep mode  (Not used)         */
+
+/* UART selections **********************************************************/
+
+/* By default, the serial console will be provided on the DCD-LZ UART
+ * (available on the 7-pin DCD-LZ debug connector J19):
+ *
+ *   DCD-LZ UART RX  PTC6  (LPUART1_RX)
+ *   DCD-LZ UART TX  PTC7  (LPUART1_TX)
+ */
+
+#define PIN_LPUART1_RX    PIN_LPUART1_RX_1   /* PTC6 */
+#define PIN_LPUART1_TX    PIN_LPUART1_TX_1   /* PTC7 */
+
+/* Header J21  (LPUART0) */
+
+#define PIN_LPUART0_RX    PIN_LPUART0_RX_1   /* PTB0 */
+#define PIN_LPUART0_TX    PIN_LPUART0_TX_1   /* PTB1 */
+
+/* SPI selections ***********************************************************/
+
+/* UJA1169ATK/F SBC SPI  (LPSPI0) */
+
+#define PIN_LPSPI0_SCK    PIN_LPSPI0_SCK_3   /* PTB2 */
+#define PIN_LPSPI0_MISO   PIN_LPSPI0_SIN_2   /* PTB3 */
+#define PIN_LPSPI0_MOSI   PIN_LPSPI0_SOUT_3  /* PTB4 */
+#define PIN_LPSPI0_PCS    PIN_LPSPI0_PCS0_3  /* PTB5 */
+
+/* MC33771C BCC SPI  (LPSPI1) */
+
+#define PIN_LPSPI1_SCK    PIN_LPSPI1_SCK_3   /* PTD0 */
+#define PIN_LPSPI1_MISO   PIN_LPSPI1_SIN_2   /* PTD1 */
+#define PIN_LPSPI1_MOSI   PIN_LPSPI1_SOUT_3  /* PTD2 */
+#define PIN_LPSPI1_PCS    PIN_LPSPI1_PCS0_2  /* PTD3 */
+
+/* I2C selections ***********************************************************/
+
+/* I2C Master Connector J23  (LPI2C0 Master) */
+
+#define PIN_LPI2C0_SDA    PIN_LPI2C0_SDA_2   /* PTA2 */
+#define PIN_LPI2C0_SCL    PIN_LPI2C0_SCL_2   /* PTA3 */
+
+/* I2C/SMBus Connector J18  (LPI2C0 Slave) */
+
+#define PIN_LPI2C0_SDAS   PIN_LPI2C0_SDAS_1  /* PTA1 */
+#define PIN_LPI2C0_SCLS   PIN_LPI2C0_SCLS_1  /* PTA0 */
+
+/* CAN selections ***********************************************************/
+
+/* UJA1169ATK/F SBC CAN  (CAN0) */
+
+#define PIN_CAN0_RX       PIN_CAN0_RX_4      /* PTE4 */
+#define PIN_CAN0_TX       PIN_CAN0_TX_4      /* PTE5 */
+
+/* TJA1463ATK SIC CAN    (CAN1) */
+
+#define PIN_CAN1_RX       PIN_CAN1_RX_1      /* PTA12 */
+#define PIN_CAN1_TX       PIN_CAN1_TX_1      /* PTA13 */
+#define PIN_CAN1_STB      (PIN_PTB12 | GPIO_OUTPUT)
+
+#endif  /* __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_BOARD_H */
diff --git a/boards/arm/s32k1xx/mr-bms771/include/nsh_romfsimg.h b/boards/arm/s32k1xx/mr-bms771/include/nsh_romfsimg.h
new file mode 100644
index 0000000000..38a9ab91c0
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/include/nsh_romfsimg.h
@@ -0,0 +1,90 @@
+#include <nuttx/compiler.h>
+const unsigned char aligned_data(4) romfs_img[] = {
+  0x2d, 0x72, 0x6f, 0x6d, 0x31, 0x66, 0x73, 0x2d, 0x00, 0x00, 0x02, 0xd0,
+  0x61, 0xcb, 0xab, 0x51, 0x4e, 0x53, 0x48, 0x49, 0x6e, 0x69, 0x74, 0x56,
+  0x6f, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0x97,
+  0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x20,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xff, 0x80, 0x2e, 0x2e, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
+  0x68, 0x2d, 0x96, 0x03, 0x69, 0x6e, 0x69, 0x74, 0x2e, 0x64, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x7a,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc9, 0x8d, 0x9c, 0xaa, 0xbd,
+  0x72, 0x63, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
+  0x6c, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x52, 0x2d,
+  0x42, 0x4d, 0x53, 0x37, 0x37, 0x31, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61,
+  0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x65,
+  0x63, 0x68, 0x6f, 0x20, 0x22, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
+  0x6c, 0x65, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x61, 0x66,
+  0x74, 0x65, 0x72, 0x20, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x20, 0x69, 0x6e,
+  0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+  0x3a, 0x22, 0x0a, 0x22, 0x66, 0x72, 0x65, 0x65, 0x22, 0x0a, 0x23, 0x20,
+  0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x42, 0x72, 0x69, 0x6e, 0x67, 0x20,
+  0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65,
+  0x72, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x22, 0x0a, 0x23, 0x20, 0x22, 0x69,
+  0x66, 0x75, 0x70, 0x22, 0x20, 0x22, 0x63, 0x61, 0x6e, 0x30, 0x22, 0x0a,
+  0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x4d, 0x52, 0x2d, 0x42, 0x4d, 0x53,
+  0x37, 0x37, 0x31, 0x3a, 0x20, 0x53, 0x74, 0x61, 0x72, 0x74, 0x69, 0x6e,
+  0x67, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61, 0x70, 0x70, 0x6c, 0x69, 0x63,
+  0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x22, 0x62, 0x6d, 0x73, 0x22,
+  0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x9a,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf1, 0xaa, 0xb5, 0x64, 0x94,
+  0x72, 0x63, 0x2e, 0x73, 0x79, 0x73, 0x69, 0x6e, 0x69, 0x74, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x23, 0x20, 0x49, 0x6e, 0x69, 0x74, 0x69, 0x61,
+  0x6c, 0x69, 0x7a, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x52, 0x2d,
+  0x42, 0x4d, 0x53, 0x37, 0x37, 0x31, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61,
+  0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x0a, 0x65,
+  0x63, 0x68, 0x6f, 0x20, 0x22, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62,
+  0x6c, 0x65, 0x20, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x20, 0x61, 0x66,
+  0x74, 0x65, 0x72, 0x20, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x20, 0x69, 0x6e,
+  0x69, 0x74, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e,
+  0x3a, 0x22, 0x0a, 0x22, 0x66, 0x72, 0x65, 0x65, 0x22, 0x0a, 0x23, 0x20,
+  0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x4e, 0x4f, 0x54, 0x20, 0x62, 0x72,
+  0x69, 0x6e, 0x67, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x70, 0x20, 0x63, 0x61,
+  0x6e, 0x30, 0x20, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,
+  0x22, 0x0a, 0x23, 0x20, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x42, 0x72,
+  0x69, 0x6e, 0x67, 0x20, 0x75, 0x70, 0x20, 0x63, 0x61, 0x6e, 0x30, 0x20,
+  0x69, 0x6e, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65, 0x3a, 0x22, 0x0a,
+  0x23, 0x20, 0x22, 0x69, 0x66, 0x75, 0x70, 0x22, 0x20, 0x22, 0x63, 0x61,
+  0x6e, 0x30, 0x22, 0x0a, 0x65, 0x63, 0x68, 0x6f, 0x20, 0x22, 0x4d, 0x52,
+  0x2d, 0x42, 0x4d, 0x53, 0x37, 0x37, 0x31, 0x3a, 0x20, 0x53, 0x74, 0x61,
+  0x72, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x42, 0x4d, 0x53, 0x20, 0x61, 0x70,
+  0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x0a, 0x22,
+  0x62, 0x6d, 0x73, 0x22, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xb0,
+  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0xd1, 0xd1, 0xfd, 0x30,
+  0x2e, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60,
+  0x00, 0x00, 0x00, 0x00, 0xd1, 0xff, 0xff, 0xa0, 0x2e, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+unsigned int romfs_img_len = 1024;
diff --git a/boards/arm/s32k1xx/mr-bms771/include/rc.sysinit.template b/boards/arm/s32k1xx/mr-bms771/include/rc.sysinit.template
new file mode 100644
index 0000000000..031ccacc96
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/include/rc.sysinit.template
@@ -0,0 +1,8 @@
+# Initialize the MR-BMS771 BMS application
+echo "Available memory after board initialization:"
+"free"
+# echo "NOT bringing up can0 interface"
+# echo "Bring up can0 interface:"
+# "ifup" "can0"
+echo "MR-BMS771: Starting BMS application"
+"bms"
diff --git a/boards/arm/s32k1xx/mr-bms771/include/rcS.template b/boards/arm/s32k1xx/mr-bms771/include/rcS.template
new file mode 100644
index 0000000000..843cb9f9ee
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/include/rcS.template
@@ -0,0 +1,7 @@
+# Initialize the MR-BMS771 BMS application
+echo "Available memory after board initialization:"
+"free"
+# echo "Bring up can0 interface:"
+# "ifup" "can0"
+echo "MR-BMS771: Starting BMS application"
+"bms"
diff --git a/boards/arm/s32k1xx/mr-bms771/include/smbus_sbd.h b/boards/arm/s32k1xx/mr-bms771/include/smbus_sbd.h
new file mode 100644
index 0000000000..31ca7bf021
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/include/smbus_sbd.h
@@ -0,0 +1,201 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/include/smbus_sbd.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+#ifndef __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_SMBUS_SBD_H
+#define __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_SMBUS_SBD_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+
+#ifdef CONFIG_SMBUS_SBD
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Smart Battery Data Specification v1.1 registers **************************/
+
+/* 0x00-0x07 NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBD_MANUFACTURER_ACCESS       0x00
+#define SBD_REMAINING_CAPACITY_ALARM  0x01
+#define SBD_REMAINING_TIME_ALARM      0x02
+#define SBD_BATTERY_MODE              0x03
+#define SBD_AT_RATE                   0x04
+#define SBD_AT_RATE_TIME_TO_FULL      0x05
+#define SBD_AT_RATE_TIME_TO_EMPTY     0x06
+#define SBD_AT_RATE_OK                0x07
+#endif
+
+#define SBD_TEMPERATURE               0x08
+#define SBD_VOLTAGE                   0x09
+#define SBD_CURRENT                   0x0a
+#define SBD_AVERAGE_CURRENT           0x0b
+#define SBD_MAX_ERROR                 0x0c
+#define SBD_RELATIVE_STATE_OF_CHARGE  0x0d
+#define SBD_ABSOLUTE_STATE_OF_CHARGE  0x0e
+#define SBD_REMAINING_CAPACITY        0x0f
+#define SBD_FULL_CHARGE_CAPACITY      0x10
+#define SBD_RUN_TIME_TO_EMPTY         0x11
+#define SBD_AVERAGE_TIME_TO_EMPTY     0x12
+
+/* 0x13-0x16 NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBD_AVERAGE_TIME_TO_FULL      0x13
+#define SBD_CHARGING_CURRENT          0x14
+#define SBD_CHARGING_VOLTAGE          0x15
+#define SBD_BATTERY_STATUS            0x16
+#endif
+
+#define SBD_CYCLE_COUNT               0x17
+#define SBD_DESIGN_CAPACITY           0x18
+#define SBD_DESIGN_VOLTAGE            0x19
+
+/* 0x1a NOT YET IMPLEMENTED! */
+
+#if 0
+#define SBD_SPECIFICATION_INFO        0x1a
+#endif
+
+#define SBD_MANUFACTURE_DATE          0x1b
+#define SBD_SERIAL_NUMBER             0x1c
+#define SBD_MANUFACTURER_NAME         0x20
+#define SBD_DEVICE_NAME               0x21
+#define SBD_DEVICE_CHEMISTRY          0x22
+#define SBD_MANUFACTURER_DATA         0x23
+
+/* Non-standard registers ***************************************************/
+#define SBD_CELL14_VOLTAGE            0x32
+#define SBD_CELL13_VOLTAGE            0x33
+#define SBD_CELL12_VOLTAGE            0x34
+#define SBD_CELL11_VOLTAGE            0x35
+#define SBD_CELL10_VOLTAGE            0x36
+#define SBD_CELL9_VOLTAGE             0x37
+#define SBD_CELL8_VOLTAGE             0x38
+#define SBD_CELL7_VOLTAGE             0x39
+#define SBD_CELL6_VOLTAGE             0x3a
+#define SBD_CELL5_VOLTAGE             0x3b
+#define SBD_CELL4_VOLTAGE             0x3c
+#define SBD_CELL3_VOLTAGE             0x3d
+#define SBD_CELL2_VOLTAGE             0x3e
+#define SBD_CELL1_VOLTAGE             0x3f
+
+/****************************************************************************
+ * Public Type Definitions
+ ****************************************************************************/
+
+/* Battery data */
+
+struct smbus_sbd_data_s
+{
+  uint16_t temperature;              /* 0.1  K,       0 <->  6,553.5  K */
+  uint16_t voltage;                  /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t current;                  /* 1.0 mA, -32,767 <-> 32,767.0 mA */
+  uint16_t average_current;          /* 1.0 mA, -32,767 <-> 32,767.0 mA */
+  uint16_t max_error;                /* 1.0  %,       0 <->    100.0  % */
+  uint16_t relative_state_of_charge; /* 1.0  %,       0 <->    100.0  % */
+  uint16_t absolute_state_of_charge; /* 1.0  %,       0 <->    100.0  % */
+  uint16_t remaining_capacity;       /* 1.0 mAh,      0 <-> 65,535.0 mAh */
+  uint16_t full_charge_capacity;     /* 1.0 mAh,      0 <-> 65,535.0 mAh */
+  uint16_t run_time_to_empty;        /* 1.0 min,      0 <-> 65,535.0 min */
+  uint16_t average_time_to_empty;    /* 1.0 min,      0 <-> 65,535.0 min */
+
+  uint16_t cycle_count;              /* 1.0 cycle,    0 <-> 65,535.0 cycles */
+  uint16_t design_capacity;          /* 1.0 mAh,      0 <-> 65,535.0 mAh */
+  uint16_t design_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t manufacture_date;         /* (year-1980)*512 + month*32 + day */
+  uint16_t serial_number;
+  const char *manufacturer_name;
+  const char *device_name;
+  const char *device_chemistry;
+  const uint8_t *manufacturer_data;
+  uint8_t manufacturer_data_length;
+
+  uint16_t cell1_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell2_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell3_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell4_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell5_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell6_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell7_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell8_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell9_voltage;            /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell10_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell11_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell12_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell13_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+  uint16_t cell14_voltage;           /* 1.0 mV,       0 <-> 65,535.0 mV */
+};
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+#undef EXTERN
+#if defined(__cplusplus)
+#define EXTERN extern "C"
+extern "C"
+{
+#else
+#define EXTERN extern
+#endif
+
+/****************************************************************************
+ * Name: smbus_sbd_initialize
+ *
+ * Description:
+ *   Create and register a SMBus Smart Battery Data character driver.
+ *
+ *   This SMBus Smart Battery Data slave character driver supports (a subset
+ *   of) the Smart Battery Data Specification, Revision 1.1.  This driver
+ *   provides a buffer to the I2C slave driver.  This buffer can be updated
+ *   at regular intervals by a user-space application.
+ *
+ * Input Parameters:
+ *   minor         - The SMBus Smart Battery Data slave character device will
+ *                   be registered as /dev/smbus-sbdN where N is the
+ *                   minor number
+ *   i2c_slave_dev - An instance of the lower half I2C slave driver
+ *
+ * Returned Value:
+ *   OK if the driver was successfully registered; A negated errno value is
+ *   returned on any failure.
+ *
+ ****************************************************************************/
+
+int smbus_sbd_initialize(int minor, struct i2c_slave_s *i2c_slave_dev);
+
+#undef EXTERN
+#if defined(__cplusplus)
+}
+#endif
+
+#endif /* CONFIG_SMBUS_SBD */
+#endif /* __BOARDS_ARM_S32K1XX_MR_BMS771_INCLUDE_SMBUS_SBD_H */
diff --git a/boards/arm/s32k1xx/mr-bms771/scripts/Make.defs b/boards/arm/s32k1xx/mr-bms771/scripts/Make.defs
new file mode 100644
index 0000000000..99d43455d8
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/scripts/Make.defs
@@ -0,0 +1,49 @@
+############################################################################
+# boards/arm/s32k1xx/mr-bms771/scripts/Make.defs
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.  The
+# ASF licenses this file to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance with the
+# License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+# License for the specific language governing permissions and limitations
+# under the License.
+#
+############################################################################
+
+# Copyright 2022-2025 NXP
+
+include $(TOPDIR)/.config
+include $(TOPDIR)/tools/Config.mk
+include $(TOPDIR)/arch/arm/src/armv7-m/Toolchain.defs
+
+ifeq ($(CONFIG_BOOT_RUNFROMFLASH),y)
+ LDSCRIPT = flash.ld
+else ifeq ($(CONFIG_BOOT_RUNFROMISRAM),y)
+ LDSCRIPT = sram.ld
+endif
+
+$(warning, LDSCRIPT is $(LDSCRIPT))
+ARCHSCRIPT += $(BOARD_DIR)$(DELIM)scripts$(DELIM)$(LDSCRIPT)
+$(warning, LDSCRIPT is $(LDSCRIPT))
+$(warning, ARCHSCRIPT is $(ARCHSCRIPT))
+
+ARCHPICFLAGS = -fpic -msingle-pic-base -mpic-register=r10
+
+CFLAGS := $(ARCHCFLAGS) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CPICFLAGS = $(ARCHPICFLAGS) $(CFLAGS)
+CXXFLAGS := $(ARCHCXXFLAGS) $(ARCHOPTIMIZATION) $(ARCHCPUFLAGS) $(ARCHXXINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS) -pipe
+CXXPICFLAGS = $(ARCHPICFLAGS) $(CXXFLAGS)
+CPPFLAGS := $(ARCHINCLUDES) $(ARCHDEFINES) $(EXTRAFLAGS)
+AFLAGS := $(CFLAGS) -D__ASSEMBLY__
+
+NXFLATLDFLAGS1 = -r -d -warn-common
+NXFLATLDFLAGS2 = $(NXFLATLDFLAGS1) -T$(TOPDIR)/binfmt/libnxflat/gnu-nxflat-pcrel.ld -no-check-sections
+LDNXFLATFLAGS = -e main -s 2048
diff --git a/boards/arm/s32k1xx/mr-bms771/scripts/flash.ld b/boards/arm/s32k1xx/mr-bms771/scripts/flash.ld
new file mode 100644
index 0000000000..a92149b51a
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/scripts/flash.ld
@@ -0,0 +1,139 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/scripts/flash.ld
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/* The S32K146 has 1Mb of FLASH beginning at address 0x0000:0000 and
+ * 124Kb of SRAM beginning at address 0x1fff:0000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff0000 - 1fffffff 64Kb
+ *   SRAM_U 20000000 - 2000efff 60Kb
+ */
+
+MEMORY
+{
+  vflash (rx) : ORIGIN = 0x00000000, LENGTH = 1K
+  pflash (rx) : ORIGIN = 0x00000400, LENGTH = 16
+  dflash (rx) : ORIGIN = 0x00000410, LENGTH = 1023K-16
+  sram  (rwx) : ORIGIN = 0x1fff0000, LENGTH = 124K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+EXTERN(g_flashcfg)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .vectors :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+  } > vflash
+
+  .flashcfg :
+  {
+    *(.flashcfg)
+  } > pflash
+
+  .text :
+  {
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > dflash
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    KEEP(*(.init_array .init_array.*))
+    _einit = ABSOLUTE(.);
+  } > dflash
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >dflash
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >dflash
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _eronly = LOADADDR(.data);
+
+  .ramfunc ALIGN(4):
+  {
+    _sramfuncs = ABSOLUTE(.);
+    *(.ramfunc  .ramfunc.*)
+    _eramfuncs = ABSOLUTE(.);
+  } > sram AT > dflash
+
+  _framfuncs = LOADADDR(.ramfunc);
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/mr-bms771/scripts/mr-bms771.jlink b/boards/arm/s32k1xx/mr-bms771/scripts/mr-bms771.jlink
new file mode 100644
index 0000000000..81e0dc7323
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/scripts/mr-bms771.jlink
@@ -0,0 +1,21 @@
+//
+// Copyright 2023-2025 NXP
+//
+// J-Link Command File for connecting to MR-BMS771 with a J-Link debugger and flashing a compiled NuttX binary.
+//
+// The script can be executed by entering the command: JLinkExe -CommandFile mr-bms771.jlink
+// Note that the current working directory needs to be /boards/arm/s32k1xx/mr-bms771/scripts/ 
+//
+
+usb
+si SWD
+speed 1000
+device S32K146
+connect
+r
+w1 0x40020007, 0x44 // Reset entire flash, including the area used for the Emulated EEPROM functionality,
+w1 0x40020000, 0x80 // which may be used to store application parameters.  Avoids issues when upgrading firmware.
+sleep 1000
+loadbin ../../../../../nuttx.bin, 0x00
+r
+qc
diff --git a/boards/arm/s32k1xx/mr-bms771/scripts/s32k146.cfg b/boards/arm/s32k1xx/mr-bms771/scripts/s32k146.cfg
new file mode 100644
index 0000000000..d1a7e68388
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/scripts/s32k146.cfg
@@ -0,0 +1,61 @@
+#
+# Copyright 2022-2025 NXP
+#
+# NXP S32K146 - 1x ARM Cortex-M4 @ up to 80/112 MHz
+#
+
+# May be increased to 4000 if the programmer allows
+adapter_khz 1000
+transport select swd
+
+if { [info exists CHIPNAME] } {
+	set _CHIPNAME $CHIPNAME
+} else {
+	set _CHIPNAME s32k146
+}
+
+#
+# M4 JTAG mode TAP
+#
+if { [info exists M4_JTAG_TAPID] } {
+	set _M4_JTAG_TAPID $M4_JTAG_TAPID
+} else {
+	set _M4_JTAG_TAPID 0x4ba00477
+}
+
+#
+# M4 SWD mode TAP
+#
+if { [info exists M4_SWD_TAPID] } {
+	set _M4_SWD_TAPID $M4_SWD_TAPID
+} else {
+	set _M4_SWD_TAPID 0x2ba01477
+}
+
+source [find target/swj-dp.tcl]
+
+if { [using_jtag] } {
+	set _M4_TAPID $_M4_JTAG_TAPID
+} else {
+	set _M4_TAPID $_M4_SWD_TAPID
+}
+
+swj_newdap $_CHIPNAME m4 -irlen 4 -ircapture 0x1 -irmask 0xf \
+				-expected-id $_M4_TAPID
+
+target create $_CHIPNAME.m4 cortex_m -chain-position $_CHIPNAME.m4
+
+# S32K146 has 64+60 KB contiguous SRAM
+if { [info exists WORKAREASIZE] } {
+	set _WORKAREASIZE $WORKAREASIZE
+} else {
+	set _WORKAREASIZE 0x1F000
+}
+$_CHIPNAME.m4 configure -work-area-phys 0x1FFF0000 \
+                        -work-area-size $_WORKAREASIZE -work-area-backup 0
+
+$_CHIPNAME.m4 configure -rtos nuttx
+
+if { ![using_hla] } {
+	cortex_m reset_config vectreset
+}
diff --git a/boards/arm/s32k1xx/mr-bms771/scripts/sram.ld b/boards/arm/s32k1xx/mr-bms771/scripts/sram.ld
new file mode 100644
index 0000000000..e870a3b74d
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/scripts/sram.ld
@@ -0,0 +1,116 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/scripts/sram.ld
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/* The S32K146 has 1Mb of FLASH beginning at address 0x0000:0000 and
+ * 124Kb of SRAM beginning at address 0x1fff:0000 (plus 4Kb of FlexRAM)
+ *
+ * The on-chip RAM is split in two regions: SRAM_L and SRAM_U. The RAM is
+ * implemented such that the SRAM_L and SRAM_U ranges form a contiguous
+ * block in the memory map
+ *
+ *   SRAM_L 1fff0000 - 1fffffff 64Kb
+ *   SRAM_U 20000000 - 2000efff 60Kb
+ */
+
+MEMORY
+{
+  flash (rx)  : ORIGIN = 0x00000000, LENGTH = 1M
+  sram  (rwx) : ORIGIN = 0x1fff0000, LENGTH = 124K
+}
+
+OUTPUT_ARCH(arm)
+EXTERN(_vectors)
+ENTRY(_stext)
+
+SECTIONS
+{
+  .text :
+  {
+    _stext = ABSOLUTE(.);
+    *(.vectors)
+    *(.text .text.*)
+    *(.fixup)
+    *(.gnu.warning)
+    *(.rodata .rodata.*)
+    *(.gnu.linkonce.t.*)
+    *(.glue_7)
+    *(.glue_7t)
+    *(.got)
+    *(.gcc_except_table)
+    *(.gnu.linkonce.r.*)
+    _etext = ABSOLUTE(.);
+  } > sram
+
+  .init_section :
+  {
+    _sinit = ABSOLUTE(.);
+    KEEP(*(.init_array .init_array.*))
+    _einit = ABSOLUTE(.);
+  } > sram
+
+  .ARM.extab :
+  {
+    *(.ARM.extab*)
+  } >sram
+
+  .ARM.exidx :
+  {
+    __exidx_start = ABSOLUTE(.);
+    *(.ARM.exidx*)
+    __exidx_end = ABSOLUTE(.);
+  } >sram
+
+  .data :
+  {
+    _sdata = ABSOLUTE(.);
+    *(.data .data.*)
+    *(.gnu.linkonce.d.*)
+    CONSTRUCTORS
+    . = ALIGN(4);
+    _edata = ABSOLUTE(.);
+  } > sram
+
+  .bss :
+  {
+    _sbss = ABSOLUTE(.);
+    *(.bss .bss.*)
+    *(.gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN(4);
+    _ebss = ABSOLUTE(.);
+  } > sram
+
+  /* Stabs debugging sections. */
+
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  .debug_abbrev 0 : { *(.debug_abbrev) }
+  .debug_info 0 : { *(.debug_info) }
+  .debug_line 0 : { *(.debug_line) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  .debug_aranges 0 : { *(.debug_aranges) }
+}
diff --git a/boards/arm/s32k1xx/mr-bms771/src/Makefile b/boards/arm/s32k1xx/mr-bms771/src/Makefile
new file mode 100644
index 0000000000..ee239a0c3e
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/Makefile
@@ -0,0 +1,70 @@
+############################################################################
+# boards/arm/s32k1xx/mr-bms771/src/Makefile
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.  The
+# ASF licenses this file to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance with the
+# License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+# License for the specific language governing permissions and limitations
+# under the License.
+#
+############################################################################
+
+# Copyright 2022-2025 NXP
+
+include $(TOPDIR)/Make.defs
+
+CSRCS  = s32k1xx_boot.c s32k1xx_bringup.c s32k1xx_clockconfig.c
+CSRCS += s32k1xx_periphclocks.c
+
+ifeq ($(CONFIG_ARCH_LEDS),y)
+CSRCS += s32k1xx_autoleds.c
+else
+CSRCS += s32k1xx_userleds.c
+endif
+
+ifeq ($(CONFIG_BOARDCTL),y)
+CSRCS += s32k1xx_appinit.c
+endif
+
+ifeq ($(CONFIG_BOARDCTL_RESET),y)
+CSRCS += s32k1xx_reset.c
+endif
+
+ifeq ($(CONFIG_BOARDCTL_UNIQUEID),y)
+CSRCS += s32k1xx_uid.c
+endif
+
+ifeq ($(CONFIG_DEV_GPIO),y)
+CSRCS += s32k1xx_gpio.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_LPI2C),y)
+CSRCS += s32k1xx_i2c.c
+endif
+
+ifeq ($(CONFIG_LCD_SSD1306_I2C),y)
+CSRCS += s32k1xx_ssd1306.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_LPSPI),y)
+CSRCS += s32k1xx_spi.c
+endif
+
+ifeq ($(CONFIG_S32K1XX_NRSTCHECK_PROCFS),y)
+CSRCS += s32k1xx_nrstcheck_procfs.c
+endif
+
+ifeq ($(CONFIG_SMBUS_SBD),y)
+CSRCS += s32k1xx_smbus_sbd.c
+endif
+
+include $(TOPDIR)/boards/Board.mk
diff --git a/boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h b/boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h
new file mode 100644
index 0000000000..5663ca7dbb
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h
@@ -0,0 +1,162 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/mr-bms771.h
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+#ifndef __BOARDS_ARM_S32K1XX_MR_BMS771_SRC_MR_BMS771_H
+#define __BOARDS_ARM_S32K1XX_MR_BMS771_SRC_MR_BMS771_H
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <stdint.h>
+
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_periphclocks.h"
+#include "s32k1xx_pin.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+/* MR-BMS771 GPIOs *****************************************************/
+
+/* LEDs.  The MR-BMS771 has one RGB LED:
+ *
+ *   RedLED    PTD16  (FTM0 CH1)
+ *   GreenLED  PTB13  (FTM0 CH1)
+ *   BlueLED   PTD15  (FTM0 CH0)
+ *
+ * An output of '0' illuminates the LED.
+ */
+
+#define GPIO_LED_R  (PIN_PTD16 | GPIO_LOWDRIVE | GPIO_OUTPUT_ONE)
+#define GPIO_LED_G  (PIN_PTB13 | GPIO_LOWDRIVE | GPIO_OUTPUT_ONE)
+#define GPIO_LED_B  (PIN_PTD15 | GPIO_LOWDRIVE | GPIO_OUTPUT_ONE)
+
+/* GPIO pins to be registered to the GPIO driver.  These definitions need to
+ * be added to the g_gpiopins array in s32k1xx_gpio.c!
+ */
+
+#define GPIO0       (PIN_PTC1  | GPIO_OUTPUT) /* GATE_CTRL_CP */
+#define GPIO1       (PIN_PTC2  | GPIO_OUTPUT) /* GATE_CTRL_D */
+#define GPIO2       (PIN_PTD5  | GPIO_OUTPUT) /* BCC_RESET */
+#define GPIO3       (PIN_PTE10 | GPIO_OUTPUT) /* NFC_HPD */
+#define GPIO4       (PIN_PTC15 | GPIO_OUTPUT) /* SE_RST_N */
+#define GPIO5       (PIN_PTC17 | GPIO_OUTPUT) /* SE_EN */
+#define GPIO6       (PIN_PTE3  | GPIO_OUTPUT) /* LED_CAN0 */
+#define GPIO7       (PIN_PTC8  | GPIO_OUTPUT) /* LED_CAN1 */
+#define GPIO8       (PIN_PTD4  | GPIO_OUTPUT) /* 12V_EXT_ON */
+#define GPIO9       (PIN_PTA6  | GPIO_OUTPUT) /* CAN1_EN */
+#define GPIO10      (PIN_PTB12 | GPIO_OUTPUT) /* CAN1_STB_N */
+
+#define GPIO11      (PIN_PTE8  | GPIO_INPUT | PIN_INT_BOTH) /* PTE8_SW_E_STOP */
+#define GPIO12      (PIN_PTC3  | GPIO_INPUT | PIN_INT_BOTH) /* OVERCURRENT */
+#define GPIO13      (PIN_PTC14 | GPIO_INPUT | PIN_INT_BOTH) /* BUTTON_WAKE_N */
+#define GPIO14      (PIN_PTC0  | GPIO_INPUT | PIN_INT_BOTH) /* CAN1_ERR_N */
+#define GPIO15      (PIN_PTA11 | GPIO_INPUT | PIN_INT_BOTH) /* SBC_LIMP */
+#define GPIO16      (PIN_PTC9  | GPIO_INPUT | PIN_INT_BOTH) /* BCC_FAULT */
+#define GPIO17      (PIN_PTE11 | GPIO_INPUT | PIN_INT_BOTH) /* NFC_ED */
+#define GPIO18      (PIN_PTE7  | GPIO_INPUT | PIN_INT_BOTH) /* E_FUSE_FLAG_N */
+
+#define NUM_OF_GPIO 19
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+#ifndef __ASSEMBLY__
+
+/* User peripheral configuration structure 0 */
+
+extern const struct peripheral_clock_config_s g_peripheral_clockconfig0[];
+
+/****************************************************************************
+ * Public Function Prototypes
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y && CONFIG_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void);
+
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void);
+
+/****************************************************************************
+ * Name: s32k1xx_i2cdev_initialize
+ *
+ * Description:
+ *   Initialize I2C driver and register /dev/i2cN devices.
+ *
+ ****************************************************************************/
+
+int s32k1xx_i2cdev_initialize(void);
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Configure chip select pins, initialize the SPI driver and register
+ *   /dev/spiN devices.
+ *
+ ****************************************************************************/
+
+int s32k1xx_spidev_initialize(void);
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_register
+ *
+ * Description:
+ *   Check if the (active low) reset pin is being pulled high externally by
+ *   reconfiguring the pin (temporarily) to a GPIO input with weak pull-down.
+ *   The pin state is saved and registered as a PROCFS entry.  The pin will
+ *   then be reconfigured again as reset pin.
+ *
+ ****************************************************************************/
+
+int s32k1xx_nrstcheck_procfs_register(void);
+
+#endif /* __ASSEMBLY__ */
+#endif /* __BOARDS_ARM_S32K1XX_MR_BMS771_SRC_MR_BMS771_H */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_appinit.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_appinit.c
new file mode 100644
index 0000000000..4f5184bb25
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_appinit.c
@@ -0,0 +1,82 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_appinit.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/board.h>
+
+#include <stdint.h>
+
+#include "mr-bms771.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#ifndef OK
+#  define OK 0
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_app_initialize
+ *
+ * Description:
+ *   Perform application specific initialization.  This function is never
+ *   called directly from application code, but only indirectly via the
+ *   (non-standard) boardctl() interface using the command BOARDIOC_INIT.
+ *
+ * Input Parameters:
+ *   arg - The boardctl() argument is passed to the board_app_initialize()
+ *         implementation without modification.  The argument has no meaning
+ *         to NuttX; the meaning of the argument is a contract between the
+ *         board-specific initialization logic and the matching application
+ *         logic.  The value could be such things as a mode enumeration
+ *         value, a set of DIP switch settings, a pointer to configuration
+ *         data read from a file or serial FLASH, or whatever you would like
+ *         to do with it.  Every implementation should accept zero/NULL as a
+ *         default configuration.
+ *
+ * Returned Value:
+ *   Zero (OK) is returned on success; a negated errno value is returned on
+ *   any failure to indicate the nature of the failure.
+ *
+ ****************************************************************************/
+
+int board_app_initialize(uintptr_t arg)
+{
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+  /* Board initialization already performed by board_late_initialize() */
+
+  return OK;
+#else
+  /* Perform board-specific initialization */
+
+  return s32k1xx_bringup();
+#endif
+}
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_autoleds.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_autoleds.c
new file mode 100644
index 0000000000..e1f1159706
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_autoleds.c
@@ -0,0 +1,150 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_autoleds.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/* The MR-BMS771 has one RGB LED:
+ *
+ *   RedLED    PTD16  (FTM0 CH1)
+ *   GreenLED  PTB13  (FTM0 CH1)
+ *   BlueLED   PTD15  (FTM0 CH0)
+ *
+ * An output of '0' illuminates the LED.
+ *
+ * If CONFIG_ARCH_LEDs is defined, then NuttX will control the LED on board
+ * the MR-BMS771.  The following definitions describe how NuttX controls
+ * the LEDs:
+ *
+ *   SYMBOL            Meaning                    LED state
+ *                                                RED    GREEN  BLUE
+ *   ----------------  ------------------------  --------------------
+ *   LED_STARTED       NuttX has been started     OFF    OFF    OFF
+ *   LED_HEAPALLOCATE  Heap has been allocated    OFF    OFF    ON
+ *   LED_IRQSENABLED   Interrupts enabled         OFF    OFF    ON
+ *   LED_STACKCREATED  Idle stack created         OFF    ON     OFF
+ *   LED_INIRQ         In an interrupt           (No change)
+ *   LED_SIGNAL        In a signal handler       (No change)
+ *   LED_ASSERTION     An assertion failed       (No change)
+ *   LED_PANIC         The system has crashed     FLASH  OFF    OFF
+ *   LED_IDLE          S32K146 is in sleep mode  (Optional, not used)
+ */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <nuttx/board.h>
+
+#include "s32k1xx_pin.h"
+
+#include "mr-bms771.h"
+
+#ifdef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Summary of all possible settings */
+
+#define LED_NOCHANGE     0 /* LED_IRQSENABLED, LED_INIRQ, LED_SIGNAL, LED_ASSERTION */
+#define LED_OFF_OFF_OFF  1 /* LED_STARTED */
+#define LED_OFF_OFF_ON   2 /* LED_HEAPALLOCATE */
+#define LED_OFF_ON_OFF   3 /* LED_STACKCREATED */
+#define LED_ON_OFF_OFF   4 /* LED_PANIC */
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_autoled_initialize
+ ****************************************************************************/
+
+void board_autoled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+}
+
+/****************************************************************************
+ * Name: board_autoled_on
+ ****************************************************************************/
+
+void board_autoled_on(int led)
+{
+  if (led != LED_NOCHANGE)
+    {
+      bool redon   = false;
+      bool greenon = false;
+      bool blueon  = false;
+
+      switch (led)
+        {
+          default:
+          case LED_OFF_OFF_OFF:
+            break;
+
+          case LED_OFF_OFF_ON:
+            blueon = true;
+            break;
+
+          case LED_OFF_ON_OFF:
+            greenon = true;
+            break;
+
+          case LED_ON_OFF_OFF:
+            redon = true;
+            break;
+        }
+
+      /* Invert output, an output of '0' illuminates the LED */
+
+      s32k1xx_gpiowrite(GPIO_LED_R, !redon);
+      s32k1xx_gpiowrite(GPIO_LED_G, !greenon);
+      s32k1xx_gpiowrite(GPIO_LED_B, !blueon);
+    }
+}
+
+/****************************************************************************
+ * Name: board_autoled_off
+ ****************************************************************************/
+
+void board_autoled_off(int led)
+{
+  if (led == LED_ON_OFF_OFF)
+    {
+      /* Invert outputs, an output of '0' illuminates the LED */
+
+      s32k1xx_gpiowrite(GPIO_LED_R, !true);
+      s32k1xx_gpiowrite(GPIO_LED_G, !false);
+      s32k1xx_gpiowrite(GPIO_LED_B, !false);
+    }
+}
+
+#endif /* CONFIG_ARCH_LEDS */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c
new file mode 100644
index 0000000000..5db70fe8d3
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c
@@ -0,0 +1,82 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_boot.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+#include <arch/board/board.h>
+#include "mr-bms771.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_board_initialize
+ *
+ * Description:
+ *   All S32K1XX architectures must provide the following entry point.  This
+ *   entry point is called early in the initialization -- after all memory
+ *   has been configured and mapped but before any devices have been
+ *   initialized.
+ *
+ ****************************************************************************/
+
+void s32k1xx_board_initialize(void)
+{
+#ifdef CONFIG_SEGGER_SYSVIEW
+  up_perf_init((void *)MR_BMS771_RUN_SYSCLK_FREQUENCY);
+#endif
+
+#ifdef CONFIG_ARCH_LEDS
+  /* Configure on-board LEDs if LED support has been selected */
+
+  board_autoled_initialize();
+#endif
+}
+
+/****************************************************************************
+ * Name: board_late_initialize
+ *
+ * Description:
+ *   If CONFIG_BOARD_LATE_INITIALIZE is selected, then an additional
+ *   initialization call will be performed in the boot-up sequence to a
+ *   function called board_late_initialize().  board_late_initialize() will
+ *   be called immediately after up_initialize() is called and just before
+ *   the initial application is started.  This additional initialization
+ *   phase may be used, for example, to initialize board-specific device
+ *   drivers.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_BOARD_LATE_INITIALIZE
+void board_late_initialize(void)
+{
+  /* Perform board-specific initialization */
+
+  s32k1xx_bringup();
+}
+#endif
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_bringup.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_bringup.c
new file mode 100644
index 0000000000..e6db05e065
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_bringup.c
@@ -0,0 +1,242 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_bringup.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <syslog.h>
+
+#ifdef CONFIG_USERLED
+#  include <nuttx/leds/userled.h>
+#endif
+
+#ifdef CONFIG_FS_PROCFS
+#  include <nuttx/fs/fs.h>
+
+#  ifdef CONFIG_S32K1XX_RESETCAUSE_PROCFS
+#    include "s32k1xx_resetcause_procfs.h"
+#  endif
+#endif
+
+#ifdef CONFIG_S32K1XX_PROGMEM
+#  include <nuttx/mtd/mtd.h>
+#endif
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+#  include "s32k1xx_eeeprom.h"
+#endif
+
+#ifdef CONFIG_SMBUS_SBD
+#  include <nuttx/i2c/i2c_slave.h>
+#  include "s32k1xx_lpi2c_slave.h"
+#  include <arch/board/smbus_sbd.h>
+#endif
+
+#ifdef CONFIG_S32K1XX_FLEXCAN
+#  include "s32k1xx_flexcan.h"
+#endif
+
+#ifdef CONFIG_VIDEO_FB
+#   include <nuttx/video/fb.h>
+#endif
+
+#include "mr-bms771.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_bringup
+ *
+ * Description:
+ *   Perform architecture-specific initialization
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=y :
+ *     Called from board_late_initialize().
+ *
+ *   CONFIG_BOARD_LATE_INITIALIZE=n && CONFIG_BOARDCTL=y :
+ *     Called from the NSH library
+ *
+ ****************************************************************************/
+
+int s32k1xx_bringup(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_USERLED
+  /* Register the LED driver */
+
+  ret = userled_lower_initialize("/dev/userleds");
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: userled_lower_initialize() failed: %d\n", ret);
+    }
+#endif
+
+#ifdef CONFIG_FS_PROCFS
+  /* Register procfs entries before mounting */
+
+#  ifdef CONFIG_S32K1XX_RESETCAUSE_PROCFS
+  ret = s32k1xx_resetcause_procfs_register();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR,
+             "ERROR: Failed to register MCU Reset Cause PROCFS entry: %d\n",
+             ret);
+    }
+#  endif /* CONFIG_S32K1XX_RESETCAUSE_PROCFS */
+
+#  ifdef CONFIG_S32K1XX_NRSTCHECK_PROCFS
+  ret = s32k1xx_nrstcheck_procfs_register();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR,
+             "ERROR: Failed to register nRST Check PROCFS entry: %d\n", ret);
+    }
+#  endif /* CONFIG_S32K1XX_NRSTCHECK_PROCFS */
+
+  /* Mount the procfs file system */
+
+  ret = nx_mount(NULL, "/proc", "procfs", 0, NULL);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to mount procfs at /proc: %d\n", ret);
+    }
+#endif /* CONFIG_FS_PROCFS */
+
+#ifdef CONFIG_DEV_GPIO
+  /* Initialize and register the GPIO driver */
+
+  ret = s32k1xx_gpio_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: Failed to initialize GPIO driver: %d\n", ret);
+    }
+#endif /* CONFIG_DEV_GPIO */
+
+#ifdef CONFIG_S32K1XX_PROGMEM
+  struct mtd_dev_s *mtd;
+
+  mtd = progmem_initialize();
+  if (mtd == NULL)
+    {
+      syslog(LOG_ERR, "ERROR: progmem_initialize() failed\n");
+    }
+#endif /* CONFIG_S32K1XX_PROGMEM */
+
+#ifdef CONFIG_S32K1XX_EEEPROM
+  /* Register EEEPROM block device */
+
+  ret = s32k1xx_eeeprom_register(0, 4096);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_eeeprom_register() failed\n");
+    }
+#endif /* CONFIG_S32K1XX_EEEPROM */
+
+#ifdef CONFIG_S32K1XX_LPI2C
+  /* Initialize I2C driver */
+
+  ret = s32k1xx_i2cdev_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_i2cdev_initialize() failed: %d\n",
+             ret);
+    }
+#endif /* CONFIG_S32K1XX_LPI2C */
+
+#ifdef CONFIG_VIDEO_FB
+  /* Register the framebuffer device for the display */
+
+  ret = fb_register(0, 0);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: fb_register() failed: %d\n", ret);
+    }
+#endif /* CONFIG_VIDEO_FB */
+
+#if defined(CONFIG_S32K1XX_LPI2C) && defined(CONFIG_I2C_SLAVE) && \
+    defined(CONFIG_SMBUS_SBD)
+  /* Initialize I2C slave device */
+
+  struct i2c_slave_s *lpi2c0_slave = s32k1xx_i2cbus_slave_initialize(0);
+  if (lpi2c0_slave == NULL)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_i2cbus_slave_initialize() failed\n");
+    }
+
+  /* Initialize a new SMBus Smart Battery Data slave device as
+   * /dev/smbus-sbd0
+   */
+
+  ret = smbus_sbd_initialize(0, lpi2c0_slave);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: smbus_sbd_initialize() failed: %d\n", ret);
+    }
+#endif /* CONFIG_S32K1XX_LPI2C && CONFIG_I2C_SLAVE && CONFIG_SMBUS_SBD */
+
+#ifdef CONFIG_S32K1XX_LPSPI
+  /* Initialize SPI driver */
+
+  ret = s32k1xx_spidev_initialize();
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_spidev_initialize() failed: %d\n",
+             ret);
+    }
+#endif /* CONFIG_S32K1XX_LPSPI */
+
+#ifdef CONFIG_NETDEV_LATEINIT
+#  ifdef CONFIG_S32K1XX_FLEXCAN0
+  /* Initialize FlexCAN0 driver */
+
+  ret = s32k1xx_caninitialize(0);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_caninitialize(0) failed: %d\n", ret);
+    }
+#  endif /* CONFIG_S32K1XX_FLEXCAN0 */
+#  ifdef CONFIG_S32K1XX_FLEXCAN1
+
+  /* STB high enables CAN phy on TJA1463ATK */
+
+  s32k1xx_pinconfig(PIN_CAN1_STB | GPIO_OUTPUT_ONE);
+  #warning is this OK?, maybe GPIO_OUTPUT_ZERO, maybe GPIO, maybe #else other polarity
+  /* Initialize FlexCAN1 driver */
+
+  ret = s32k1xx_caninitialize(1);
+  if (ret < 0)
+    {
+      syslog(LOG_ERR, "ERROR: s32k1xx_caninitialize(1) failed: %d\n", ret);
+    }
+#  endif /* CONFIG_S32K1XX_FLEXCAN1 */
+#endif /* CONFIG_NETDEV_LATEINIT */
+
+  return ret;
+}
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_clockconfig.c
new file mode 100644
index 0000000000..0f9159c2de
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_clockconfig.c
@@ -0,0 +1,181 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_clockconfig.c
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2025 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "s32k1xx_clockconfig.h"
+#include "s32k1xx_start.h"
+
+#include "mr-bms771.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial board clocking.
+ */
+
+const struct clock_configuration_s g_initial_clkconfig =
+{
+  .scg =
+  {
+    .sirc          =
+    {
+      .range       = SCG_SIRC_RANGE_HIGH,              /* RANGE - High range (8 MHz) */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,          /* SIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_4,         /* SIRCDIV2 */
+      .initialize  = true,                             /* Initialize */
+      .stopmode    = false,                            /* SIRCSTEN */
+      .lowpower    = true,                             /* SIRCLPEN */
+      .locked      = false,                            /* LK */
+    },
+    .firc          =
+    {
+      .range       = SCG_FIRC_RANGE_48M,               /* RANGE */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,          /* FIRCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DISABLE,          /* FIRCDIV2 */
+      .initialize  = false,                            /* Initialize */
+      .regulator   = false,                            /* FIRCREGOFF */
+      .locked      = false,                            /* LK */
+    },
+    .sosc          =
+    {
+      .mode        = SCG_SOSC_MONITOR_DISABLE,         /* SOSCCM */
+      .gain        = SCG_SOSC_GAIN_LOW,                /* HGO */
+      .range       = SCG_SOSC_RANGE_HIGH,              /* RANGE */
+      .extref      = SCG_SOSC_REF_OSC,                 /* EREFS */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,          /* SOSCDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DISABLE,          /* SOSCDIV2 */
+      .initialize  = true,                             /* Initialize */
+      .locked      = false,                            /* LK */
+    },
+    .spll          =
+    {
+      .mode        = SCG_SPLL_MONITOR_DISABLE,         /* SPLLCM */
+      .div1        = SCG_ASYNC_CLOCK_DISABLE,          /* SPLLDIV1 */
+      .div2        = SCG_ASYNC_CLOCK_DIV_BY_8,         /* SPLLDIV2 */
+      .prediv      = 4,                                /* PREDIV */
+      .mult        = 40,                               /* MULT */
+      .src         = 0,                                /* SOURCE */
+      .initialize  = true,                             /* Initialize */
+      .locked      = false,                            /* LK */
+    },
+    .rtc           =
+    {
+      .initialize  = true,                             /* Initialize */
+      .clkin       = 0,                                /* RTC_CLKIN */
+    },
+    .clockout      =
+    {
+      .source      = SCG_CLOCKOUT_SRC_FIRC,            /* SCG CLKOUTSEL */
+      .initialize  = false,                            /* Initialize */
+    },
+    .clockmode     =
+    {
+      .rccr        =                                   /* RCCR - Run Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL,     /* SCS */
+        .divslow   = 3,                                /* DIVSLOW, range 1..16 */
+        .divbus    = 2,                                /* DIVBUS, range 1..16 */
+        .divcore   = 2,                                /* DIVCORE, range 1..16 */
+      },
+      .vccr        =                                   /* VCCR - VLPR Clock Control Register */
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SIRC,        /* SCS */
+        .divslow   = 4,                                /* DIVSLOW, range 1..16 */
+        .divbus    = 1,                                /* DIVBUS, range 1..16 */
+        .divcore   = 2,                                /* DIVCORE, range 1..16 */
+      },
+      .hccr        =
+      {
+        .src       = SCG_SYSTEM_CLOCK_SRC_SYS_PLL,     /* SCS */
+        .divslow   = 3,                                /* DIVSLOW, range 1..16 */
+        .divbus    = 2,                                /* DIVBUS, range 1..16 */
+        .divcore   = 2,                                /* DIVCORE, range 1..16 */
+      },
+      .initialize  = true,                             /* Initialize */
+    },
+  },
+  .sim             =
+  {
+    .clockout      =                                   /* Clock Out configuration. */
+    {
+      .source      = SIM_CLKOUT_SEL_SYSTEM_SCG_CLKOUT, /* CLKOUTSEL */
+      .divider     = 1,                                /* CLKOUTDIV, range 1..8 */
+      .initialize  = false,                            /* Initialize */
+      .enable      = false,                            /* CLKOUTEN */
+    },
+    .lpoclk        =                                   /* Low Power Clock configuration. */
+    {
+      .rtc_source  = SIM_RTCCLK_SEL_LPO_32K,           /* RTCCLKSEL */
+      .lpo_source  = SIM_LPO_CLK_SEL_LPO_128K,         /* LPOCLKSEL */
+      .initialize  = true,                             /* Initialize */
+      .lpo32k      = true,                             /* LPO32KCLKEN */
+      .lpo1k       = true,                             /* LPO1KCLKEN */
+    },
+    .tclk          =                                   /* TCLK CLOCK configuration. */
+    {
+      .tclkfreq[0] = 0,                                /* TCLK0 */
+      .tclkfreq[1] = 0,                                /* TCLK1 */
+      .tclkfreq[2] = 0,                                /* TCLK2 */
+      .initialize  = true,                             /* Initialize */
+    },
+    .platgate      =                                   /* Platform Gate Clock configuration. */
+    {
+      .initialize  = true,                             /* Initialize */
+      .mscm        = true,                             /* CGCMSCM */
+      .mpu         = true,                             /* CGCMPU */
+      .dma         = true,                             /* CGCDMA */
+      .erm         = true,                             /* CGCERM */
+      .eim         = true,                             /* CGCEIM */
+    },
+    .traceclk      =                                   /* Debug trace Clock Configuration. */
+    {
+      .source      = CLOCK_TRACE_SRC_CORE_CLK,         /* TRACECLK_SEL */
+      .divider     = 1,                                /* TRACEDIV, range 1..8 */
+      .initialize  = true,                             /* Initialize */
+      .enable      = true,                             /* TRACEDIVEN */
+      .fraction    = false,                            /* TRACEFRAC */
+    },
+  },
+  .pcc             =
+  {
+    .pclks         = g_peripheral_clockconfig0,        /* Peripheral clock configurations */
+  },
+  .pmc             =
+  {
+    .lpoclk        =                                   /* Low Power Clock configuration. */
+    {
+      .trim        = 0,                                /* Trimming value for LPO */
+      .initialize  = true,                             /* Initialize */
+      .enable      = true,                             /* Enable/disable LPO */
+    },
+  },
+};
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c
new file mode 100644
index 0000000000..5ea1e7f3d6
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c
@@ -0,0 +1,494 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_gpio.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <sys/types.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <assert.h>
+#include <debug.h>
+#include <errno.h>
+
+#include <nuttx/ioexpander/gpio.h>
+
+#include "s32k1xx_pin.h"
+
+#include "mr-bms771.h"
+
+#if defined(CONFIG_DEV_GPIO) && !defined(CONFIG_GPIO_LOWER_HALF)
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+struct s32k1xx_gpio_dev_s
+{
+  struct gpio_dev_s gpio;
+  uint8_t id;
+  pin_interrupt_t callback;
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+static int s32k1xx_gpio_interrupt(int irq, void *context, void *arg);
+
+static int gpio_read(struct gpio_dev_s *dev, bool *value);
+static int gpio_write(struct gpio_dev_s *dev, bool value);
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+static int gpio_irqattach(struct gpio_dev_s *dev, pin_interrupt_t callback);
+static int gpio_irqenable(struct gpio_dev_s *dev, bool enable);
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+static int gpio_setpintype(struct gpio_dev_s *dev,
+                           enum gpio_pintype_e pintype);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* Set of GPIO pins */
+
+static uint32_t g_gpiopins[] =
+{
+  GPIO0,
+  GPIO1,
+  GPIO2,
+  GPIO3,
+  GPIO4,
+  GPIO5,
+  GPIO6,
+  GPIO7,
+  GPIO8,
+  GPIO9,
+  GPIO10,
+  GPIO11,
+  GPIO12,
+  GPIO13,
+  GPIO14,
+  GPIO15,
+  GPIO16,
+  GPIO17,
+  GPIO18,
+};
+
+#if NUM_OF_GPIO > 0
+static struct s32k1xx_gpio_dev_s g_gpio[NUM_OF_GPIO];
+#endif
+
+/* Different pin types support different operations */
+
+static const struct gpio_operations_s gpin_ops =
+{
+  .go_read       = gpio_read,
+  .go_write      = NULL,
+  .go_attach     = NULL,
+  .go_enable     = NULL,
+  .go_setpintype = gpio_setpintype,
+};
+
+static const struct gpio_operations_s gpout_ops =
+{
+  .go_read       = gpio_read,
+  .go_write      = gpio_write,
+  .go_attach     = NULL,
+  .go_enable     = NULL,
+  .go_setpintype = gpio_setpintype,
+};
+
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+static const struct gpio_operations_s gpint_ops =
+{
+  .go_read       = gpio_read,
+  .go_write      = NULL,
+  .go_attach     = gpio_irqattach,
+  .go_enable     = gpio_irqenable,
+  .go_setpintype = gpio_setpintype,
+};
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+static int s32k1xx_gpio_interrupt(int irq, void *context, void *arg)
+{
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)arg;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && s32k1xx_gpio->callback != NULL);
+  gpioinfo("Interrupt! callback=%p\n", s32k1xx_gpio->callback);
+
+  s32k1xx_gpio->callback(&s32k1xx_gpio->gpio, s32k1xx_gpio->id);
+  return OK;
+}
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+
+static int gpio_read(struct gpio_dev_s *dev, bool *value)
+{
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL && value != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO);
+  gpioinfo("Reading...\n");
+
+  *value = s32k1xx_gpioread(g_gpiopins[s32k1xx_gpio->id]);
+  return OK;
+}
+
+static int gpio_write(struct gpio_dev_s *dev, bool value)
+{
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO);
+  gpioinfo("Writing %d\n", (int) value);
+
+  s32k1xx_gpiowrite(g_gpiopins[s32k1xx_gpio->id], value);
+  return OK;
+}
+
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+static int gpio_irqattach(struct gpio_dev_s *dev, pin_interrupt_t callback)
+{
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)dev;
+
+  gpioinfo("Attaching the callback\n");
+  s32k1xx_pinirqattach(g_gpiopins[s32k1xx_gpio->id], s32k1xx_gpio_interrupt,
+                       &g_gpio[s32k1xx_gpio->id]);
+
+  gpioinfo("Attach %p\n", callback);
+  s32k1xx_gpio->callback = callback;
+  return OK;
+}
+
+static int gpio_irqenable(struct gpio_dev_s *dev, bool enable)
+{
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+
+  if (enable)
+    {
+      if (s32k1xx_gpio->callback != NULL)
+        {
+          gpioinfo("Enabling the interrupt\n");
+          s32k1xx_pinirqenable(g_gpiopins[s32k1xx_gpio->id]);
+        }
+    }
+  else
+    {
+      gpioinfo("Disable the interrupt\n");
+      s32k1xx_pinirqdisable(g_gpiopins[s32k1xx_gpio->id]);
+    }
+
+  return OK;
+}
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+
+static int gpio_setpintype(struct gpio_dev_s *dev,
+                           enum gpio_pintype_e pintype)
+{
+  int ret = OK;
+  uint32_t pinconfig;
+  const struct gpio_operations_s *gpio_ops;
+  struct s32k1xx_gpio_dev_s *s32k1xx_gpio = (struct s32k1xx_gpio_dev_s *)dev;
+
+  DEBUGASSERT(s32k1xx_gpio != NULL);
+  DEBUGASSERT(s32k1xx_gpio->id < NUM_OF_GPIO);
+  gpioinfo("Setpintype...\n");
+
+  /* Check if the new pintype is actually different from the old pintype */
+
+  if (s32k1xx_gpio->gpio.gp_pintype == pintype)
+    {
+      /* Pintype has not changed. We're done already. */
+
+      return ret;
+    }
+
+  /* Clear the pin mode, pin options and interrupt options */
+
+  pinconfig = (g_gpiopins[s32k1xx_gpio->id] &
+              ~(_PIN_MODE_MASK | _PIN_OPTIONS_MASK | _PIN_INT_MASK));
+
+  /* Set the pinconfig and device operations according to the new pintype */
+
+  switch (pintype)
+    {
+      case GPIO_INPUT_PIN:
+        {
+          pinconfig |= GPIO_INPUT;
+          gpio_ops = &gpin_ops;
+        }
+        break;
+
+      case GPIO_INPUT_PIN_PULLUP:
+        {
+          pinconfig |= GPIO_PULLUP;
+          gpio_ops = &gpin_ops;
+        }
+        break;
+
+      case GPIO_INPUT_PIN_PULLDOWN:
+        {
+          pinconfig |= GPIO_PULLDOWN;
+          gpio_ops = &gpin_ops;
+        }
+        break;
+
+      case GPIO_OUTPUT_PIN:
+        {
+          pinconfig |= GPIO_OUTPUT;
+          gpio_ops = &gpout_ops;
+        }
+        break;
+
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+      case GPIO_INTERRUPT_HIGH_PIN:
+        {
+          pinconfig |= (GPIO_INPUT | PIN_INT_ONE);
+          gpio_ops = &gpint_ops;
+        }
+        break;
+
+      case GPIO_INTERRUPT_LOW_PIN:
+        {
+          pinconfig |= (GPIO_INPUT | PIN_INT_ZERO);
+          gpio_ops = &gpint_ops;
+        }
+        break;
+
+      case GPIO_INTERRUPT_RISING_PIN:
+        {
+          pinconfig |= (GPIO_INPUT | PIN_INT_RISING);
+          gpio_ops = &gpint_ops;
+        }
+        break;
+
+      case GPIO_INTERRUPT_FALLING_PIN:
+        {
+          pinconfig |= (GPIO_INPUT | PIN_INT_FALLING);
+          gpio_ops = &gpint_ops;
+        }
+        break;
+
+      case GPIO_INTERRUPT_BOTH_PIN:
+      case GPIO_INTERRUPT_PIN:
+        {
+          pinconfig |= (GPIO_INPUT | PIN_INT_BOTH);
+          gpio_ops = &gpint_ops;
+        }
+        break;
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+
+      default:
+        {
+          /* Not implemented yet! */
+
+          return -EINVAL; /* Return without changing the pin settings */
+        }
+        break;
+    }
+
+#ifdef CONFIG_S32K1XX_GPIOIRQ
+  /* If the pin previously had an interrupt pintype... */
+
+  if ((s32k1xx_gpio->gpio.gp_pintype >= GPIO_INTERRUPT_PIN) &&
+      (s32k1xx_gpio->gpio.gp_pintype < GPIO_NPINTYPES))
+    {
+      /* ...disable the interrupt... */
+
+      ret = gpio_irqenable(dev, false);
+      if (ret < 0)
+        {
+          return ret;
+        }
+
+      /* ...and detach the old callback. */
+
+      ret = gpio_irqattach(dev, NULL);
+      if (ret < 0)
+        {
+          return ret;
+        }
+    }
+#endif /* CONFIG_S32K1XX_GPIOIRQ */
+
+  /* Change the pintype and set of operations */
+
+  s32k1xx_gpio->gpio.gp_pintype = pintype;
+  s32k1xx_gpio->gpio.gp_ops = gpio_ops;
+
+  /* Reconfigure the actual pin */
+
+  g_gpiopins[s32k1xx_gpio->id] = pinconfig;
+  ret = s32k1xx_pinconfig(pinconfig);
+
+  return ret;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_gpio_initialize
+ *
+ * Description:
+ *   Initialize GPIO drivers for use with /apps/examples/gpio
+ *
+ ****************************************************************************/
+
+int s32k1xx_gpio_initialize(void)
+{
+  int ret = OK;
+
+#if NUM_OF_GPIO > 0
+  int i;
+  uint32_t pinset;
+
+  for (i = 0; i < NUM_OF_GPIO; i++)
+    {
+      DEBUGASSERT((g_gpiopins[i] & (_PIN_MODE_MASK)) == _PIN_MODE_GPIO);
+
+      g_gpio[i].id = i;
+
+      /* Find which pin type we are dealing with */
+
+      pinset = g_gpiopins[i];
+
+      if ((pinset & (_PIN_IO_MASK)) == _PIN_INPUT)
+        {
+#  ifdef CONFIG_S32K1XX_GPIOIRQ
+          /* Input pin (with or without interrupt) */
+
+          if (pinset & (_PIN_INTERRUPT))
+            {
+              /* Interrupt pin */
+
+              g_gpio[i].gpio.gp_ops = &gpint_ops;
+
+              /* Determine specific interrupt pin type */
+
+              switch (pinset & (_PIN_INTERRUPT))
+                {
+                  case PIN_INT_ONE:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_HIGH_PIN;
+                    }
+                    break;
+
+                  case PIN_INT_ZERO:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_LOW_PIN;
+                    }
+                    break;
+
+                  case PIN_INT_RISING:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_RISING_PIN;
+                    }
+                    break;
+
+                  case PIN_INT_FALLING:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_FALLING_PIN;
+                    }
+                    break;
+
+                  case PIN_INT_BOTH:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_BOTH_PIN;
+                    }
+                    break;
+
+                  default:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INTERRUPT_PIN;
+                    }
+                    break;
+                }
+            }
+          else
+#  endif /* CONFIG_S32K1XX_GPIOIRQ */
+            {
+              /* Input pin without interrupt */
+
+              g_gpio[i].gpio.gp_ops = &gpin_ops;
+
+              /* Determine specific input pin type */
+
+              switch (pinset & (_PIN_INPUT_PULLMASK))
+                {
+                  case _PIN_INPUT_PULLUP:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INPUT_PIN_PULLUP;
+                    }
+                    break;
+
+                  case _PIN_INPUT_PULLDOWN:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INPUT_PIN_PULLDOWN;
+                    }
+                    break;
+
+                  default:
+                    {
+                      g_gpio[i].gpio.gp_pintype = GPIO_INPUT_PIN;
+                    }
+                    break;
+                }
+            }
+        }
+      else
+        {
+          /* Output pin */
+
+          g_gpio[i].gpio.gp_ops = &gpout_ops;
+          g_gpio[i].gpio.gp_pintype = GPIO_OUTPUT_PIN;
+        }
+
+      /* Configure and register the GPIO pin */
+
+      ret = s32k1xx_pinconfig(g_gpiopins[i]);
+      if (ret < 0)
+        {
+          return ret;
+        }
+
+      ret = gpio_pin_register(&g_gpio[i].gpio, i);
+      if (ret < 0)
+        {
+          return ret;
+        }
+    }
+#endif
+
+  return ret;
+}
+#endif /* CONFIG_DEV_GPIO && !CONFIG_GPIO_LOWER_HALF */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c
new file mode 100644
index 0000000000..b17a3c0c58
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c
@@ -0,0 +1,84 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_i2c.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/i2c/i2c_master.h>
+
+#include "s32k1xx_lpi2c.h"
+
+#include "mr-bms771.h"
+
+#if defined(CONFIG_S32K1XX_LPI2C) && defined(CONFIG_I2C_DRIVER)
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_i2cdev_initialize
+ *
+ * Description:
+ *   Initialize I2C driver and register /dev/i2cN devices.
+ *
+ ****************************************************************************/
+
+int weak_function s32k1xx_i2cdev_initialize(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_S32K1XX_LPI2C0
+  /* LPI2C0 *****************************************************************/
+
+  /* Initialize LPI2C0 */
+
+  struct i2c_master_s *lpi2c0 = s32k1xx_i2cbus_initialize(0);
+  if (lpi2c0 == NULL)
+    {
+      i2cerr("ERROR: FAILED to initialize LPI2C0\n");
+      return -ENODEV;
+    }
+
+  /* Register LPI2C0 character driver */
+
+  ret = i2c_register(lpi2c0, 0);
+  if (ret < 0)
+    {
+      i2cerr("ERROR: FAILED to register LPI2C0 driver\n");
+      return ret;
+    }
+#endif /* CONFIG_S32K1XX_LPI2C0 */
+
+  return ret;
+}
+
+#endif /* CONFIG_S32K1XX_LPI2C && CONFIG_I2C_DRIVER */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_nrstcheck_procfs.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_nrstcheck_procfs.c
new file mode 100644
index 0000000000..22168eab6d
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_nrstcheck_procfs.c
@@ -0,0 +1,329 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_nrstcheck_procfs.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/fs/fs.h>
+#include <nuttx/fs/procfs.h>
+#include <nuttx/kmalloc.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <assert.h>
+#include <errno.h>
+#include <stdio.h>
+#include <string.h>
+#include <fcntl.h>
+#include <debug.h>
+
+#include "hardware/s32k1xx_pinmux.h"
+#include "s32k1xx_pin.h"
+
+#include "mr-bms771.h"
+
+#ifdef CONFIG_S32K1XX_NRSTCHECK_PROCFS
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Determines the size of an intermediate buffer that must be large enough
+ * to handle the longest line generated by this logic.
+ */
+
+#define S32K1XX_NRSTCHECK_LINELEN 2
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* This structure describes one open "file" */
+
+struct s32k1xx_nrstcheck_procfs_file_s
+{
+  struct procfs_file_s base;            /* Base open file structure */
+  unsigned int linesize;                /* Number of valid characters in line[] */
+  char line[S32K1XX_NRSTCHECK_LINELEN]; /* Pre-allocated buffer for formatted lines */
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+static int s32k1xx_nrstcheck_procfs_open(struct file *filep,
+                                         const char *relpath, int oflags,
+                                         mode_t mode);
+static int s32k1xx_nrstcheck_procfs_close(struct file *filep);
+static ssize_t s32k1xx_nrstcheck_procfs_read(struct file *filep,
+                                             char *buffer, size_t buflen);
+static int s32k1xx_nrstcheck_procfs_dup(const struct file *oldp,
+                                        struct file *newp);
+static int s32k1xx_nrstcheck_procfs_stat(const char *relpath,
+                                         struct stat *buf);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+const struct procfs_operations s32k1xx_nrstcheck_procfs_ops =
+{
+  s32k1xx_nrstcheck_procfs_open,  /* open */
+  s32k1xx_nrstcheck_procfs_close, /* close */
+  s32k1xx_nrstcheck_procfs_read,  /* read */
+  NULL,                           /* write */
+  s32k1xx_nrstcheck_procfs_dup,   /* dup */
+  NULL,                           /* opendir */
+  NULL,                           /* closedir */
+  NULL,                           /* readdir */
+  NULL,                           /* rewinddir */
+  s32k1xx_nrstcheck_procfs_stat,  /* stat */
+};
+
+static const struct procfs_entry_s g_s32k1xx_nrstcheck_procfs =
+{
+  "nrstcheck", &s32k1xx_nrstcheck_procfs_ops
+};
+
+static bool g_s32k1xx_nrstcheck = false;
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_open
+ ****************************************************************************/
+
+static int s32k1xx_nrstcheck_procfs_open(struct file *filep,
+                                         const char *relpath, int oflags,
+                                         mode_t mode)
+{
+  struct s32k1xx_nrstcheck_procfs_file_s *attr;
+
+  finfo("Open '%s'\n", relpath);
+
+  /* PROCFS is read-only.  Any attempt to open with any kind of write
+   * access is not permitted.
+   *
+   * REVISIT:  Write-able proc files could be quite useful.
+   */
+
+  if ((oflags & O_WRONLY) != 0 || (oflags & O_RDONLY) == 0)
+    {
+      ferr("ERROR: Only O_RDONLY supported\n");
+      return -EACCES;
+    }
+
+  /* Allocate a container to hold the file attributes */
+
+  attr = kmm_zalloc(sizeof(struct s32k1xx_nrstcheck_procfs_file_s));
+  if (!attr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* Save the attributes as the open-specific state in filep->f_priv */
+
+  filep->f_priv = (void *)attr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_close
+ ****************************************************************************/
+
+static int s32k1xx_nrstcheck_procfs_close(struct file *filep)
+{
+  struct s32k1xx_nrstcheck_procfs_file_s *attr;
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (struct s32k1xx_nrstcheck_procfs_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Release the file attributes structure */
+
+  kmm_free(attr);
+  filep->f_priv = NULL;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_read
+ ****************************************************************************/
+
+static ssize_t s32k1xx_nrstcheck_procfs_read(struct file *filep,
+                                             char *buffer, size_t buflen)
+{
+  struct s32k1xx_nrstcheck_procfs_file_s *attr;
+  off_t offset;
+
+  finfo("buffer=%p buflen=%d\n", buffer, (int)buflen);
+
+  /* Recover our private data from the struct file instance */
+
+  attr = (struct s32k1xx_nrstcheck_procfs_file_s *)filep->f_priv;
+  DEBUGASSERT(attr);
+
+  /* Convert the nRST check outcome to a string and save the linesize in case
+   * we are re-entered with f_pos > 0
+   */
+
+  attr->linesize = snprintf(attr->line, S32K1XX_NRSTCHECK_LINELEN, "%d",
+                            (int)g_s32k1xx_nrstcheck);
+
+  /* Transfer the nRST check outcome to user receive buffer */
+
+  offset = filep->f_pos;
+
+  return procfs_memcpy(attr->line, attr->linesize, buffer, buflen, &offset);
+}
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_dup
+ *
+ * Description:
+ *   Duplicate open file data in the new file structure.
+ *
+ ****************************************************************************/
+
+static int s32k1xx_nrstcheck_procfs_dup(const struct file *oldp,
+                                        struct file *newp)
+{
+  struct s32k1xx_nrstcheck_procfs_file_s *oldattr;
+  struct s32k1xx_nrstcheck_procfs_file_s *newattr;
+
+  finfo("Dup %p->%p\n", oldp, newp);
+
+  /* Recover our private data from the old struct file instance */
+
+  oldattr = (struct s32k1xx_nrstcheck_procfs_file_s *)oldp->f_priv;
+  DEBUGASSERT(oldattr);
+
+  /* Allocate a new container to hold the task and attribute selection */
+
+  newattr = kmm_malloc(sizeof(struct s32k1xx_nrstcheck_procfs_file_s));
+  if (!newattr)
+    {
+      ferr("ERROR: Failed to allocate file attributes\n");
+      return -ENOMEM;
+    }
+
+  /* The copy the file attributes from the old attributes to the new */
+
+  memcpy(newattr, oldattr, sizeof(struct s32k1xx_nrstcheck_procfs_file_s));
+
+  /* Save the new attributes in the new file structure */
+
+  newp->f_priv = (void *)newattr;
+  return OK;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_stat
+ *
+ * Description: Return information about a file or directory
+ *
+ ****************************************************************************/
+
+static int s32k1xx_nrstcheck_procfs_stat(const char *relpath,
+                                         struct stat *buf)
+{
+  /* "nrstcheck" is the name for a read-only file */
+
+  memset(buf, 0, sizeof(struct stat));
+  buf->st_mode = S_IFREG | S_IROTH | S_IRGRP | S_IRUSR;
+  return OK;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_nrstcheck_procfs_register
+ *
+ * Description:
+ *   Check if the (active low) reset pin is being pulled high externally by
+ *   reconfiguring the pin (temporarily) to a GPIO input with weak pull-down.
+ *   The pin state is saved and registered as a PROCFS entry.  The pin will
+ *   then be reconfigured again as reset pin.
+ *
+ ****************************************************************************/
+
+int s32k1xx_nrstcheck_procfs_register(void)
+{
+  int ret;
+
+  /* Reconfigure the reset pin to GPIO input with weak pull-down enabled */
+
+  ret = s32k1xx_pinconfig(PIN_PTA5 | GPIO_PULLDOWN);
+  if (ret != OK)
+    {
+      ferr("ERROR: could not reconfigure nRST pin to GPIO input (pull-down):"
+           " %d\n", ret);
+      return ret;
+    }
+
+  /* Sleep for a small amount of time for the NRST pin to become low */
+  usleep(10);
+
+  /* Read the input level of the pin, which should be pulled high externally
+   * by a resistor or another IC
+   */
+
+  g_s32k1xx_nrstcheck = s32k1xx_gpioread(PIN_PTA5);
+
+  /* Reconfigure the reset pin to GPIO input with pull-up enabled, to avoid
+   * accidentally triggering a reset later
+   */
+
+  ret = s32k1xx_pinconfig(PIN_PTA5 | GPIO_PULLUP);
+  if (ret != OK)
+    {
+      ferr("ERROR: could not reconfigure nRST pin to GPIO input (pull-up):"
+           " %d\n", ret);
+      return ret;
+    }
+
+  /* Reconfigure to reset pin again */
+
+  ret = s32k1xx_pinconfig(PIN_RESET);
+  if (ret != OK)
+    {
+      ferr("ERROR: could not configure nRST pin: %d\n", ret);
+      return ret;
+    }
+
+  /* Register a PROCFS entry which contains the previously detected input
+   * state of the nRST pin
+   */
+
+  return procfs_register(&g_s32k1xx_nrstcheck_procfs);
+}
+
+#endif /* CONFIG_S32K1XX_NRSTCHECK_PROCFS */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_periphclocks.c
new file mode 100644
index 0000000000..feae3c845b
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_periphclocks.c
@@ -0,0 +1,148 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_periphclocks.c
+ *
+ *   Copyright (c) 2013 - 2015, Freescale Semiconductor, Inc.
+ *   Copyright 2016-2025 NXP
+ *   All rights reserved.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NXP "AS IS" AND ANY EXPRESSED OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL NXP OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include "s32k14x/s32k14x_clocknames.h"
+#include "s32k1xx_periphclocks.h"
+
+#include "mr-bms771.h"
+
+/****************************************************************************
+ * Public Data
+ ****************************************************************************/
+
+/* Each S32K1XX board must provide the following initialized structure.
+ * This is needed to establish the initial peripheral clocking.
+ */
+
+const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
+{
+  {
+    .clkname = DMAMUX0_CLK,
+#ifdef CONFIG_S32K1XX_EDMA
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = FLEXCAN0_CLK,
+#ifdef CONFIG_S32K1XX_FLEXCAN0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = FLEXCAN1_CLK,
+#ifdef CONFIG_S32K1XX_FLEXCAN1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+  {
+    .clkname = LPI2C0_CLK,
+#ifdef CONFIG_S32K1XX_LPI2C0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPSPI0_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPSPI1_CLK,
+#ifdef CONFIG_S32K1XX_LPSPI1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPUART0_CLK,
+#ifdef CONFIG_S32K1XX_LPUART0
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = LPUART1_CLK,
+#ifdef CONFIG_S32K1XX_LPUART1
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+    .clksrc  = CLK_SRC_SPLL_DIV2,
+  },
+  {
+    .clkname = PORTA_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTB_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTC_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTD_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = PORTE_CLK,
+    .clkgate = true,
+  },
+  {
+    .clkname = RTC0_CLK,
+#ifdef CONFIG_S32K1XX_RTC
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
+};
+
+unsigned int const num_of_peripheral_clocks_0 =
+    sizeof(g_peripheral_clockconfig0) /
+    sizeof(g_peripheral_clockconfig0[0]);
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c
new file mode 100644
index 0000000000..1264f01e0a
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c
@@ -0,0 +1,66 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_reset.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/board.h>
+
+#ifdef CONFIG_BOARDCTL_RESET
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_reset
+ *
+ * Description:
+ *   Reset board.  Support for this function is required by board-level
+ *   logic if CONFIG_BOARDCTL_RESET is selected.
+ *
+ * Input Parameters:
+ *   status - Status information provided with the reset event.  This
+ *            meaning of this status information is board-specific.  If not
+ *            used by a board, the value zero may be provided in calls to
+ *            board_reset().
+ *
+ * Returned Value:
+ *   If this function returns, then it was not possible to power-off the
+ *   board due to some constraints.  The return value in this case is a
+ *   board-specific reason for the failure to shutdown.
+ *
+ ****************************************************************************/
+
+int board_reset(int status)
+{
+  up_systemreset();
+  return 0;
+}
+
+#endif /* CONFIG_BOARDCTL_RESET */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c
new file mode 100644
index 0000000000..83d6e72950
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c
@@ -0,0 +1,925 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_smbus_sbd.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/kmalloc.h>
+#include <nuttx/fs/fs.h>
+#include <nuttx/i2c/i2c_slave.h>
+
+#include <arch/board/smbus_sbd.h>
+
+#ifdef CONFIG_SMBUS_SBD
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Macros for splitting a 16-bit unsigned integer into two bytes */
+
+#define LOBYTE(n) ((uint8_t)((n) & 0x00ff))
+#define HIBYTE(n) ((uint8_t)(((n) & 0xff00) >> 8))
+
+/****************************************************************************
+ * Private Type Definitions
+ ****************************************************************************/
+
+/* Private data of the SMBus Smart Battery Data slave device */
+
+struct smbus_sbd_dev_s
+{
+  struct i2c_slave_s *i2c_slave_dev; /* Associated I2C slave device */
+  struct smbus_sbd_data_s *data;     /* Most recent battery data */
+
+  uint8_t read_buffer[3];   /* Pre-allocated read buffer */
+  uint8_t write_buffer[16]; /* Pre-allocated write buffer */
+
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  uint8_t refs; /* Reference count */
+#endif
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+static int smbus_sbd_open(struct file *filep);
+static int smbus_sbd_close(struct file *filep);
+static ssize_t smbus_sbd_read(struct file *filep, char *buffer,
+                              size_t buflen);
+static ssize_t smbus_sbd_write(struct file *filep, const char *buffer,
+                               size_t buflen);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* Valid operations that can be performed on the the SMBus Smart Battery Data
+ * slave character device:
+ */
+
+static const struct file_operations smbus_sbd_fops =
+{
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  smbus_sbd_open,  /* open */
+  smbus_sbd_close, /* close */
+#else
+  NULL,            /* open */
+  NULL,            /* close */
+#endif
+  smbus_sbd_read,  /* read */
+  smbus_sbd_write, /* write */
+  NULL,            /* seek */
+  NULL,            /* ioctl */
+  NULL,            /* poll */
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+  NULL,            /* unlink */
+#endif
+};
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+#ifndef CONFIG_DISABLE_PSEUDOFS_OPERATIONS
+/****************************************************************************
+ * Name: smbus_sbd_open
+ *
+ * Description: Open the character device.
+ *
+ * Input Parameters:
+ *   filep - Instance of file struct
+ *
+ * Returned Value:
+ *   OK if the SMBus Smart Battery Data slave character device was
+ *   successfully opened; A negated errno value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int smbus_sbd_open(struct file *filep)
+{
+  struct smbus_sbd_dev_s *dev;
+
+  /* Retrieve the smbus_sbd_dev_s struct */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (struct smbus_sbd_dev_s *)filep->f_inode->i_private;
+
+  /* Increase the open reference count */
+
+  dev->refs++;
+  DEBUGASSERT(dev->refs > 0);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Name: smbus_sbd_close
+ *
+ * Description:
+ *   Close the character device.
+ *
+ * Input Parameters:
+ *   filep - Instance of file struct
+ *
+ * Returned Value:
+ *   OK if the SMBus Smart Battery Data slave character device was
+ *   successfully closed; A negated errno value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int smbus_sbd_close(struct file *filep)
+{
+  struct smbus_sbd_dev_s *dev;
+
+  /* Retrieve the smbus_sbd_dev_s struct */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (struct smbus_sbd_dev_s *)filep->f_inode->i_private;
+
+  /* Decrease the open reference count */
+
+  DEBUGASSERT(dev->refs > 0);
+  dev->refs--;
+
+  return OK;
+}
+#endif /* CONFIG_DISABLE_PSEUDOFS_OPERATIONS */
+
+/****************************************************************************
+ * Name: smbus_sbd_read
+ *
+ * Description:
+ *   Reads the battery data that is currently known by the SMBus Smart
+ *   Battery Data slave driver into a smbus_sbd_data_s struct that needs
+ *   to be converted to a character buffer.
+ *
+ * Input Parameters:
+ *   filep  - Instance of file struct
+ *   buffer - Pointer to an empty smbus_sbd_data_s struct (cast to a
+ *            (char *)) which will be filled with the most recent battery
+ *            data that is available in the SMBus Smart Battery Data slave
+ *            driver.
+ *   buflen - Size of the provided smbus_sbd_data_s struct
+ *
+ * Returned Value:
+ *   On success, buflen is returned to indicate that all data has been
+ *   copied.  Zero will be returned if the provided buffer length is not
+ *   sufficient for a smbus_sbd_data_s struct.
+ *
+ ****************************************************************************/
+
+static ssize_t smbus_sbd_read(struct file *filep, char *buffer,
+                              size_t buflen)
+{
+  irqstate_t flags;
+  struct smbus_sbd_dev_s *dev;
+  struct smbus_sbd_data_s *read_data;
+
+  /* Make sure that the read process (i.e. copying data from the SMBus Smart
+   * Battery Data slave driver) cannot be interrupted.
+   */
+
+  flags = enter_critical_section();
+
+  if (buflen < sizeof(struct smbus_sbd_data_s))
+    {
+      /* Something went wrong. The provided buffer length is not sufficient
+       * for a smbus_sbd_data_s struct.  Return zero to indicate that
+       * nothing was read.
+       */
+
+      return 0;
+    }
+
+  /* Retrieve the SMBus Smart Battery Data slave device struct and the data
+   * struct that holds the new data that should be copied to the SMBus Smart
+   * Battery Data slave driver.
+   */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (struct smbus_sbd_dev_s *)filep->f_inode->i_private;
+
+  DEBUGASSERT(buffer);
+  read_data = (struct smbus_sbd_data_s *)buffer;
+
+  /* Copy the new data into the SMBus Smart Battery Data slave device
+   * struct
+   */
+
+  read_data->temperature              = dev->data->temperature;
+  read_data->voltage                  = dev->data->voltage;
+  read_data->current                  = dev->data->current;
+  read_data->average_current          = dev->data->average_current;
+  read_data->max_error                = dev->data->max_error;
+  read_data->relative_state_of_charge = dev->data->relative_state_of_charge;
+  read_data->absolute_state_of_charge = dev->data->absolute_state_of_charge;
+  read_data->remaining_capacity       = dev->data->remaining_capacity;
+  read_data->full_charge_capacity     = dev->data->full_charge_capacity;
+  read_data->run_time_to_empty        = dev->data->run_time_to_empty;
+  read_data->average_time_to_empty    = dev->data->average_time_to_empty;
+
+  read_data->cycle_count              = dev->data->cycle_count;
+  read_data->design_capacity          = dev->data->design_capacity;
+  read_data->design_voltage           = dev->data->design_voltage;
+  read_data->manufacture_date         = dev->data->manufacture_date;
+  read_data->serial_number            = dev->data->serial_number;
+  read_data->manufacturer_name        = dev->data->manufacturer_name;
+  read_data->device_name              = dev->data->device_name;
+  read_data->device_chemistry         = dev->data->device_chemistry;
+  read_data->manufacturer_data        = dev->data->manufacturer_data;
+  read_data->manufacturer_data_length = dev->data->manufacturer_data_length;
+
+  read_data->cell1_voltage            = dev->data->cell1_voltage;
+  read_data->cell2_voltage            = dev->data->cell2_voltage;
+  read_data->cell3_voltage            = dev->data->cell3_voltage;
+  read_data->cell4_voltage            = dev->data->cell4_voltage;
+  read_data->cell5_voltage            = dev->data->cell5_voltage;
+  read_data->cell6_voltage            = dev->data->cell6_voltage;
+  read_data->cell7_voltage            = dev->data->cell7_voltage;
+  read_data->cell8_voltage            = dev->data->cell8_voltage;
+  read_data->cell9_voltage            = dev->data->cell9_voltage;
+  read_data->cell10_voltage           = dev->data->cell10_voltage;
+  read_data->cell11_voltage           = dev->data->cell11_voltage;
+  read_data->cell12_voltage           = dev->data->cell12_voltage;
+  read_data->cell13_voltage           = dev->data->cell13_voltage;
+  read_data->cell14_voltage           = dev->data->cell14_voltage;
+
+  leave_critical_section(flags);
+
+  return buflen;
+}
+
+/****************************************************************************
+ * Name: smbus_sbd_write
+ *
+ * Description:
+ *   Updates the battery data of the SMBus Smart Battery Data slave driver.
+ *   The data is contained in a smbus_sbd_data_s struct that needs to be
+ *   converted to a character buffer.  This data is then copied into the
+ *   private data structure of the SMBus Smart Battery Data slave driver and
+ *   used to prepare a write buffer for the I2C slave when a valid request is
+ *   received on the I2C bus.
+ *
+ * Input Parameters:
+ *   filep  - Instance of file struct
+ *   buffer - Pointer to a smbus_sbd_data_s struct (cast to a
+ *            (const char *)) containing updated battery data.
+ *   buflen - Size of the provided smbus_sbd_data_s struct
+ *
+ * Returned Value:
+ *   On success, buflen is returned to indicate that all data has been
+ *   copied.  Zero will be returned if the provided buffer length is not
+ *   sufficient for a smbus_sbd_data_s struct.
+ *
+ ****************************************************************************/
+
+static ssize_t smbus_sbd_write(struct file *filep, const char *buffer,
+                               size_t buflen)
+{
+  irqstate_t flags;
+  struct smbus_sbd_dev_s *dev;
+  struct smbus_sbd_data_s *new_data;
+
+  /* Make sure that the write process (i.e. copying new data to the SMBus
+   * Smart Battery Data slave driver) cannot be interrupted.
+   */
+
+  flags = enter_critical_section();
+
+  if (buflen < sizeof(struct smbus_sbd_data_s))
+    {
+      /* Something went wrong. The provided buffer length is not sufficient
+       * for a smbus_sbd_data_s struct.  Return zero to indicate that
+       * nothing was written.
+       */
+
+      return 0;
+    }
+
+  /* Retrieve the SMBus Smart Battery Data slave device struct and the data
+   * struct that holds the new data that should be copied to the SMBus Smart
+   * Battery Data slave driver.
+   */
+
+  DEBUGASSERT(filep && filep->f_inode && filep->f_inode->i_private);
+  dev = (struct smbus_sbd_dev_s *)filep->f_inode->i_private;
+
+  DEBUGASSERT(buffer);
+  new_data = (struct smbus_sbd_data_s *)buffer;
+
+  /* Copy the new data into the SMBus Smart Battery Data slave device
+   * struct
+   */
+
+  dev->data->temperature              = new_data->temperature;
+  dev->data->voltage                  = new_data->voltage;
+  dev->data->current                  = new_data->current;
+  dev->data->average_current          = new_data->average_current;
+  dev->data->max_error                = new_data->max_error;
+  dev->data->relative_state_of_charge = new_data->relative_state_of_charge;
+  dev->data->absolute_state_of_charge = new_data->absolute_state_of_charge;
+  dev->data->remaining_capacity       = new_data->remaining_capacity;
+  dev->data->full_charge_capacity     = new_data->full_charge_capacity;
+  dev->data->run_time_to_empty        = new_data->run_time_to_empty;
+  dev->data->average_time_to_empty    = new_data->average_time_to_empty;
+
+  dev->data->cycle_count              = new_data->cycle_count;
+  dev->data->design_capacity          = new_data->design_capacity;
+  dev->data->design_voltage           = new_data->design_voltage;
+  dev->data->manufacture_date         = new_data->manufacture_date;
+  dev->data->serial_number            = new_data->serial_number;
+  dev->data->manufacturer_name        = new_data->manufacturer_name;
+  dev->data->device_name              = new_data->device_name;
+  dev->data->device_chemistry         = new_data->device_chemistry;
+  dev->data->manufacturer_data        = new_data->manufacturer_data;
+  dev->data->manufacturer_data_length = new_data->manufacturer_data_length;
+
+  dev->data->cell1_voltage            = new_data->cell1_voltage;
+  dev->data->cell2_voltage            = new_data->cell2_voltage;
+  dev->data->cell3_voltage            = new_data->cell3_voltage;
+  dev->data->cell4_voltage            = new_data->cell4_voltage;
+  dev->data->cell5_voltage            = new_data->cell5_voltage;
+  dev->data->cell6_voltage            = new_data->cell6_voltage;
+  dev->data->cell7_voltage            = new_data->cell7_voltage;
+  dev->data->cell8_voltage            = new_data->cell8_voltage;
+  dev->data->cell9_voltage            = new_data->cell9_voltage;
+  dev->data->cell10_voltage           = new_data->cell10_voltage;
+  dev->data->cell11_voltage           = new_data->cell11_voltage;
+  dev->data->cell12_voltage           = new_data->cell12_voltage;
+  dev->data->cell13_voltage           = new_data->cell13_voltage;
+  dev->data->cell14_voltage           = new_data->cell14_voltage;
+
+  leave_critical_section(flags);
+
+  return buflen;
+}
+
+/****************************************************************************
+ * Name: smbus_sbd_callback
+ *
+ * Description:
+ *   Callback function that is to be invoked by the I2C slave driver when
+ *   data has been received.  The received data will be checked against a
+ *   list of registers that can be requested from a smart battery.  If there
+ *   is a match the requested data will be put into the write buffer that is
+ *   used by the I2C slave driver when a bus master wants to read the data.
+ *
+ * Input Parameters:
+ *   arg    - Pointer to the SMBus Smart Battery Data slave device struct
+ *
+ * Returned Value:
+ *   OK if a new write buffer was successfully registered in response to the
+ *   received command; A negated errno value is returned on any failure.
+ *
+ ****************************************************************************/
+
+static int smbus_sbd_callback(void *arg, size_t rx_len)
+{
+  struct smbus_sbd_dev_s *dev;
+  int buffer_length;
+  int i;
+
+  /* Retrieve the pointer to the SMBus SBD slave device struct */
+
+  dev = (struct smbus_sbd_dev_s *)arg;
+  DEBUGASSERT(dev && dev->i2c_slave_dev);
+
+  /* Check which register was requested and prepare the write buffer */
+
+  switch (dev->read_buffer[0])
+    {
+      case SBD_TEMPERATURE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->temperature);
+          dev->write_buffer[1] = HIBYTE(dev->data->temperature);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CURRENT:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->current);
+          dev->write_buffer[1] = HIBYTE(dev->data->current);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_AVERAGE_CURRENT:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->average_current);
+          dev->write_buffer[1] = HIBYTE(dev->data->average_current);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_MAX_ERROR:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->max_error);
+          dev->write_buffer[1] = HIBYTE(dev->data->max_error);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_RELATIVE_STATE_OF_CHARGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->relative_state_of_charge);
+          dev->write_buffer[1] = HIBYTE(dev->data->relative_state_of_charge);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_ABSOLUTE_STATE_OF_CHARGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->absolute_state_of_charge);
+          dev->write_buffer[1] = HIBYTE(dev->data->absolute_state_of_charge);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_REMAINING_CAPACITY:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->remaining_capacity);
+          dev->write_buffer[1] = HIBYTE(dev->data->remaining_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_FULL_CHARGE_CAPACITY:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->full_charge_capacity);
+          dev->write_buffer[1] = HIBYTE(dev->data->full_charge_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_RUN_TIME_TO_EMPTY:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->run_time_to_empty);
+          dev->write_buffer[1] = HIBYTE(dev->data->run_time_to_empty);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_AVERAGE_TIME_TO_EMPTY:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->average_time_to_empty);
+          dev->write_buffer[1] = HIBYTE(dev->data->average_time_to_empty);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CYCLE_COUNT:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cycle_count);
+          dev->write_buffer[1] = HIBYTE(dev->data->cycle_count);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_DESIGN_CAPACITY:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->design_capacity);
+          dev->write_buffer[1] = HIBYTE(dev->data->design_capacity);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_DESIGN_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->design_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->design_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_MANUFACTURE_DATE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->manufacture_date);
+          dev->write_buffer[1] = HIBYTE(dev->data->manufacture_date);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_SERIAL_NUMBER:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->serial_number);
+          dev->write_buffer[1] = HIBYTE(dev->data->serial_number);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_MANUFACTURER_NAME:
+        {
+          if (dev->data->manufacturer_name == NULL)
+            {
+              /* No manufacturer name was set. Return an empty string. */
+
+              dev->write_buffer[0] = 0;
+              buffer_length = 1;
+            }
+          else
+            {
+              /* Determine how many characters to put into the write buffer,
+               * but it can be at most 15.  The buffer can hold 16 bytes,
+               * including the first byte that indicates the string length.
+               */
+
+              dev->write_buffer[0] =
+                strnlen(dev->data->manufacturer_name, 15);
+
+              /* Fill the write buffer */
+
+              for (i = 0; i < dev->write_buffer[0]; i++)
+                {
+                  dev->write_buffer[i + 1] =
+                    (uint8_t)dev->data->manufacturer_name[i];
+                }
+
+              buffer_length = (dev->write_buffer[0] + 1);
+            }
+        }
+        break;
+
+      case SBD_DEVICE_NAME:
+        {
+          if (dev->data->device_name == NULL)
+            {
+              /* No device name was set. Return an empty string. */
+
+              dev->write_buffer[0] = 0;
+              buffer_length = 1;
+            }
+          else
+            {
+              /* Determine how many characters to put into the write buffer,
+               * but it can be at most 15.  The buffer can hold 16 bytes,
+               * including the first byte that indicates the string length.
+               */
+
+              dev->write_buffer[0] = strnlen(dev->data->device_name, 15);
+
+              /* Fill the write buffer */
+
+              for (i = 0; i < dev->write_buffer[0]; i++)
+                {
+                  dev->write_buffer[i + 1] =
+                    (uint8_t)dev->data->device_name[i];
+                }
+
+              buffer_length = (dev->write_buffer[0] + 1);
+            }
+        }
+        break;
+
+      case SBD_DEVICE_CHEMISTRY:
+        {
+          if (dev->data->device_chemistry == NULL)
+            {
+              /* No device chemistry was set. Return an empty string. */
+
+              dev->write_buffer[0] = 0;
+              buffer_length = 1;
+            }
+          else
+            {
+              /* Determine how many characters to put into the write buffer,
+               * but it can be at most 15.  The buffer can hold 16 bytes,
+               * including the first byte that indicates the string length.
+               */
+
+              dev->write_buffer[0] =
+                strnlen(dev->data->device_chemistry, 15);
+
+              /* Fill the write buffer */
+
+              for (i = 0; i < dev->write_buffer[0]; i++)
+                {
+                  dev->write_buffer[i + 1] =
+                    (uint8_t)dev->data->device_chemistry[i];
+                }
+
+              buffer_length = (dev->write_buffer[0] + 1);
+            }
+        }
+        break;
+
+      case SBD_MANUFACTURER_DATA:
+        {
+          if (dev->data->manufacturer_data == NULL)
+            {
+              /* No manufacturer data was set. Return an empty dataset. */
+
+              dev->write_buffer[0] = 0;
+              buffer_length = 1;
+            }
+          else
+            {
+              /* Determine how many bytes to put into the write buffer */
+
+              dev->write_buffer[0] = dev->data->manufacturer_data_length;
+              if (dev->write_buffer[0] > 15)
+                {
+                  dev->write_buffer[0] = 15;
+
+                  /* The write buffer can only hold 16 bytes, including the
+                   * first byte that indicates the length of the byte array.
+                   * The array has to be limited to 15 bytes if it is longer.
+                   */
+                }
+
+              /* Fill the write buffer */
+
+              for (i = 0; i < dev->write_buffer[0]; i++)
+                {
+                  dev->write_buffer[i + 1] = dev->data->manufacturer_data[i];
+                }
+
+              buffer_length = (dev->write_buffer[0] + 1);
+            }
+        }
+        break;
+
+      case SBD_CELL14_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell14_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell14_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL13_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell13_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell13_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL12_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell12_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell12_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL11_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell11_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell11_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL10_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell10_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell10_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL9_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell9_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell9_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL8_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell8_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell8_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL7_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell7_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell7_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL6_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell6_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell6_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL5_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell5_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell5_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL4_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell4_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell4_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL3_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell3_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell3_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL2_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell2_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell2_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      case SBD_CELL1_VOLTAGE:
+        {
+          dev->write_buffer[0] = LOBYTE(dev->data->cell1_voltage);
+          dev->write_buffer[1] = HIBYTE(dev->data->cell1_voltage);
+          buffer_length = 2;
+        }
+        break;
+
+      default:
+        {
+          /* Set an empty write buffer with zero length if the requested
+           * register does not exist (or is not yet supported).  The I2C
+           * slave will usually handle an empty buffer by sending zero bytes.
+           */
+
+          return I2CS_WRITE(dev->i2c_slave_dev, NULL, 0);
+        }
+        break;
+    }
+
+  /* Install the (re)filled write buffer.  Technically this buffer needs to
+   * be constant, but we want to be able to re-use the same buffer for the
+   * next request, so we just cast the buffer to const.  This should not
+   * cause any problems, because the write buffer is only changed when the
+   * I2C slave driver invokes this callback, which only happens when a new
+   * request has been received.
+   */
+
+  return I2CS_WRITE(dev->i2c_slave_dev, (const uint8_t *)dev->write_buffer,
+                    buffer_length);
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: smbus_sbd_initialize
+ *
+ * Description:
+ *   Create and register a SMBus Smart Battery Data slave character driver.
+ *
+ *   This character driver supports (a subset of) the Smart Battery Data
+ *   Specification, Revision 1.1.  This driver provides a buffer to the I2C
+ *   slave driver.  This buffer can be updated at regular intervals by a
+ *   user-space application.
+ *
+ * Input Parameters:
+ *   minor         - The SMBus Smart Battery Data slave character device will
+ *                   be registered as /dev/smbus-sbdN where N is the
+ *                   minor number
+ *   i2c_slave_dev - An instance of the lower half I2C slave driver
+ *
+ * Returned Value:
+ *   OK if the driver was successfully registered; A negated errno value is
+ *   returned on any failure.
+ *
+ ****************************************************************************/
+
+int smbus_sbd_initialize(int minor, struct i2c_slave_s *i2c_slave_dev)
+{
+  irqstate_t flags;
+  struct smbus_sbd_dev_s *smbus_sbd_dev;
+  char dev_name[24];
+  int ret;
+
+  /* Make sure the initialization is not interrupted */
+
+  flags = enter_critical_section();
+
+  /* Allocate an SMBus Smart Battery Data slave device structure */
+
+  smbus_sbd_dev =
+    (struct smbus_sbd_dev_s *)kmm_zalloc(sizeof(struct smbus_sbd_dev_s));
+
+  if (smbus_sbd_dev == NULL)
+    {
+      leave_critical_section(flags);
+      return -ENOMEM;
+    }
+  else
+    {
+      /* Create the device name string */
+
+      snprintf(dev_name, 24, "/dev/smbus-sbd%d", minor);
+
+      /* Register the driver.  The associated private data is a reference to
+       * the SMBus Smart Battery Data slave device structure.
+       */
+
+      ret = register_driver(dev_name, &smbus_sbd_fops, 0, smbus_sbd_dev);
+      if (ret < 0)
+        {
+          ferr("register_driver failed: %d\n", -ret);
+          kmm_free(smbus_sbd_dev);
+
+          leave_critical_section(flags);
+          return ret;
+        }
+    }
+
+  /* Allocate the SMBus Smart Battery Data slave data structure */
+
+  smbus_sbd_dev->data =
+    (struct smbus_sbd_data_s *)kmm_zalloc(sizeof(struct smbus_sbd_data_s));
+
+  if (smbus_sbd_dev->data == NULL)
+    {
+      leave_critical_section(flags);
+      return -ENOMEM;
+    }
+
+  /* Set-up the I2C slave device.  Install a read-buffer as well as a
+   * callback, which will receive the SMBus Smart Battery Data slave device
+   * structure as an argument.
+   */
+
+  DEBUGASSERT(i2c_slave_dev);
+  smbus_sbd_dev->i2c_slave_dev = i2c_slave_dev;
+
+  ret = I2CS_READ(smbus_sbd_dev->i2c_slave_dev,
+                  smbus_sbd_dev->read_buffer, 3);
+  if (ret < 0)
+    {
+      leave_critical_section(flags);
+      return ret;
+    }
+
+  ret = I2CS_REGISTERCALLBACK(smbus_sbd_dev->i2c_slave_dev,
+                              smbus_sbd_callback, (void *)smbus_sbd_dev);
+  if (ret < 0)
+    {
+      leave_critical_section(flags);
+      return ret;
+    }
+
+  leave_critical_section(flags);
+  return 0;
+}
+
+#endif /* CONFIG_SMBUS_SBD */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c
new file mode 100644
index 0000000000..a977eccd2e
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c
@@ -0,0 +1,169 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_spi.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <nuttx/compiler.h>
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <debug.h>
+
+#include <nuttx/spi/spi.h>
+#include <nuttx/spi/spi_transfer.h>
+
+#include "s32k1xx_pin.h"
+#include "s32k1xx_lpspi.h"
+
+#include <arch/board/board.h>
+
+#include "mr-bms771.h"
+
+#ifdef CONFIG_S32K1XX_LPSPI
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: s32k1xx_spidev_initialize
+ *
+ * Description:
+ *   Configure chip select pins, initialize the SPI driver and register
+ *   /dev/spiN devices.
+ *
+ ****************************************************************************/
+
+int weak_function s32k1xx_spidev_initialize(void)
+{
+  int ret = OK;
+
+#ifdef CONFIG_S32K1XX_LPSPI0
+  /* LPSPI0 *****************************************************************/
+
+  /* Configure LPSPI0 peripheral chip select pins */
+
+  s32k1xx_pinconfig(PIN_LPSPI0_PCS);
+
+#  ifdef CONFIG_SPI_DRIVER
+  /* Initialize the SPI driver for LPSPI0 */
+
+  struct spi_dev_s *g_lpspi0 = s32k1xx_lpspibus_initialize(0);
+  if (g_lpspi0 == NULL)
+    {
+      spierr("ERROR: FAILED to initialize LPSPI0\n");
+      return -ENODEV;
+    }
+
+  ret = spi_register(g_lpspi0, 0);
+  if (ret < 0)
+    {
+      spierr("ERROR: FAILED to register LPSPI0 driver\n");
+      return ret;
+    }
+#  endif /* CONFIG_SPI_DRIVER */
+#endif /* CONFIG_S32K1XX_LPSPI0 */
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+  /* LPSPI1 *****************************************************************/
+
+  /* Configure LPSPI1 peripheral chip select pins */
+
+  s32k1xx_pinconfig(PIN_LPSPI1_PCS);
+
+#  ifdef CONFIG_SPI_DRIVER
+  /* Initialize the SPI driver for LPSPI1 */
+
+  struct spi_dev_s *g_lpspi1 = s32k1xx_lpspibus_initialize(1);
+  if (g_lpspi1 == NULL)
+    {
+      spierr("ERROR: FAILED to initialize LPSPI1\n");
+      return -ENODEV;
+    }
+
+  ret = spi_register(g_lpspi1, 1);
+  if (ret < 0)
+    {
+      spierr("ERROR: FAILED to register LPSPI1 driver\n");
+      return ret;
+    }
+#  endif /* CONFIG_SPI_DRIVER */
+#endif /* CONFIG_S32K1XX_LPSPI1 */
+
+  return ret;
+}
+
+/****************************************************************************
+ * Name: s32k1xx_lpspiNselect and s32k1xx_lpspiNstatus
+ *
+ * Description:
+ *   The external functions, s32k1xx_lpspiNselect* and s32k1xx_lpspiNstatus
+ *   must be provided by board-specific logic.  They are implementations of
+ *   the select and status methods of the SPI interface defined by struct
+ *   spi_ops_s (see include/nuttx/spi/spi.h).  All other methods (including
+ *   s32k1xx_lpspibus_initialize()) are provided by common logic.  To use
+ *   this common SPI logic on your board:
+ *
+ *   1. Provide logic in s32k1xx_boardinitialize() to configure SPI chip
+ *      select pins.
+ *   2. Provide s32k1xx_lpspiNselect() and s32k1xx_lpspiNstatus() functions
+ *      in your board-specific logic.  These functions will perform chip
+ *      selection and status operations using GPIOs in the way your board is
+ *      configured.
+ *   3. Add a calls to s32k1xx_lpspibus_initialize() in your low level
+ *      application initialization logic.
+ *   4. The handle returned by s32k1xx_lpspibus_initialize() may then be used
+ *      to bind the SPI driver to higher level logic (e.g., calling
+ *      mmcsd_spislotinitialize(), for example, will bind the SPI driver to
+ *      the SPI MMC/SD driver).
+ *
+ * NOTE*: If CONFIG_S32K1XX_LPSPI_HWPCS is selected, s32k1xx_lpspiNselect()
+ *        does NOT need to provided by board-specific logic.  In this case a
+ *        generic implementation is used that switches between native
+ *        hardware chip select pins.  It is important that all pins are
+ *        configured when the SPI bus is initialized.
+ *
+ ****************************************************************************/
+
+#ifdef CONFIG_S32K1XX_LPSPI0
+/* LPSPI0 *******************************************************************/
+
+uint8_t s32k1xx_lpspi0status(struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif /* CONFIG_S32K1XX_LPSPI0 */
+
+#ifdef CONFIG_S32K1XX_LPSPI1
+/* LPSPI1 *******************************************************************/
+
+uint8_t s32k1xx_lpspi1status(struct spi_dev_s *dev, uint32_t devid)
+{
+  return 0;
+}
+#endif /* CONFIG_S32K1XX_LPSPI1 */
+#endif /* CONFIG_S32K1XX_LPSPI */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c
new file mode 100644
index 0000000000..9616d67713
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c
@@ -0,0 +1,113 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_ssd1306.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <debug.h>
+#include <errno.h>
+#include <nuttx/board.h>
+#include <nuttx/i2c/i2c_master.h>
+#include <nuttx/lcd/lcd.h>
+#include <nuttx/lcd/ssd1306.h>
+
+#include "s32k1xx_lpi2c.h"
+
+#if defined(CONFIG_I2C) && defined(CONFIG_S32K1XX_LPI2C0) && \
+    defined(CONFIG_LCD_SSD1306_I2C)
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+static struct lcd_dev_s *s32k1xx_ssd1306_dev;
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_lcd_initialize
+ ****************************************************************************/
+
+int board_lcd_initialize(void)
+{
+  struct i2c_master_s *lpi2c0;
+  int ret = OK;
+
+  /* Initialize LPI2C0 */
+
+  lpi2c0 = s32k1xx_i2cbus_initialize(0);
+  if (lpi2c0 == NULL)
+    {
+      i2cerr("ERROR: Failed to initialize LPI2C0\n");
+      return -ENODEV;
+    }
+
+  /* Initialize SSD1306 on LPI2C0 */
+
+  lcdinfo("Initialize SSD1306 on LPI2C0\n");
+
+  s32k1xx_ssd1306_dev = ssd1306_initialize(lpi2c0, NULL, 0);
+  if (s32k1xx_ssd1306_dev == NULL)
+    {
+      lcderr("ERROR: Failed to initialize SSD1306 on LPI2C0\n");
+      s32k1xx_i2cbus_uninitialize(lpi2c0);
+      return -ENODEV;
+    }
+
+  lcdinfo("Successfully initialized SSD1306 on LPI2C0\n");
+
+  return ret;
+}
+
+/****************************************************************************
+ * Name: board_lcd_getdev
+ ****************************************************************************/
+
+struct lcd_dev_s *board_lcd_getdev(int devno)
+{
+  /* Only one display device with devno 0 is supported */
+
+  if (devno == 0)
+    {
+      return s32k1xx_ssd1306_dev;
+    }
+
+  return NULL;
+}
+
+/****************************************************************************
+ * Name: board_lcd_uninitialize
+ ****************************************************************************/
+
+void board_lcd_uninitialize(void)
+{
+  /* Turn off the power to uninitialize */
+
+  s32k1xx_ssd1306_dev->setpower(s32k1xx_ssd1306_dev, 0);
+}
+
+#endif /* CONFIG_I2C && CONFIG_S32K1XX_LPI2C0 && CONFIG_LCD_SSD1306_I2C */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c
new file mode 100644
index 0000000000..ff980525df
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c
@@ -0,0 +1,67 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_uid.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <nuttx/board.h>
+#include <nuttx/compiler.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <errno.h>
+
+#include "s32k1xx_uid.h"
+
+#ifdef CONFIG_BOARDCTL_UNIQUEID
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#if CONFIG_BOARDCTL_UNIQUEID_SIZE != S32K1XX_UID_SIZE
+#  error CONFIG_BOARDCTL_UNIQUEID_SIZE does not match S32K1XX_UID_SIZE
+#endif
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_uniqueid
+ ****************************************************************************/
+
+int board_uniqueid(uint8_t *uniqueid)
+{
+  if (uniqueid == NULL)
+    {
+      return -EINVAL;
+    }
+
+  s32k1xx_get_uniqueid(uniqueid);
+
+  return OK;
+}
+
+#endif /* CONFIG_BOARDCTL_UNIQUEID */
diff --git a/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_userleds.c b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_userleds.c
new file mode 100644
index 0000000000..7dc8655c5c
--- /dev/null
+++ b/boards/arm/s32k1xx/mr-bms771/src/s32k1xx_userleds.c
@@ -0,0 +1,122 @@
+/****************************************************************************
+ * boards/arm/s32k1xx/mr-bms771/src/s32k1xx_userleds.c
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/* Copyright 2022-2025 NXP */
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <nuttx/board.h>
+
+#include "s32k1xx_pin.h"
+
+#include <arch/board/board.h>
+
+#include "mr-bms771.h"
+
+#ifndef CONFIG_ARCH_LEDS
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: board_userled_initialize
+ ****************************************************************************/
+
+uint32_t board_userled_initialize(void)
+{
+  /* Configure LED GPIOs for output */
+
+  s32k1xx_pinconfig(GPIO_LED_R);
+  s32k1xx_pinconfig(GPIO_LED_G);
+  s32k1xx_pinconfig(GPIO_LED_B);
+
+  return BOARD_NLEDS;
+}
+
+/****************************************************************************
+ * Name: board_userled
+ ****************************************************************************/
+
+void board_userled(int led, bool ledon)
+{
+  uint32_t ledcfg;
+
+  if (led == BOARD_LED_R)
+    {
+      ledcfg = GPIO_LED_R;
+    }
+  else if (led == BOARD_LED_G)
+    {
+      ledcfg = GPIO_LED_G;
+    }
+  else if (led == BOARD_LED_B)
+    {
+      ledcfg = GPIO_LED_B;
+    }
+  else
+    {
+      return;
+    }
+
+  /* Invert output, an output of '0' illuminates the LED */
+
+  s32k1xx_gpiowrite(ledcfg, !ledon);
+}
+
+/****************************************************************************
+ * Name: board_userled_all
+ ****************************************************************************/
+
+void board_userled_all(uint32_t ledset)
+{
+  /* Invert output, an output of '0' illuminates the LED */
+
+  s32k1xx_gpiowrite(GPIO_LED_R, !((ledset & BOARD_LED_R_BIT) != 0));
+  s32k1xx_gpiowrite(GPIO_LED_G, !((ledset & BOARD_LED_G_BIT) != 0));
+  s32k1xx_gpiowrite(GPIO_LED_B, !((ledset & BOARD_LED_B_BIT) != 0));
+}
+
+#ifdef CONFIG_USERLED_LOWER_READSTATE
+/****************************************************************************
+ * Name: board_userled_getall
+ ****************************************************************************/
+
+void board_userled_getall(uint32_t *ledset)
+{
+  /* Clear the LED bits */
+
+  *ledset = 0;
+
+  /* Get LED state. Invert value, an output of '0' illuminates the LED. */
+
+  *ledset |= (((!s32k1xx_gpioread(GPIO_LED_R)) & 1) << BOARD_LED_R);
+  *ledset |= (((!s32k1xx_gpioread(GPIO_LED_G)) & 1) << BOARD_LED_G);
+  *ledset |= (((!s32k1xx_gpioread(GPIO_LED_B)) & 1) << BOARD_LED_B);
+}
+#endif /* CONFIG_USERLED_LOWER_READSTATE */
+#endif /* !CONFIG_ARCH_LEDS */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
new file mode 100644
index 0000000000..17a3ceb609
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bms/defconfig
@@ -0,0 +1,143 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
new file mode 100644
index 0000000000..a6007e8249
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmsdebug/defconfig
@@ -0,0 +1,149 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ASSERTIONS=y
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_INFO=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEBUG_WARN=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig b/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig
new file mode 100644
index 0000000000..c3d0ab4a4e
--- /dev/null
+++ b/boards/arm/s32k1xx/rddrone-bms772/configs/bmstrace/defconfig
@@ -0,0 +1,158 @@
+#
+# This file is autogenerated: PLEASE DO NOT EDIT IT.
+#
+# You can use "make menuconfig" to make any modifications to the installed .config file.
+# You can then do "make savedefconfig" to generate a new defconfig file that includes your
+# modifications.
+#
+# CONFIG_ARCH_LEDS is not set
+# CONFIG_NDEBUG is not set
+# CONFIG_NET_ETHERNET is not set
+# CONFIG_NET_IPv4 is not set
+# CONFIG_NSH_ARGCAT is not set
+# CONFIG_NSH_CMDOPT_HEXDUMP is not set
+# CONFIG_NSH_CMDPARMS is not set
+CONFIG_ALLOW_MIT_COMPONENTS=y
+CONFIG_ARCH="arm"
+CONFIG_ARCH_BOARD="rddrone-bms772"
+CONFIG_ARCH_BOARD_RDDRONE_BMS772=y
+CONFIG_ARCH_CHIP="s32k1xx"
+CONFIG_ARCH_CHIP_S32K144=y
+CONFIG_ARCH_CHIP_S32K14X=y
+CONFIG_ARCH_CHIP_S32K1XX=y
+CONFIG_ARCH_INTERRUPTSTACK=1024
+CONFIG_ARCH_STACKDUMP=y
+CONFIG_ARMV7M_LIBM=y
+CONFIG_ARMV7M_MEMCPY=y
+CONFIG_BCH=y
+CONFIG_BINFMT_DISABLE=y
+CONFIG_BOARDCTL_RESET=y
+CONFIG_BOARDCTL_UNIQUEID=y
+CONFIG_BOARD_LOOPSPERMSEC=6667
+CONFIG_BUILTIN=y
+CONFIG_CANUTILS_LIBCANARDV1=y
+CONFIG_CANUTILS_LIBDRONECAN=y
+CONFIG_CAN_CONNS=1
+CONFIG_DEBUG_ERROR=y
+CONFIG_DEBUG_FEATURES=y
+CONFIG_DEBUG_SYMBOLS=y
+CONFIG_DEBUG_TCBINFO=y
+CONFIG_DEV_GPIO=y
+CONFIG_DRIVERS_VIDEO=y
+CONFIG_DRIVER_NOTE=y
+CONFIG_EVENT_FD=y
+CONFIG_FS_PROCFS=y
+CONFIG_FS_ROMFS=y
+CONFIG_I2C_DRIVER=y
+CONFIG_I2C_RESET=y
+CONFIG_I2C_SLAVE=y
+CONFIG_INIT_ENTRYPOINT="nsh_main"
+CONFIG_INIT_STACKSIZE=2304
+CONFIG_IOB_BUFSIZE=96
+CONFIG_LCD=y
+CONFIG_LCD_FRAMEBUFFER=y
+CONFIG_LCD_MAXCONTRAST=255
+CONFIG_LCD_RLANDSCAPE=y
+CONFIG_LCD_SSD1306_CUSTOM=y
+CONFIG_LCD_SSD1306_I2C=y
+CONFIG_LIBDRONECAN_VERSION="21f2a73df86886101e254d02cfc2277cd2a15717"
+CONFIG_LIBM=y
+CONFIG_LPI2C0_SLAVE_BUS=y
+CONFIG_LPUART0_RXBUFSIZE=64
+CONFIG_LPUART0_TXBUFSIZE=64
+CONFIG_LPUART1_RXBUFSIZE=64
+CONFIG_LPUART1_SERIAL_CONSOLE=y
+CONFIG_LPUART1_TXBUFSIZE=64
+CONFIG_NET=y
+CONFIG_NETDEV_CAN_BITRATE_IOCTL=y
+CONFIG_NETDEV_CAN_FILTER_IOCTL=y
+CONFIG_NETDEV_IFINDEX=y
+CONFIG_NET_CAN=y
+CONFIG_NET_CAN_EXTID=y
+CONFIG_NET_CAN_NOTIFIER=y
+CONFIG_NET_CAN_RAW_FILTER_MAX=0
+CONFIG_NET_CAN_RAW_TX_DEADLINE=y
+CONFIG_NET_CAN_SOCK_OPTS=y
+CONFIG_NET_TIMESTAMP=y
+CONFIG_NSH_ARCHINIT=y
+CONFIG_NSH_ARCHROMFS=y
+CONFIG_NSH_BUILTIN_APPS=y
+CONFIG_NSH_FILEIOSIZE=512
+CONFIG_NSH_READLINE=y
+CONFIG_NSH_ROMFSETC=y
+CONFIG_NXFONTS=y
+CONFIG_NXFONTS_CHARBITS=8
+CONFIG_NXFONTS_DISABLE_16BPP=y
+CONFIG_NXFONTS_DISABLE_1BPP=y
+CONFIG_NXFONTS_DISABLE_24BPP=y
+CONFIG_NXFONTS_DISABLE_2BPP=y
+CONFIG_NXFONTS_DISABLE_32BPP=y
+CONFIG_NXFONTS_DISABLE_4BPP=y
+CONFIG_NXFONTS_DISABLE_8BPP=y
+CONFIG_NXFONT_X11_MISC_FIXED_5X8=y
+CONFIG_NXP_BMS=y
+CONFIG_PATH_MAX=128
+CONFIG_PM=y
+CONFIG_PM_CONSOLE_SLEEP=y
+CONFIG_PM_CONSOLE_STANDBY=y
+CONFIG_PM_SERIAL_SLEEP=y
+CONFIG_PM_SERIAL_STANDBY=y
+CONFIG_PM_SPI0_SLEEP=y
+CONFIG_PM_SPI0_STANDBY=y
+CONFIG_PM_SPI1_STANDBY=y
+CONFIG_PM_SPI_SLEEP=y
+CONFIG_PM_SPI_STANDBY=y
+CONFIG_PREALLOC_TIMERS=4
+CONFIG_RAM_SIZE=61440
+CONFIG_RAM_START=0x1fff8000
+CONFIG_RAW_BINARY=y
+CONFIG_RR_INTERVAL=200
+CONFIG_S32K1XX_EEEPROM=y
+CONFIG_S32K1XX_FLEXCAN0=y
+CONFIG_S32K1XX_GPIOIRQ=y
+CONFIG_S32K1XX_LPI2C0=y
+CONFIG_S32K1XX_LPSPI0=y
+CONFIG_S32K1XX_LPSPI1=y
+CONFIG_S32K1XX_LPSPI_DWORD=y
+CONFIG_S32K1XX_LPSPI_HWPCS=y
+CONFIG_S32K1XX_LPUART0=y
+CONFIG_S32K1XX_LPUART1=y
+CONFIG_S32K1XX_NRSTCHECK_PROCFS=y
+CONFIG_S32K1XX_PORTAINTS=y
+CONFIG_S32K1XX_PORTBINTS=y
+CONFIG_S32K1XX_PORTCINTS=y
+CONFIG_S32K1XX_PORTDINTS=y
+CONFIG_S32K1XX_PORTEINTS=y
+CONFIG_S32K1XX_RESETCAUSE_PROCFS=y
+CONFIG_S32K1XX_RTC=y
+CONFIG_SCHED_CPULOAD=y
+CONFIG_SCHED_INSTRUMENTATION=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER=y
+CONFIG_SCHED_INSTRUMENTATION_FILTER_DEFAULT_MODE=0x0B
+CONFIG_SCHED_INSTRUMENTATION_IRQHANDLER=y
+CONFIG_SCHED_INSTRUMENTATION_SWITCH=y
+CONFIG_SCHED_LPWORK=y
+CONFIG_SCHED_LPWORKSTACKSIZE=1536
+CONFIG_SCHED_WAITPID=y
+CONFIG_SEGGER_RTT_BUFFER_SIZE_DOWN=2048
+CONFIG_SEGGER_RTT_BUFFER_SIZE_UP=2048
+CONFIG_SEGGER_RTT_MAX_NUM_DOWN_BUFFERS=6
+CONFIG_SEGGER_RTT_MAX_NUM_UP_BUFFERS=6
+CONFIG_SEGGER_SYSVIEW=y
+CONFIG_SEGGER_SYSVIEW_RTT_BUFFER_SIZE=6144
+CONFIG_SIG_DEFAULT=y
+CONFIG_SMBUS_SBD=y
+CONFIG_SPI_DRIVER=y
+CONFIG_SSD1306_POWEROFF_RECONFIGURE=y
+CONFIG_STACK_COLORATION=y
+CONFIG_START_DAY=25
+CONFIG_START_MONTH=5
+CONFIG_START_YEAR=2022
+CONFIG_STDIO_DISABLE_BUFFERING=y
+CONFIG_SYMTAB_ORDEREDBYNAME=y
+CONFIG_SYSLOG_DEVPATH="/dev/ttyS0"
+CONFIG_SYSTEM_NSH=y
+CONFIG_USERLED=y
+CONFIG_USERLED_LOWER=y
+CONFIG_USERLED_LOWER_READSTATE=y
+CONFIG_VIDEO_FB=y
diff --git a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
index f9c98396c2..ba0dc1ba94 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
+++ b/boards/arm/s32k1xx/rddrone-bms772/include/rcS.template
@@ -1,7 +1,8 @@
 # Initialize the RDDRONE-BMS772 BMS application
 echo "Available memory after board initialization:"
 "free"
-echo "Bring up can0 interface:"
-"ifup" "can0"
+# echo "NOT bringing up can0 interface"
+# echo "Bring up can0 interface:"
+# "ifup" "can0"
 echo "RDDRONE-BMS772: Starting BMS application"
-"bms"
\ No newline at end of file
+"bms"
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
index f9865c7f9d..61114c4c00 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/rddrone-bms772.h
@@ -77,10 +77,6 @@
 
 #define NUM_OF_GPIO 12
 
-/* Count of peripheral clock user configurations */
-
-#define NUM_OF_PERIPHERAL_CLOCKS_0 12
-
 /****************************************************************************
  * Public Data
  ****************************************************************************/
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
index f628d415e5..a6cf7ce645 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_clockconfig.c
@@ -163,7 +163,6 @@ const struct clock_configuration_s g_initial_clkconfig =
   },
   .pcc             =
   {
-    .count         = NUM_OF_PERIPHERAL_CLOCKS_0,       /* Number peripheral clock configurations */
     .pclks         = g_peripheral_clockconfig0,        /* Peripheral clock configurations */
   },
   .pmc             =
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
index 81f3b4783d..dfc45df09a 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_nrstcheck_procfs.c
@@ -289,6 +289,9 @@ int s32k1xx_nrstcheck_procfs_register(void)
       return ret;
     }
 
+  /* Sleep for a small amount of time for the NRST pin to become low */
+  usleep(10);
+
   /* Read the input level of the pin, which should be pulled high externally
    * by a resistor or another IC
    */
diff --git a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
index 969eb59402..f07236dbca 100644
--- a/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
+++ b/boards/arm/s32k1xx/rddrone-bms772/src/s32k1xx_periphclocks.c
@@ -40,6 +40,14 @@
 
 const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
 {
+  {
+    .clkname = DMAMUX0_CLK,
+#ifdef CONFIG_S32K1XX_EDMA
+    .clkgate = true,
+#else
+    .clkgate = false,
+#endif
+  },
   {
     .clkname = FLEXCAN0_CLK,
 #ifdef CONFIG_S32K1XX_FLEXCAN0
@@ -123,6 +131,10 @@ const struct peripheral_clock_config_s g_peripheral_clockconfig0[] =
   },
 };
 
+unsigned int const num_of_peripheral_clocks_0 =
+    sizeof(g_peripheral_clockconfig0) /
+    sizeof(g_peripheral_clockconfig0[0]);
+
 /****************************************************************************
  * Public Functions
  ****************************************************************************/
diff --git a/net/can/can_recvmsg.c b/net/can/can_recvmsg.c
index 536e72a1ed..8b18529049 100644
--- a/net/can/can_recvmsg.c
+++ b/net/can/can_recvmsg.c
@@ -290,7 +290,7 @@ static inline int can_readahead(struct can_recvfrom_s *pstate)
       if (!conn->fd_frames)
 #endif
         {
-          if (recvlen > sizeof(struct can_frame))
+          if (iob->io_pktlen > sizeof(struct can_frame))
             {
               return 0;
             }
@@ -625,12 +625,12 @@ ssize_t can_recvmsg(FAR struct socket *psock, FAR struct msghdr *msg,
    */
 
   ret = can_readahead(&state);
-  if (ret > 0)
+  if (1)
     {
 #ifdef CONFIG_NET_TIMESTAMP
       if (conn->sconn.s_timestamp)
         {
-          if (state.pr_msglen == sizeof(struct timeval))
+          if (state.pr_msglen == sizeof(struct timeval) && ret > 0)
             {
               can_readahead_timestamp(conn, state.pr_msgbuf);
             }
diff --git a/net/utils/net_lock.c b/net/utils/net_lock.c
index 5dc6967c4c..be8f8d7915 100644
--- a/net/utils/net_lock.c
+++ b/net/utils/net_lock.c
@@ -244,7 +244,7 @@ int net_trylock(void)
 
 void net_unlock(void)
 {
-  DEBUGASSERT(g_holder == getpid() && g_count > 0);
+  DEBUGASSERT(g_count > 0);
 
   /* If the count would go to zero, then release the semaphore */
 
diff --git a/sched/semaphore/sem_trywait.c b/sched/semaphore/sem_trywait.c
index 4e9cc0ea01..dc1dbe83ae 100644
--- a/sched/semaphore/sem_trywait.c
+++ b/sched/semaphore/sem_trywait.c
@@ -70,10 +70,11 @@ int nxsem_trywait(FAR sem_t *sem)
   irqstate_t flags;
   int ret;
 
-  /* This API should not be called from interrupt handlers & idleloop */
+  /* This API should not be called from the idleloop */
 
-  DEBUGASSERT(sem != NULL && up_interrupt_context() == false);
-  DEBUGASSERT(!OSINIT_IDLELOOP() || !sched_idletask());
+  DEBUGASSERT(sem != NULL);
+  DEBUGASSERT(!OSINIT_IDLELOOP() || !sched_idletask() ||
+              up_interrupt_context());
 
   if (sem != NULL)
     {
-- 
2.25.1

